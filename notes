#!/usr/bin/env bash
#              _
#  _ __   ___ | |_ ___  ___
# | '_ \ / _ \| __/ _ \/ __|
# | | | | (_) | ||  __/\__ \
# |_| |_|\___/ \__\___||___/
#
# A git-backed, syncable, searchable command line note-taking tool in a single
# portable script.
#
# https://github.com/xwmx/notes
#
# Based on Bash Boilerplate: https://github.com/xwmx/bash-boilerplate
#
# Copyright (c) 2015 William Melody â€¢ hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
set -o noglob
IFS=$'\n\t'

###############################################################################
# Environment
###############################################################################

_VERSION="2.7.2"

# $_ME
#
# Set to the program's basename.
_ME="$(basename "${0}")"

# $_MY_PATH
#
# Set to the programs full path.
_MY_PATH="$(cd "$(dirname "$0")"; pwd)/$(basename "${0}")"

# extglob
#
# Enable extended pattern matching operators.
#
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
shopt -s extglob

# $_SED_I_COMMAND
#
# `sed -i` takes an extension on macOS, but that extension can cause errors in
# GNU `sed`.
#
# NOTE: To use this command, call it with `"${_SED_I_COMMAND[@]}"`
#
# https://stackoverflow.com/q/43171648
# http://stackoverflow.com/a/16746032
if sed --help >/dev/null 2>&1
then # GNU
  export _SED_I_COMMAND=(sed -i)
else # macOS
  export _SED_I_COMMAND=(sed -i '')
fi

###############################################################################
# .notesrc
###############################################################################

# .notesrc
#
# If a `.notesrc` file exists in `$HOME`, source it.
export NOTESRC_PATH="${NOTESRC_PATH:-${HOME}/.notesrc}"
if [[ -e "${NOTESRC_PATH}" ]]
then
  # shellcheck disable=SC1090
  #
  # Shellcheck can't follow non-constant source.
  #
  # More information:
  #   https://github.com/koalaman/shellcheck/wiki/SC1090
  source "${NOTESRC_PATH}"
fi

###############################################################################
# $EDITOR
###############################################################################

# Set default $EDITOR if one has not been set.
if [[ -z "${EDITOR:-}" ]]
then
  if hash "code" 2>/dev/null
  then
    export EDITOR="code"
  elif hash "subl" 2>/dev/null
  then
    export EDITOR="subl"
  elif hash "mate" 2>/dev/null
  then
    export EDITOR="mate"
  elif hash "nano" 2>/dev/null
  then
    export EDITOR="nano"
  elif hash "vi" 2>/dev/null
  then
    export EDITOR="vi"
  else
    _die printf "\$EDITOR not found. Set the editor in ~/.notesrc\n"
  fi
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  %s " "${__DEBUG_COUNTER}"
    "${@}"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "${@}"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "âŒ  "
  "${@}" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "${@}"
}

###############################################################################
# Setup
###############################################################################

# `$NOTES_DIR`
#
# Default: `$HOME/.notes`
export NOTES_DIR="${NOTES_DIR:-${HOME}/.notes}"

# `$NOTES_DATA_DIR`
#
# Default: `$NOTES_DIR/home`
export NOTES_DATA_DIR="${NOTES_DATA_DIR:-${NOTES_DIR}/home}"
_set_notes_data_dir() {
  if [[ -e "${NOTES_DIR}/.current" ]]
  then
    local _current
    _current="$(cat "${NOTES_DIR}/.current")"
    if [[ -e "${NOTES_DIR}/${_current}" ]]
    then
      NOTES_DATA_DIR="${NOTES_DIR}/${_current}"
    fi
  fi
}
_set_notes_data_dir

# `$NOTES_AUTO_SYNC`
#
# Default: 1
#
# When set to '1', each `_git_checkpoint()` call will automativally run
# `$_ME sync`. To disable this behavior, set the value to '0'.
export NOTES_AUTO_SYNC="${NOTES_AUTO_SYNC:-1}"

# `$NOTES_DEFAULT_EXTENSION`
#
# Default: 'md'
#
# Example Values: 'md' 'org'
export NOTES_DEFAULT_EXTENSION="${NOTES_DEFAULT_EXTENSION:-md}"

# `$NOTES_ENCRYPTION_TOOL`
#
# Default: 'openssl'
#
# Supported Values: 'gpg' 'openssl'
export NOTES_ENCRYPTION_TOOL="${NOTES_ENCRYPTION_TOOL:-openssl}"

###############################################################################
# Helpers
###############################################################################

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Takes a potential command name as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
#
# Returns:
#   0  If the item is included in the list.
#   1  If not.
_contains() {
  local _test_list=(${*:2})
  for __test_element in "${_test_list[@]:-}"
  do
    _debug printf "_contains() \${__test_element}: %s\\n" "${__test_element}"
    if [[ "${__test_element}" == "${1}" ]]
    then
      _debug printf "_contains() match: %s\\n" "${1}"
      return 0
    fi
  done
  return 1
}

# _decrypt_file
#
# Usage:
#   _decrypt_file <path> <password>
_decrypt_file() {
  local _encrypted_path="${1:-}"
  local _password="${2:-}"

  if [[ -z "${_password}" ]]
  then
    printf "Password required.\n"
    return 1
  fi

  if [[ -z "${_encrypted_path}" ]]
  then
    return 1
  fi

  local _basename
  _basename="$(basename "${_encrypted_path}")"

  local _unencrypted_basename
  _unencrypted_basename="$(printf "%s" "${_basename}" | sed 's/.enc$//')"

  local _unencrypted_path
  _unencrypted_path="/tmp/notes-n-$(date -u "+%Y%m%d%H%M%S")-${_unencrypted_basename}"

  local _file_command_response
  _file_command_response="$(file "${_encrypted_path}")"

  if [[ "${_file_command_response}" =~ GPG ]]
  then
    if _command_exists "gpg"
    then
      printf "%s\\n" "${_password}" \
        | gpg \
          --batch \
          --passphrase-fd 0 \
          --output "${_unencrypted_path}" \
          --decrypt "${_encrypted_path}"
    else
      printf "\
This note was encrypted with GPG, but the GPG command was not found.\n"
      return 1
    fi
  elif [[ "${_file_command_response}" =~ openssl ]]
  then
    openssl enc -d -aes-256-cbc \
      -in "${_encrypted_path}" -out "${_unencrypted_path}" \
      -pass file:<(printf "%s\\n" "${_password}") 2> /dev/null ||
      rm "${_unencrypted_path}"
  else
    printf "Unable to decrypt file.\\n"
    return 1
  fi

  if [[ ! -e "${_unencrypted_path}" ]]
  then
    printf "Decryption error.\n" 1>&2
    return 1
  fi

  printf "%s\n" "${_unencrypted_path}"
}

# _edit_file()
#
# Usage:
#   _edit_file <path>
#
# Description:
#   Open the file in $EDITOR. Use the `-f` option in vim and `--wait` option in
#   other GUI editors to wait until the file is closed in the editor before
#   continuing.
_edit_file() {
  local _file_path="${1:-}"
  if [[ -z "${_file_path}" ]]
  then
    return 1
  fi

  cd "${NOTES_DATA_DIR}" || return 1

  if _file_is_encrypted "${_file_path}"
  then
    printf "\
Can't edit encrypted files. Export file and decrypt to edit.\n"
    exit 1
  fi

  if _file_is_archive "${_file_path}"
  then
    printf "\
Can't edit archives. Export archive and expand to edit.\n"
    exit 1
  fi

  if ! _file_is_text "${_file_path}"
  then
    if _command_exists "xdg-open"
    then
      xdg-open "${_file_path}" && return 0
    elif [[ "${OSTYPE}" =~ ^darwin ]]
    then
      open "${_file_path}" && return 0
    fi
  fi

  if [[ "${EDITOR}" =~ mvim ]] ||
     [[ "${EDITOR}" =~ gvim ]]
  then
    "${EDITOR}" -f "${_file_path}"
  elif [[ "${EDITOR}" =~ code ]] ||
       [[ "${EDITOR}" =~ mate ]] ||
       [[ "${EDITOR}" =~ subl ]]
  then
    "${EDITOR}" --wait "${_file_path}"
  else
    "${EDITOR}" "${_file_path}"
  fi
}

# _encrypt_file
#
# Usage:
#   _encrypt_file <decrypted path> <encrypted path> <password>
_encrypt_file() {
  local _decrypted_path="${1:-}"
  local _encrypted_path="${2:-}"
  local _password="${3:-}"

  if [[ -z "${_password}" ]]
  then
    printf "Password required.\n"
    return 1
  fi

  if [[ -z "${_decrypted_path}" ]] ||
     [[ -z "${_encrypted_path}" ]]
  then
    printf "Encrypted and decripted paths required.\n"
    return 1
  fi

  if [[ "${NOTES_ENCRYPTION_TOOL}" == "gpg" ]]
  then
    printf "%s\n" "${_password}" \
      | gpg \
        --batch \
        --passphrase-fd 0 \
        --output "${_encrypted_path}" \
        --symmetric \
        --cipher-algo AES256 \
        "${_decrypted_path}"
  elif [[ "${NOTES_ENCRYPTION_TOOL}" == "openssl" ]]
  then
    openssl enc -aes-256-cbc \
      -in "${_decrypted_path}" \
      -out "${_encrypted_path}" \
      -pass file:<(printf "%s\n" "${_password}")
  else
    printf "\$NOTES_ENCRYPTION_TOOL must be set to either 'gpg' or 'openssl'."
    return 1
  fi

  if [[ ! -e "${_encrypted_path}" ]]
  then
    printf "Encryption error.\n"
    return 1
  fi
}

# _file_is_archive()
#
# Usage:
#   _file_is_archive <path>
#
# Returns:
#   1  If file is an archive.
#   0  if not.
_file_is_archive() {
  [[ "$(file "${1:-}" | cut -d: -f2)" =~ archive|compressed ]]
}

# _file_is_encrypted()
#
# Usage:
#   _file_is_encrypted <path>
#
# Returns:
#   1  If file is encrypted.
#   0  if not.
_file_is_encrypted() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # `file` with 'soft' test is slow, so avoid calling it.
  [[ "${_file_type}" == "enc" ]] ||
    [[ ! "$(file "${1:-}" \
            -b --mime-type \
            --exclude=apptype \
            --exclude=encoding \
            --exclude=tokens \
            --exclude=cdf \
            --exclude=compress \
            --exclude=elf \
            --exclude=soft \
            --exclude=tar)" =~ ^text ]] &&
    # [[ "$(dd bs=1 count=6 if="${_file_path}" 2>/dev/null)" == 'Salted'  ]] ||
    [[ "$(file "${_file_path:-}" \
            --exclude=apptype \
            --exclude=encoding \
            --exclude=tokens \
            --exclude=cdf \
            --exclude=compress \
            --exclude=elf \
            --exclude=tar)" =~ encrypted|openssl ]]
}

# _file_is_text()
#
# Usage:
#   _file_is_text <path>
#
# Returns:
#   1  If file is text.
#   0  if not.
_file_is_text() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # Avoid calling `file` for better performance.
  [[ "${_file_type}" =~ ^html|latex|md|markdown|org|rst|textile|txt$ ]] ||
    [[ "$(file -b --mime-type "${1:-}")" =~ ^text ]]
}

# _get_hash()
#
# Usage:
#   _get_hash <path>
#
# Description:
#   Generate a hash for the file at the given <path>.
_get_hash() {
  local _hash
  if _command_exists "md5sum"
  then
    _hash="$(md5sum "${1:-}" | awk '{ print $1 }')"
  elif _command_exists "md5"
  then
    _hash="$(md5 -q "${1:-}")"
  fi
  printf "%s\\n" "${_hash}"
}

# _get_selection_basename()
#
# Usage:
#   _get_selection_basename <id>
#   _get_selection_basename <filename>
#   _get_selection_basename <path>
#   _get_selection_basename <title>
#
# Description:
#   Determine the basename of the file in `$NOTES_DATA_DIR` that is identified
#   by the given <id>, <filename>, <path>, or <title>.
_get_selection_basename() {
  local _basename=
  local _selection="${1:-}"
  local _identifier=
  if [[ -z "${_selection}" ]]
  then  # <selection> is blank.
    _basename=
  else

    _set_selection_notebook "${_selection}"
    _identifier="$(_get_selection_identifier "${_selection}")"

    if [[ -e "${_identifier}" ]] &&
       [[ "${_identifier}" =~ ${NOTES_DATA_DIR} ]]
    then # <selection> is a full path.
      _basename="$(basename "${_identifier}")"
    elif [[ -e "${NOTES_DATA_DIR}/${_identifier}" ]]
    then # <selection> is a filename.
      _basename="${_identifier}"
    elif [[ "${_identifier}" =~ ^[0-9]+$ ]]
    then # <selection> is an id.
      _basename="$(_index get_basename "${_identifier}")"
    else # <selection> might be a title.
      local _title
      local _filenames

      _filenames=($(_list_notes_files))
      for __file in "${_filenames[@]:-}"
      do
        _title="$(_get_title "${__file}")"

        if [[ -n "${_title}" ]] &&
           [[ "${_title}" == "${_identifier}" ]]
        then
          _basename="${__file}"
          break
        fi
      done
    fi
  fi

  printf "%s\\n" "${_basename}"
}

# _get_selection_identifier()
#
# Usage:
#   _get_selection_identifier <selection>
#
# Description:
#   Given <selection>, print the identifier portion.
_get_selection_identifier() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))
  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    printf "%s\\n" "${_parts[1]:-}"
  else
    printf "%s\\n" "${_parts[0]:-}"
  fi
}

# _get_selection_parts()
#
# Usage:
#   _get_selection_parts <selection>
#
# Description:
#   Given <selection>, split on first colon.
_get_selection_parts() {
  local _identifier
  local _data_dir

  _data_dir=$(printf "%s\\n" "${1:-}" | cut -f 1 -d ":")

  if [[ "${1:-}" =~ ':'       ]] &&
     [[ -e "${NOTES_DIR}/${_data_dir}/.git" ]]
  then
    _identifier=$(printf "%s\\n" "${1:-}" | cut -f 2- -d ":")
    printf "%s\\n%s\\n" "${_data_dir}" "${_identifier}"
  else
    printf "%s\\n" "${1:-}"
  fi
}

# _get_title()
#
# Usage:
#   _get_title <basename> [<scope>]
#
# Description:
#   Print the title, if present, of the note with the given basename in
#   `$NOTES_DATA_DIR` or <scope>.
_get_title() {
  local _basename="${1:-}"
  local _scope="${2:-}"
  local _data_dir="${NOTES_DATA_DIR}"
  local _title=

  if [[ -n "${_scope}" ]]
  then
    _data_dir="${NOTES_DIR}/${_scope}"
  fi

  if [[ -z "${_basename}" ]]
  then
    _die printf "Usage: _get_title <basename>\\n"
  elif [[ -e "${_data_dir}/${_basename}" ]]
  then
    if _file_is_text "${_data_dir}/${_basename}"
    then
      _maybe_title="$(head -1 "${_data_dir}/${_basename}")"
      if [[ "${_maybe_title}" =~ ^#\  ]]
      then # first line starts with an H1
        _title="$(printf "%s\\n" "${_maybe_title}" | sed 's/^\# //')"
      fi
      printf "%s\\n" "${_title}"
    fi
  fi
}

# _get_unique_basename()
#
# Usage:
#   _get_unique_basename [<file name> | <file extension>]
#
# Description:
#   Get a unique basename that doesn't conflict with any existing file.
_get_unique_basename() {
  local _file_basename="${1:-}"

  local _file_name="${_file_basename%.*}"
  if [[ -z "${_file_name}" ]]
  then
    _file_name="$(date -u "+%Y%m%d%H%M%S")"
  fi

  local _file_type="${_file_basename##*.}"
  if [[ -z "${_file_type}" ]]
  then
     _file_type="md"
  fi

  local _uniqueness_counter=0
  local _unique_filename="${_file_name}"
  while [[ -e "${NOTES_DATA_DIR}/${_unique_filename}.${_file_type}" ]]
  do
    printf -v _unique_filename -- "%s-%02d" \
      "${_file_name}" \
      "$(( ++_uniqueness_counter ))"
  done
  printf "%s\n" "${_unique_filename}.${_file_type}"
}

# _git_checkpoint()
#
# Usage:
#   _git_checkpoint <commit message> [<target-directory>]
#
# Description:
#   Commit all files in the repository with the provided commit message.
_git_checkpoint() {
  _git_checkpoint_commit() {
    [[ -z "${1:-}" ]] && _die printf "Usage: _git_checkpoint_commit <message>"
    _debug printf "_git_checkpoint() \$(ls -la): '%s'\n" \
      "$(ls -la)"

    git add --all && git commit -a -m "${1}"
  }
  _git_checkpoint_sync() {
    if git show-branch remotes/origin/master > /dev/null 2>&1
    then
      git fetch && git rebase origin/master && git push
    else
      git push
    fi
  }

  local _message=
  local _show_spinner=0
  local _target_directory=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --spinner)
        _show_spinner=1
        ;;
      *)
        if [[ -z "${_message}" ]]
        then
          _message="${__arg}"
        elif [[ -z "${_target_directory}" ]]
        then
          _target_directory="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_target_directory}" ]]
  then
    _target_directory="${NOTES_DATA_DIR}"
  fi

  _debug printf "_git_checkpoint() \${_target_directory}: '%s'\n" \
    "${_target_directory}"

  if [[ -z "${_message}" ]]
  then
    _die printf "Usage: _git_checkpoint <message>\\n"
    return 1
  fi

  if [[ -n "${2:-}" ]] && [[ "${2}" == "--spinner" ]]
  then
    _show_spinner=1
  fi

  cd "${_target_directory}" || _die printf "_git_checkpoint() \`cd\` failed.\\n"

  _debug printf "_git_checkpoint() \$(ls -la): '%s'\n" \
    "$(ls -la)"

  if ((NOTES_AUTO_SYNC))
  then
    (
      # Only sync when the index is dirty to avoid fetching from and pushing
      # to origin.
      if _git_index_is_dirty "${_target_directory}"
      then
        _git_checkpoint_commit "${_message}" &>/dev/null
      fi && _git_checkpoint_sync &>/dev/null
    ) &
  else
    (
      _git_checkpoint_commit "${_message}" &>/dev/null
    ) &
  fi

  if ((_show_spinner))
  then
    _spinner ${!}
  fi
}

# _git_index_is_dirty()
#
# Usage:
#   _git_index_is_dirty [<target-directory>]
#
# Returns:
#   0  If there are uncommitted changes in `NOTES_DATA_DIR` or
#      <target-directory>.
#   1  If the `$NOTES_DATA_DIR` repository is clean.
_git_index_is_dirty() {
  local _target_directory="${1:-}"
  if [[ -z "${_target_directory}" ]]
  then
    _target_directory="${NOTES_DATA_DIR}"
  fi

  cd "${_target_directory}" ||
    _die printf "_git_index_is_dirty() \`cd\` failed.\\n"
  [[ -n "$(git status --porcelain)" ]]
}

# _git_required()
#
# Usage:
#   _git_required
#
# Description:
#   Exit with `_die` if `git` isn't found.
_git_required() {
  if ! _command_exists "git"
  then
    _die printf "\`git\` is required, but wasn't found.\\n"
  fi

  local _git_name
  _git_name="$(git config user.name || printf '')"
  local _git_email
  _git_email="$(git config user.email || printf '')"

  if [[ -z "${_git_name}" ]] || [[ -z "${_git_email}" ]]
  then
    printf "git configuration incomplete. To set your name and email, run:\\n"
    if [[ -z "${_git_name}" ]]
    then
      printf "git config --global user.name \"Your Name\"\\n"
    fi
    if [[ -z "${_git_email}" ]]
    then
      printf "git config --global user.email \"you@example.com\"\\n"
    fi
    return 1
  fi
}

# _git_should_autosync()
#
# Usage:
#   _git_should_autosync
#
# Returns:
#   0  If an autosync should be triggered.
#   1  If not.
_git_should_autosync() {
  local _last_fetch_timestamp
  local _current_timestamp

  if ! ((NOTES_AUTO_SYNC))
  then # autosync not enabled.
    return 1
  fi

  cd "${NOTES_DATA_DIR}" || _die printf "\`cd\` failed.\\n"
  if ! git config --get remote.origin.url &>/dev/null
  then # there is no remote configured.
    return 1
  fi

  if [[ ! -e "${NOTES_DATA_DIR}/.git/FETCH_HEAD" ]]
  then # no previous fetches, but has an origin and autosync is enabled.
    return 0
  fi

  if stat -c &>/dev/null
  then # GNU
    _last_fetch_timestamp="$(stat -c %Y .git/FETCH_HEAD)"
  elif gstat -c &>/dev/null
  then # GNU prefixed
    _last_fetch_timestamp="$(gstat -c %Y .git/FETCH_HEAD)"
  else
    _last_fetch_timestamp="$(stat -f '%m' .git/FETCH_HEAD)"
  fi
  _current_timestamp="$(date +%s)"

  _diff=$((_current_timestamp-_last_fetch_timestamp))
  _debug printf \
    "_git_should_sync() \${_last_fetch_timestamp}: %s\\n" \
    "${_last_fetch_timestamp}"
  _debug printf \
    "_git_should_sync() \${_current_timestamp}: %s\\n" \
    "${_current_timestamp}"
  _debug printf \
    "_git_should_sync() \${_diff}: %s\\n" \
    "${_diff}"

  [[ "${_diff}" -gt 300 ]]
}

# _highlight()
#
# Usage:
#   _highlight <string>
#
# Description:
#   Use `tput` to highlight the given string.
_highlight() {
  local _input="${1:-}"
  if [[ -z "${_input}" ]]
  then
    _die printf "Usage: _highlight <string>"
  fi
  printf "$(tput setaf 3)%s$(tput sgr0)\\n" "${_input}"
}

# _highlight_syntax_if_available()
#
# Usage:
#   _highlight_syntax_if_available [<path>]
#
# Description:
#   If Pygments is available, use it to highlight syntax. When it is not
#   available, just pipe through `cat`.
#
# References:
#   http://pygments.org/
_highlight_syntax_if_available() {
  if hash "pygmentize" 2>/dev/null
  then # pygments is installed.
    local _path="${1:-}"
    local _basename
    _basename="$(basename "${_path}")"

    local _extension="${_basename##*.}"

    # Markdown highlighting is better with explicit 'md' lexer.
    [[ ! "${_extension}" == "md" ]] &&
      pygmentize -O style=pastie "${@}" 2>/dev/null ||
      pygmentize -l md -O style=pastie "${@}"
  else
    cat "${@}"
  fi
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _join()
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
#
# Returns:
#   The list or array of items joined into a string with elements divided by
#   the optional separator if one is provided.
#
# More information:
#   https://stackoverflow.com/a/17841619
_join() {
  local _delimiter="${1}"
  shift
  printf "%s" "${1}"
  shift
  printf "%s" "${@/#/${_delimiter}}" | tr -d '[:space:]'
}

# _list_notes_files()
#
# Usage:
#   _list_notes_files [--sort] [--reverse]
#
# Description:
#   List note files with default sorting.
_list_notes_files() {
  # Relevant `ls` options:
  # --  Default sort order.
  # -t  Sort by time modified (most recently modified first) before sorting
  #     the operands by lexicographical order
  # -r  Reverse the order of the sort to get reverse order or the oldest
  #     entries first (or largest files last, combined with sort by size

  if [[ "${1:-}" == "--sort" ]]
  then
    local _index_file
    _index_file="$(cat "${NOTES_DATA_DIR}/.index")"
    local _filenames=()
    for __line in "${_index_file[@]}"
    do
      if [[ -n "${__line}" ]]
      then
        _filenames+=("${__line}")
      fi
    done

    if [[ "${2:-}" == "--reverse" ]]
    then
      printf "%s\n" "${_filenames[@]}" | sort -r
    else
      printf "%s\n" "${_filenames[@]}"
    fi
  else
    ls -t "${NOTES_DATA_DIR}"
  fi
}

# __option_value_is_present()
#
# Usage:
#   __option_value_is_present "${variable}"
#
# Returns:
#   0  The argument is blank or matches as an option flag.
#   1  The argument is present and does not match an option flag.
__option_value_is_present() {
  [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
}

# _print_line()
#
# Usage:
#   _print_line <text>
#
# Description:
#   Print a line of dashes the length of <text>.
#
# More information:
#   http://wiki.bash-hackers.org/commands/builtin/printf
_print_line() {
  local _text="${1:-}"
  local _text_length=0
  local _line=
  _text_length=${#_text}
  printf -v _line '%*s' "${_text_length}"
  printf "%s\\n" "${_line// /-}"
}

# _set_selection_notebook()
#
# Usage:
#   _set_selection_notebook <selection>
#
# Description:
#   Given <selection>, set `$_SCOPE` and `$NOTES_DATA_DIR` with the notebook
#   name, if present.
_set_selection_notebook() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))
  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    NOTES_DATA_DIR="${NOTES_DIR}/${_parts[0]}"
    _SCOPE="$(basename "${NOTES_DATA_DIR}")"
  fi
}

# _spinner()
#
# Usage:
#   _spinner <pid>
#
# Description:
#   Display an ascii spinner while <pid> is running.
#
# Example Usage:
#   ```
#   _spinner_example() {
#     printf "Working..."
#     (sleep 1) &
#     _spinner $!
#     printf "Done!\\n"
#   }
#   (_spinner_example)
#   ```
#
# More Information:
#   http://fitnr.com/showing-a-bash-spinner.html
_spinner() {
  local _pid="${1:-}"
  local _delay=0.75
  local _spin_string="|/-\\"

  if [[ -z "${_pid}" ]]
  then
    _die printf "Usage: _spinner <pid>\\n"
  fi

  while ps a | awk '{print $1}' | grep -q "${_pid}"
  do
    local _temp="${_spin_string#?}"
    printf " [%c]  " "${_spin_string}"
    _spin_string="${_temp}${_spin_string%${_temp}}"
    sleep ${_delay}
    printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
#
# Examples:
# ```
#   desc "list" <<HEREDOC
# Usage:
#   ${_ME} list
#
# Description:
#   List items.
# HEREDOC
#
# desc --get "list"
# ```
#
# Set or print a description for a specified command or function <name>. The
# <description> text can be passed as the second argument or as standard input.
#
# To make the <description> text available to other functions, `desc()` assigns
# the text to a variable with the format `$___desc_<name>`.
#
# When the `--get` option is used, the description for <name> is printed, if
# one has been set.
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'HEREDOC'
# some message
# HEREDOC
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z "${1:-}" ]] && _die printf "desc(): No command name specified.\\n"

  if [[ "${1}" == "--get" ]]
  then # get ------------------------------------------------------------------
    [[ -z "${2:-}" ]] && _die printf "desc(): No command name specified.\\n"

    local _name="${2:-}"
    local _desc_var="___desc_${_name}"

    if [[ -n "${!_desc_var:-}" ]]
    then
      printf "%s\\n" "${!_desc_var}"
    else
      printf "No additional information for \`%s\`\\n" "${_name}"
    fi
  else # set ------------------------------------------------------------------
    if [[ -n "${2:-}" ]]
    then # argument is present
      read -r -d '' "___desc_${1}" <<HEREDOC
${2}
HEREDOC

      _debug printf "desc() set with argument: \${___desc_%s}\\n" "${1}"
    else # no argument is present, so assume piped input
      read -r -d '' "___desc_${1}"

      _debug printf "desc() set with pipe: \${___desc_%s}\\n" "${1}"
    fi
  fi
  set -e
}

###############################################################################
# help
###############################################################################

desc "help" <<HEREDOC
Usage:
  ${_ME} help [<subcommand>]

Description:
  Print the program help information. When a subcommand name is passed, the
  print the help information for the subcommand.
HEREDOC
_help() {
  if [[ -z "${1:-}" ]]
  then
    cat <<HEREDOC
             _
 _ __   ___ | |_ ___  ___
| '_ \ / _ \| __/ _ \/ __|
| | | | (_) | ||  __/\__ \\
|_| |_|\___/ \__\___||___/

A git-backed, syncable, searchable command line note-taking tool.

Usage:
  ${_ME} [<id> | <filename> | <path> | <title>] [<list options>]
  ${_ME} add [<filename> | <content>] [-c | --content <content>]
            [-e | --encrypt] [-f | --filename <filename>]
            [-t | --title <title>] [--type <type>]
  ${_ME} count
  ${_ME} delete (<id> | <filename> | <path> | <title>) [--force]
  ${_ME} edit (<id> | <filename> | <path> | <title>)
  ${_ME} export (<id> | <filename> | <path> | <title>) <path> [--force]
               [<pandoc options>...]
  ${_ME} git <git options>...
  ${_ME} history [<selection>]
  ${_ME} import [copy | download | move] (<path> | <url>) [--convert]
  ${_ME} init [<remote-url>]
  ${_ME} list [(-e | --excerpt) [<length>]] [--no-id] [-n <limit>] [--titles]
             [-s | --sort] [-r | --reverse] [<selection>]
  ${_ME} ls [<list options>...]
  ${_ME} move (<id> | <filename> | <path> | <title>) [--force] <notebook>
  ${_ME} notebook
  ${_ME} notebooks [<name>] [--names] [--no-color]
  ${_ME} notebooks add <name> [<remote-url>]
  ${_ME} notebooks current
  ${_ME} notebooks rename <old-name> <new-name>
  ${_ME} notebooks use <name>
  ${_ME} open
  ${_ME} remote [remove | set <url> [--force]]
  ${_ME} rename (<id> | <filename> | <path> | <title>) (<name> | --reset)
  ${_ME} search <query> [-a | --all] [--path]
  ${_ME} settings
  ${_ME} show (<id> | <filename> | <path> | <title>) [--id | --path | --render]
             [--dump [--no-color]]
  ${_ME} sync [-a|--all]
  ${_ME} use <notebook>
  ${_ME} -h | --help | help [<subcommand>]
  ${_ME} --version | version

Help:
  ${_ME} help [<subcommand>]

More Information:
  https://github.com/xwmx/notes
HEREDOC
  else
    desc --get "${@}"
  fi
}

###############################################################################
# Subcommands
###############################################################################

# add #########################################################################

desc "add" <<HEREDOC
Usage:
  ${_ME} add [<filename> | <content>] [-c | --content <content>]
            [-e | --encrypt] [-f | --filename <filename>]
            [-t | --title <title>] [--type <type>]

Options:
  -c | --content   <content>    The content for the new note.
  -e | --encrypt                Encrypt the note with a password.
  -f | --filename  <filename>   The filename for the new note.
  -t | --title     <title>      The title for a new note. If \`--title\` is
                                present, the filename will be derived from the
                                title, unless \`--filename\` is specified.
  --type           <type>       The file type for the new note, as a file
                                extension.

Description:
  Create a new note.

  If no arguments are passed, a new blank note file is opened with
  \`\$EDITOR\`, currently set to '${EDITOR}'. If a non-option argument is
  passed, \`notes\` will treat it as a <filenameâ‰¥ if a file extension is found.
  If no file extension is found, \`notes\` will treat the string as
  <content> and will create a new note without opening the editor.
  \`notes add\` can also create a new note with piped content.

  \`notes\` creates Markdown files by default. To create a note with a
  different file type, use the extension in the filename or use the \`--type\`
  option. To change the default file type, use \`notes settings\`.

  When the \`--encrypt\` option is specified, \`notes\` will encrypt the
  note with AES-256.

Examples:
  notes add
  nores add example.md
  notes add "Note content."
  notes add example.md --title "Example Title" --content "Example content."
  echo "Note content." | notes add

Alias: \`a\`
HEREDOC
_add() {
  local _basename=
  local _content=
  local _encrypt=0
  local _filename=
  local _maybe_filename_or_content=
  local _title=
  local _file_type="${NOTES_DEFAULT_EXTENSION}"
  local _arguments=()
  local _password=

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      -c|--content)
        if __option_value_is_present "${_val:-}"
        then
          _content="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      -e|--encrypt)
        _encrypt=1
        ;;
      -f|--filename)
        if __option_value_is_present "${_val:-}"
        then
          _filename="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      --password)
        if __option_value_is_present "${_val:-}"
        then
          _password="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      -t|--title)
        if __option_value_is_present "${_val:-}"
        then
          _title="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      --type)
        if __option_value_is_present "${_val:-}"
        then
          _file_type="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      *)
        if [[ -z "${_maybe_filename_or_title:-}" ]]
        then
          _maybe_filename_or_content="${_arg:-}"
        else
          _arguments+=("${_arg:-}")
        fi
        ;;
    esac

    shift
  done

  local _maybe_filename_or_content_extension="${_maybe_filename_or_content##*\.}"
  if [[ -n "${_maybe_filename_or_content:-}" ]]
  then
    if [[ "${_maybe_filename_or_content:-}" =~ \.[A-Za-z0-9]+$ ]] &&
       [[ -n "${_maybe_filename_or_content_extension:-}" ]]
    then
      _filename="${_maybe_filename_or_content}"
    else
      _content="${_maybe_filename_or_content}"
    fi
  fi

  if [[ -n "${_filename:-}" ]]
  then
    _basename="$(_get_unique_basename "${_filename:-}")"
  elif [[ -n "${_title:-}" ]]
  then
    _filename="$(printf "%s" "${_title}" | tr '[:space:]' '_')"
    _basename="$(_get_unique_basename "${_filename}.${_file_type}")"
  else
    _basename="$(_get_unique_basename ".${_file_type}")" # !! note the '.'
  fi

  _target_path="${NOTES_DATA_DIR}/${_basename}"

  if ((_encrypt))
  then
    if [[ -z "${_password}" ]]
    then
      printf "Password: "
      read -r -s _password </dev/tty
      printf "\\n" # print newline to stop `read`.

      if [[ -z "${_password:-}" ]]
      then
        printf "Password required.\n"
        return 1
      fi
    fi

    _target_path="/tmp/notes-n-$(date -u "+%Y%m%d%H%M%S")-${_basename}"
  fi

  if [[ -n "${_title}" ]]
  then
    printf "%s\\n\\n" "# ${_title}" >> "${_target_path}"
  fi

  if [[ -n "${_content}" ]]
  then
    printf "%s\\n" "${_content}" >> "${_target_path}"
  fi

  if _interactive_input
  then # terminal input.
    if [[ -z "${_content:-}" ]]
    then
      _edit_file "${_target_path}"
    fi
  else # piped input.
    cat >> "${_target_path}"
  fi

  if ((_encrypt))
  then
    local _decrypted_path="${_target_path}"
    local _encrypted_path="${NOTES_DATA_DIR}/${_basename}.enc"

    _encrypt_file "${_decrypted_path}" "${_encrypted_path}" "${_password}"

    if [[ -n "${_decrypted_path}" ]] && [[ -e "${_decrypted_path}" ]]
    then
      rm "${_decrypted_path}"
    fi

    _basename="${_basename}.enc"
    _target_path="${_encrypted_path}"
  fi

  _debug printf \
    "_add() \`\${_target_path}\`: '%s'\n" \
    "${_target_path:-}"

  if [[ -e "${_target_path}" ]]
  then
    _index add "${_basename}"

    local _title
    _title="$(_get_title "${_basename}")"
    if [[ -n "${_title}" ]]
    then
      printf "Added %s:%s '%s'\\n" \
        "${_SCOPE}" \
        "${_basename}" \
        "${_title}"
    else
      printf "Added %s:%s\\n" \
        "${_SCOPE}" \
        "${_basename}"
    fi
  fi &&
    _git_checkpoint "[NOTES] Add: ${_basename}"
}
desc "a" "$(_help 'add')"
_a() { _add "${@}"; }

# commands ####################################################################

desc "commands" <<HEREDOC
Usage:
  ${_ME} commands

Description:
  List available commands.
HEREDOC
_commands() {
  printf "%s\\n" "${_SUBCOMMANDS[*]}"
}

# count #######################################################################

desc "count" <<HEREDOC
Usage:
  ${_ME} count

Description:
  Print the number of notes files in the current notebook.
HEREDOC
_count() {
  _list_notes_files | wc -l
}

# delete ######################################################################

desc "delete" <<HEREDOC
Usage:
  ${_ME} delete (<id> | <filename> | <path> | <title>) [--force]

Options:
  --force  Skip the confirmation prompt.

Description:
  Delete a note.

Alias: \`d\`
HEREDOC
_delete() {
  local _basename=
  local _force=0
  local _note_info_line
  local _selection=
  local _title

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_delete() \${_selection}: '%s'\\n" "${_selection}"
  if [[ -z "${_selection:-}" ]]
  then
    _help "delete"
    return 1
  fi

  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_delete() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    printf "Note not found.\n"
    return 1
  fi

  _set_selection_notebook "${_selection}"

  if [[ -z "${_basename}" ]]
  then
    _help "delete"
    return 1
  fi
  _debug printf "_delete() \${_basename}: '%s'\\n" "${_basename}"

  _title="$(_get_title "${_basename}")"
  if [[ -n "${_title}" ]]
  then
    _note_info_line="${_SCOPE}:${_basename} '${_title}'"
  else
    _note_info_line="${_SCOPE}:${_basename}"
  fi

  if ! ((_force))
  then
    printf "Deleting %s\\n" "${_note_info_line}"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    cd "${NOTES_DATA_DIR}" || _die printf "_delete() \`cd\` failed.\\n"
    git rm "${_basename}" 1>/dev/null

    if [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]]
    then
      _index delete "${_basename}"
      _git_checkpoint "[NOTES] Delete: ${_basename}"
      printf "Deleted %s\\n" "${_note_info_line}"
    fi
  else
    printf "Selection not found.\\n"
    return 1
  fi
}
desc "d" "$(_help 'delete')"
_d() { _delete "${@}"; }

# edit ########################################################################

desc "edit" <<HEREDOC
Usage:
  ${_ME} edit (<id> | <filename> | <path> | <title>)

Description:
  Open the specified note in \`\$EDITOR\`, currently set to '${EDITOR}'. Any
  data piped to \`notes edit\` will be appended to the file.

  Non-text files will be opened in your system's preferred app or program for
  that file type.

Example:
  notes edit 1
  echo "Content to append." | noted edit 1

Alias: \`e\`
HEREDOC
_edit() {
  local _basename=
  local _password=
  local _selection="${1:-}"

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --password)
        if __option_value_is_present "${_val:-}"
        then
          _password="${_val:-}"
          shift
        else
          _help edit
          return 1
        fi
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "_edit() \${_selection}: %s\\n" "${_selection}"
  if [[ -z "${_selection:-}" ]]
  then
    _help "edit"
    return 1
  fi

  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_edit() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    printf "Note not found.\n"
    return 1
  fi

  _set_selection_notebook "${_selection}"

  if [[ -n "${_basename}" ]] || [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # _basename is assigned and a note exists with that name.
    local _target_file="${NOTES_DATA_DIR}/${_basename}"

    local _before
    _before="$(_get_hash "${NOTES_DATA_DIR}/${_basename}")"

    if _file_is_encrypted "${_target_file}"
    then
      local _encrypted_path
      _encrypted_path="${_target_file}"

      if [[ -z "${_password}" ]]
      then
        # Request password without displaying it
        printf "Password: "
        read -r -s _password </dev/tty
        printf "\\n" # print newline to stop `read`.
      fi

      local _decrypted_path
      _decrypted_path="$(_decrypt_file "${_target_file}" "${_password}")"

      _target_file="${_decrypted_path}"
    fi

    if _interactive_input
    then # terminal input.
      if [[ -z "${_content:-}" ]]
      then
        _edit_file "${_target_file}"
      fi
    else # piped input.
      cat >> "${_target_file}"
    fi

    if [[ -n "${_encrypted_path:-}" ]] && [[ -e "${_decrypted_path}" ]]
    then
      local _temp_encrypted_path="${_decrypted_path}.tmp"
      mv "${_encrypted_path}" "${_temp_encrypted_path}"
      _encrypt_file "${_decrypted_path}" "${_encrypted_path}" "${_password}"
      rm "${_temp_encrypted_path}" && rm "${_decrypted_path}"
    fi

    _git_checkpoint "[NOTES] Edit: ${_basename}"

    _after="$(_get_hash "${NOTES_DATA_DIR}/${_basename}")"
    _debug printf "_edit() \${_before}: %s\\n" "${_before}"
    _debug printf "_edit() \${_after}: %s\\n" "${_after}"

    if [[ "${_before}" != "${_after}" ]]
    then
      local _title
      _title="$(_get_title "${_basename}")"
      if [[ -n "${_title}" ]]
      then
        printf "Updated %s:%s '%s'\\n" \
          "${_SCOPE}" \
          "${_basename}" \
          "${_title}"
      else
        printf "Updated %s:%s\\n" \
          "${_SCOPE}" \
          "${_basename}"
      fi
    fi
  else
    printf "Selection not found.\\n"
    return 1
  fi
}
desc "e" "$(_help 'edit')"
_e() { _edit "${@}"; }

# env #########################################################################

desc "env" <<HEREDOC
Usage:
  ${_ME} env

Description:
  Print program environment variables.
HEREDOC
_env() {
  printf "NOTES_DIR=%s\\n" "${NOTES_DIR}"
  printf "NOTES_DATA_DIR=%s\\n" "${NOTES_DATA_DIR}"
  printf "NOTES_AUTO_SYNC=%s\\n" "${NOTES_AUTO_SYNC}"
  printf "NOTESRC_PATH=%s\\n" "${NOTESRC_PATH}"
  printf "EDITOR=%s\\n" "${EDITOR}"
}

# export ######################################################################

desc "export" <<HEREDOC
Usage:
  ${_ME} export (<id> | <filename> | <path> | <title>) <path> [--force]
               [<pandoc options>...]
  ${_ME} export pandoc (<id> | <filename> | <path> | <title>)
               [<pandoc options>...]

Options:
  --force    Skip the confirmation prompt when overwriting an existing file.

Subcommands:
  (default)  Export a file to <path>. If <path> has a different extension from
             the source note, convert the note using \`pandoc\`.
  pandoc     Export the file to standard output or a file using \`pandoc\`.
             \`export pandoc\` prints to standard output by default.

Description:
  Export a file from the notebook.

  If Pandoc [1] is available, convert the note from its current format
  to the format of the output file as indicated by the file extension
  in <path>. Any additional arguments are passed directly to Pandoc.
  See the Pandoc help information for available options.

  1. http://pandoc.org/

Examples:
  # Export an Emacs Org mode note
  ${_ME} export example.org /path/to/example.org

  # Export a Markdown note to HTML and print to standard output
  ${_ME} export pandoc example.md --from=markdown_strict

  # Export a Markdown note to a .docx Microsoft Office Word document
  ${_ME} export example.md /path/to/example.docx
HEREDOC
_export() {
  local _args=()
  local _force=0
  local _pandoc_only=0
  local _selection=
  local _target_path=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      pandoc)
        _pandoc_only=1
        ;;
      --force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${__arg}"
        elif ! ((_pandoc_only)) && [[ -z "${_target_path:-}" ]]
        then
          _target_path="${__arg}"
        else
          _args+=("${__arg}")
        fi
        ;;
    esac
  done

  if [[ -z "${_selection:-}" ]]
  then
    _help "export"
    return 1
  fi
  _debug printf "_export() \${_selection}: %s\\n" "${_selection}"

  local _basename
  _basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"

  if [[ -z "${_basename:-}" ]] || [[ ! -e "${NOTES_DATA_DIR}/${_basename:-}" ]]
  then
    printf "Note not found: %s\n" "${_selection}"
    return 1
  fi
  _debug printf "_export() \${_basename}: %s\\n" "${_basename}"

  if ((_pandoc_only))
  then
    if _command_exists 'pandoc'
    then
      if [[ -n "${_args[*]:-}" ]]
      then
        pandoc "${NOTES_DATA_DIR}/${_basename}" "${_args[@]:-}"
      else
        pandoc "${NOTES_DATA_DIR}/${_basename}"
      fi
    else
      printf "Pandoc required. http://pandoc.org/\n"
      return 1
    fi
  else
    if [[ -z "${_target_path:-}" ]]
    then
      _help "export"
      return 1
    fi
    _debug printf "_export() \${target_path}: %s\\n" "${_target_path}"

    if [[ -e "${_target_path:-}" ]]
    then
      if ! ((_force))
      then
        printf "File exists at '%s'\\n"  \
          "${_target_path}"
        while true
        do
          read -r -p "Overwrite existing file? [y/N] " __yn
          case ${__yn} in
            [Yy]*)
              break
              ;;
            *)
              printf "Exiting...\\n"
              exit 0
              ;;
          esac
        done
      fi
    fi

    _source_file_type="${_basename##*.}"
    _target_file_type="${_target_path##*.}"

    if _command_exists 'pandoc' &&
       [[ "${_source_file_type}" != "${_target_file_type}" ]]
    then
      _debug printf "_export() \${_args}: %s\\n" "${_args[*]:-}"
      if [[ -n "${_args[*]:-}" ]]
      then
        pandoc \
          -o "${_target_path}" \
          --standalone \
          "${NOTES_DATA_DIR}/${_basename}" \
          "${_args[@]:-}"
      else
        pandoc \
          -o "${_target_path}" \
          --standalone \
          "${NOTES_DATA_DIR}/${_basename}"
      fi
    else
      cp "${NOTES_DATA_DIR}/${_basename}" "${_target_path}"
    fi &&
      printf "Exported '%s' to '%s'\n" "${_selection}" "${_target_path}"
  fi
}

# git #########################################################################

desc "git" <<HEREDOC
Usage:
  ${_ME} git <git options>...

Description:
  Alias for \`git\` within the current notebook.
HEREDOC
_git() {
  cd "${NOTES_DATA_DIR}" || _die printf "_git() \`cd\` failed.\\n"
  git "${@}"
}

# history #####################################################################

desc "history" <<HEREDOC
Usage:
  ${_ME} history [<selection>]

Description:
  Display git history using \`tig\` [1] (if available) or \`git log\`. When a
  <selection> is specified, the history for that note is displayed.

  1. https://github.com/jonas/tig
HEREDOC
_history() {
  cd "${NOTES_DATA_DIR}" || _die printf "_history() \`cd\` failed.\\n"

  local _log_command="git log"
  if _command_exists "tig"
  then # tig <https://github.com/jonas/tig> is present.
    _log_command="tig --all"
  fi

  local _selection="${1:-}"
  _debug printf "_history() \${_selection}: '%s'\\n" "${_selection}"

  local _basename=
  _basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"
  _debug printf "_history() \${_basename}: '%s'\\n" "${_basename}"

  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    eval "${_log_command} -- ${_basename}"
  else
    eval "${_log_command}"
  fi
}

# import ######################################################################

desc "import" <<HEREDOC
Usage:
  ${_ME} import (<path> | <url>)
  ${_ME} import copy <path>
  ${_ME} import download <url> [--convert]
  ${_ME} import move <path>

Options:
  --convert    Convert HTML content to Markdown.

Subcommands:
  (default) Copy or download the file in <path> or <url>.
  copy      Copy the file at <path> into the current notebook.
  download  Download the file at <url> into the current notebook.
  move      Copy the file at <path> into the current notebook.

Description:
  Copy, move, or download a file into the current notebook.
HEREDOC
_import() {
  # _import_validate_path()
  #
  # Usage:
  #   _import_validate_path <path>
  _import_validate_path() {
    if [[ -z "${1:-}" ]]
    then
      _help import
      return 1
    elif [[ ! -e "${1:-}" ]]
    then
      printf "File not found: %s\n" "${1:-}"
      return 1
    fi
  }

  # _import_get_valid_basename()
  #
  # Usage:
  #   _import_get_valid_basename <basename>
  _import_get_valid_basename() {
    local _target_basename="${1:-}"
    if [[ -e "${NOTES_DATA_DIR}/${_target_basename}" ]]
    then
      _target_basename="$(_get_unique_basename "${_target_basename}")"
    fi
    printf "%s\n" "${_target_basename}"
  }

  local _basename=
  local _convert=0
  local _path=
  local _subcommand=
  local _url=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      copy|download|move)
        _subcommand="${__arg}"
        ;;
      --convert)
        _convert=1
        ;;
      *)
        if [[ -n "${_subcommand:-}" ]]
        then
          if [[ "${_subcommand}" == "download" ]]
          then
            _url="${__arg:-}"
          else
            _path="${__arg:-}"
          fi
        else
          if [[ "${__arg:-}" =~ ^http ]]
          then
            _subcommand="download"
            _url="${__arg:-}"
          else
            _subcommand="copy"
            _path="${__arg:-}"
          fi
        fi
        ;;
    esac
  done

  case "${_subcommand}" in
    copy)
      _import_validate_path "${_path:-}"

      _basename="$(basename -- "${_path}")"
      _basename="$(_import_get_valid_basename "${_basename}")"

      cp "${_path}" "${NOTES_DATA_DIR}/${_basename}" &&
        _index add "${_basename}" &&
        _git_checkpoint "[NOTES] Import: ${_basename}"
      printf "Imported '%s' to '%s'\n" "${_path}" "${_basename}"
      ;;
    download)
      _basename="$(basename -- "${_url}" | tr -d '[:space:]')"
      if [[ "${_url}" =~ \/$ ]]
      then
        _basename="${_basename}.html"
      fi
      _basename="$(_import_get_valid_basename "${_basename}")"

      if ((_convert))
      then
        curl "${_url}" | pandoc \
          --from html --to markdown \
          -o "${NOTES_DATA_DIR}/${_basename}"
      else
        curl "${_url}" -o "${NOTES_DATA_DIR}/${_basename}"
      fi &&
        _index add "${_basename}" &&
        _git_checkpoint "\
[NOTES] Import: ${_basename}

Source:
${_url}
"
      printf "Imported '%s' to '%s'\n" "${_url}" "${_basename}"
      ;;
    move)
      _import_validate_path "${_path:-}"
      _basename="$(basename -- "${_path}")"
      _basename="$(_import_get_valid_basename "${_basename}")"

      mv "${_path}" "${NOTES_DATA_DIR}/${_basename}" &&
        _index add "${_basename}" &&
        _git_checkpoint "[NOTES] Import: ${_basename}"
      printf "Imported '%s' to '%s'\n" "${_path}" "${_basename}"
      ;;
    *)
      _help import
      return 1
      ;;
  esac
}

# index #######################################################################

desc "index" <<HEREDOC
Usage:
  ${_ME} index add <filename>
  ${_ME} index delete <filename>
  ${_ME} index get_basename <id>
  ${_ME} index get_id <filename>
  ${_ME} index get_max_id
  ${_ME} index rebuild
  ${_ME} index reconcile
  ${_ME} index show
  ${_ME} index update <existing-filename> <new-filename>
  ${_ME} index verfiy

Subcommands:
  add           Add <filename> to the index.
  delete        Delete <filename> from the index.
  get_basename  Print the filename / basename at the specified <id>.
  get_id        Get the id for <filename>.
  get_max_id    Get the maximum id for the notebook.
  rebuild       Rebuild the index. Some ids might change.
  reconcile     Update index for added and deleted files.
  show          Print the index.
  update        Overwrite the <existing-filename> entry with <new-filename>.
  verify        Verify that the index matches the notebook contents.

Description:
  Manage the index for the current notebook.
HEREDOC
_index() {
  local _subcommand="${1:-}"
  local _index_path="${NOTES_DATA_DIR}/.index"

  if [[ ! -e "${_index_path}" ]] &&
     [[ ! "${_subcommand}" == "rebuild" ]]
  then
    _index rebuild
  fi

  case "${_subcommand}" in
    add)
      local _basename="${2:-}"
      if [[ -z "${_basename}" ]]
      then
        _help index
        return 1
      fi
      if [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]]
      then
        printf "File not found: %s\n" "${_basename}"
        return 1
      fi

      if ! grep -q "^${_basename}$" "${_index_path}"
      then
        _debug printf "_index() add \$_basename: %s\n" "${_basename}"
        printf "%s\n" "${_basename}" >> "${_index_path}"
      fi
      ;;
    delete)
      local _basename="${2:-}"
      _debug printf "_index() delete \${_basename}: '%s'\n" "${_basename}"

      if [[ -z "${_basename}" ]]
      then
        _help index
        return 1
      fi

      if grep -q "^${_basename}$" "${_index_path}"
      then
        "${_SED_I_COMMAND[@]}" -e "s/^${_basename}$//g" "${_index_path}"
      else
        return 1
      fi
      ;;
    get_basename)
      # Usage: _index_get_basename <id> <index path>
      _index_get_basename() {
        sed "${_id_number}q;d" "${_index_path}"
      }

      local _id_number="${2:-}"
      if [[ -z "${_id_number}" ]]
      then
        _help index
        return 1
      fi

      local _basename
      _basename="$(_index_get_basename "${_id_number}" "${_index_path}")"

      if [[ -z "${_basename}" ]]
      then
        _index reconcile &&
          _basename="$(_index_get_basename "${_id_number}" "${_index_path}")"
      fi

      if [[ -z "${_basename}" ]]
      then
        return 1
      else
        printf "%s\n" "${_basename}"
      fi
      ;;
    get_id)
      # Usage: _index_get_id <basename> <index path>
      _index_get_id() {
        grep -n "^${1:-}$" "${2:-}" | cut -f1 -d:
      }

      local _basename="${2:-}"
      if [[ -z "${_basename}" ]]
      then
        _help index
        return 1
      fi

      local _id
      _id="$(_index_get_id "${_basename}" "${_index_path}")"

      if [[ -z "${_id}" ]]
      then
        _index reconcile &&
          _id="$(_index_get_id "${_basename}" "${_index_path}")"
      fi

      if [[ -z "${_id}" ]]
      then
        return 1
      else
        printf "%s\n" "${_id}"
      fi
      ;;
    get_max_id)
      wc -l < "${_index_path}" | tr -d '[:space:]'
      ;;
    rebuild)
      _debug printf "_index() rebuild\n"
      _debug printf \
        "_index() rebuild: \`ls \${NOTES_DATA_DIR}\`: '%s'\n" \
        "$(ls "${NOTES_DATA_DIR}")"
      ls "${NOTES_DATA_DIR}" > "${_index_path}" &&
        _git_checkpoint "[NOTES] Rebuild Index"
      ;;
    reconcile)
      _index_reconcile_remove_duplicates() {
        local _reconcle_index_path="${1:-}"
        [[ -z "${_reconcle_index_path:-}" ]] && return 1

        local _tmp_file
        _tmp_file=$(mktemp /tmp/notes-index.XXXXXX)
        exec 3> "${_tmp_file}"
        exec 4< "${_tmp_file}"
        rm "${_tmp_file}"

        # Remove duplicates
        awk '!seen[$0]++' "${_reconcle_index_path}" >&3
        cat <&4 > "${_reconcle_index_path}"

        exec 3>&-
        exec 4<&-
      }

      local _index_list
      _index_list=($(<"${_index_path}"))

      local _file_list
      _file_list=($(ls "${NOTES_DATA_DIR}"))

      _index_reconcile_remove_duplicates "${_index_path}"

      _debug printf \
        "_index() reconcile: \`\${_index_list[*]}\`: '%s'\n" \
        "${_index_list[*]:-}"
      _debug printf \
        "_index() reconcile: \`\${_file_list[*]}\`: '%s'\n" \
        "${_file_list[*]:-}"

      for __item in "${_index_list[@]:-}"
      do
        if [[ -n "${__item}" ]]
        then
          _contains "${__item}" "${_file_list[*]:-}" ||
            _index delete "${__item}"
        fi
      done

      for __item in "${_file_list[@]:-}"
      do
        if [[ -n "${__item}" ]]
        then
          _contains "${__item}" "${_index_list[*]:-}" ||
            _index add "${__item}"
        fi
      done
      ;;
    show)
      cat "${_index_path}"
      ;;
    update)
      local _old_basename="${2:-}"
      local _new_basename="${3:-}"
      if [[ -z "${_old_basename}" ]] || [[ -z "${_new_basename}" ]]
      then
        _help index
        return 1
      fi

      if grep -q "^${_old_basename}$" "${_index_path}"
      then
        "${_SED_I_COMMAND[@]}" \
          -e "s/^${_old_basename}$/${_new_basename}/g" "${_index_path}"
      else
        return 1
      fi
      ;;
    verify)
      local _index_list
      _index_list=($(<"${_index_path}"))
      local _file_list
      _file_list=($(ls "${NOTES_DATA_DIR}"))
      local _errors=0

      for __item in "${_index_list[@]:-}"
      do
        _contains "${__item}" "${_file_list[*]:-}" || _errors=1
      done
      for __item in "${_file_list[@]:-}"
      do
        _contains "${__item}" "${_index_list[*]:-}" || _errors=1
      done

      if ((_errors))
      then
        printf "Index corrupted. To fix, run:\n  %s index reconcile\n" \
          "${_ME}"
        return 1
      fi
      ;;
    *)
      :
      ;;
  esac
}

# init ########################################################################

desc "init" <<HEREDOC
Usage:
  ${_ME} init [<remote-url>]

Description:
  Initialize the local data directory and generate a ~/.notesrc configruation
  file if it doesn't exist.
HEREDOC
_init() {
  if [[ -e "${NOTES_DIR}" ]] && [[ ! -d "${NOTES_DIR}" ]]
  then
    printf "\`init\`: %s already exists and is not a directory.\\n" \
      "${NOTES_DIR}"
    return 1
  elif [[ -e "${NOTES_DATA_DIR}" ]]
  then
    printf "\`init\`: %s already exists.\\n" \
      "${NOTES_DATA_DIR}"
    return 1
  fi

  cat <<HEREDOC
Welcome to
             _
 _ __   ___ | |_ ___  ___
| '_ \ / _ \| __/ _ \/ __|
| | | | (_) | ||  __/\__ \\
|_| |_|\___/ \__\___||___/

Initializing...
HEREDOC
  if [[ ! -e "${NOTES_DIR}" ]]
  then
    mkdir -p "${NOTES_DIR}"
    printf "Created %s\\n" "${NOTES_DIR}"
  fi

  if [[ ! -e "${NOTESRC_PATH}" ]]
  then
    cat <<HEREDOC > "${NOTESRC_PATH}"
###############################################################################
# .notesrc
#
# Configuration file for notes, a git-backed, syncable, searchable command line
# note-taking tool.
#
# https://github.com/xwmx/notes
###############################################################################

# \$NOTES_AUTO_SYNC
#
# Default: 1
#
# By default, operations that trigger a git commit like \`add\`, \`edit\`,
# and \`delete\` will also sync notebook changes to the remote repository, if
# one is set.
#
# To disable this behavior, uncomment the following line.
# export NOTES_AUTO_SYNC=0

# \$NOTES_DIR
#
# Default: "\$HOME/.notes"
#
# The location of the directory that contains the notebooks.
# export NOTES_DIR="\$HOME/.notes"

# \$NOTES_DEFAULT_EXTENSION
#
# Default: 'md'
#
# The default extension to use for notes files. Change to 'org' for Emacs Org
# mode files, 'rst' for reStructuredText, 'txt' for plain text, or whatever
# you prefer.

# Example Values: 'md' 'org' 'txt' 'rst'
# export NOTES_DEFAULT_EXTENSION="org"

# \$EDITOR
#
# Default: inherits the global \`\$EDITOR\` value.
#
# Reassign \`\$EDITOR\` to use a specific editor with notes, overriding the
# global \`\$EDITOR\` setting.
#
# Example Values: 'vim' 'emacs' 'subl' 'atom' 'code' 'macdown'
# export EDITOR="code"
HEREDOC
    printf "Created %s\\n" "${NOTESRC_PATH}"
  fi

  local _repo_url="${1:-}"
  if [[ -n "${_repo_url}" ]]
  then
    git clone "${_repo_url}" "${NOTES_DATA_DIR}"
  else
    mkdir -p "${NOTES_DATA_DIR}"
    cd "${NOTES_DATA_DIR}" &&
      git init 1>/dev/null &&
      touch "${NOTES_DATA_DIR}/.index" &&
      _git_checkpoint "[NOTES] Initialize"
  fi
  printf "home\\n" > "${NOTES_DIR}/.current"

  printf "Created 'home' notebook\\n"
}

# list ########################################################################

desc "list" <<HEREDOC
Usage:
  ${_ME} list [(-e | --excerpt) [<length>]] [--no-id] [-n <limit>] [--titles]
             [-s | --sort] [-r | --reverse] [<selection>]

Options:
  -e --excerpt <length>  Print an excerpt <length> lines long under each
                         note's filename [default: 3].
  --no-id                Don't print the id next to each note's filename.
  -n <limit>             The maximum number of notes to list.
  -s --sort              Order notes by id.
  -r --reverse           Order notes by id descending.
  --titles               Show title instead of filename when present.

Description:
  List notes in the current notebook.

Examples:
  ${_ME} list
  ${_ME} list example.md -e 10
  ${_ME} list --excerpt --no-id
  ${_ME} list --titles --reverse
HEREDOC
_list() {
  _debug printf "_list() \${1:-}: '%s'\\n" "${1:-}"
  _debug printf "_list() \${2:-}: '%s'\\n" "${2:-}"
  _debug printf "_list() \${3:-}: '%s'\\n" "${3:-}"

  local _excerpt_length=3
  local _print_excerpt=0
  local _limit
  local _list_titles=0
  local _no_color=0
  local _no_id=0
  local _reverse=0
  local _selection
  local _sort=0

  _debug printf "_list() \${@:-}: '%s'\\n" "${@:-}"

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      -e|--excerpt)
        _print_excerpt=1
        if __option_value_is_present "${_val:-}"
        then
          _excerpt_length="${_val:-}"
          shift
        fi
        ;;
      --no-id|--noid|--noindex|--no-index)
        _no_id=1
        ;;
      --nocolor|--no-color)
        _no_color=1
        ;;
      -n)
        if __option_value_is_present "${_val:-}"
        then
          _limit="${_val:-}"
          shift
        fi
        ;;
      --titles)
        _list_titles=1
        ;;
      -s|--sort)
        _sort=1
        ;;
      -r|--reverse)
        _reverse=1
        ;;
      *)
        _debug printf "_list() *: '%s'\\n" "${_arg:-}"
        _selection="${_arg:-}"
        ;;
    esac
    shift
  done

  _debug printf "_list() \${_print_excerpt}: '%s'\\n" "${_print_excerpt:-}"
  _debug printf "_list() \${_excerpt_length}: '%s'\\n" "${_excerpt_length:-}"
  _debug printf "_list() \${_selection}: '%s'\\n" "${_selection:-}"
  _debug printf "_list() \${_sort}: '%s'\\n" "${_sort:-}"

  local _selection_basename=
  if [[ -n "${_selection:-}" ]]
  then
    _selection_basename="$(_get_selection_basename "${_selection}")"
    _set_selection_notebook "${_selection}"

    if [[ -z "${_selection_basename}" ]]
    then
      printf "Note not found: %s\\n" "${_selection}"
      printf "Help & Usage Info:\n"
      printf "  notes help\\n"
      return 1
    fi
  fi

  local _filenames=()
  if ((_reverse))
  then
    _filenames=($(_list_notes_files --sort --reverse))
  elif ((_sort))
  then
    _filenames=($(_list_notes_files --sort))
  else
    _filenames=($(_list_notes_files))
  fi
  local _filenames_count="${#_filenames[@]}"

  _debug printf "list() \${_filenames_count}: '%s'\\n" "${_filenames_count[@]}"

  if [[ "${_filenames_count}" -eq 0 ]]
  then # no files in `$NOTES_DATA_DIR`
    cat <<HEREDOC
0 notes.

Add a note:
  ${_ME} add
Usage information:
  ${_ME} help
HEREDOC
    return 1
  else
    local _counter=0
    local _max_id
    _max_id="$(_index get_max_id)"

    for __basename in "${_filenames[@]}"
    do
      if [[ -n "${_limit:-}" ]] && [[ "${_counter}" -eq "${_limit}" ]]
      then # the limit has been reached.

        _debug printf "list() \${#_limit}: '%s'\\n" "${#_limit}"
        _debug printf "list() \${#_counter}: '%s'\\n" "${#_counter}"

        local _difference
        _difference=$((_filenames_count-_counter))
        printf "%s omitted. %s total.\\n" "${_difference}" "${_filenames_count}"
        break
      fi

      # NOTE: Plain version serves as the reference version and can be used
      # for length calculations.
      local _item_id_number
      _item_id_number="$(_index get_id "${__basename}")"

      local _id_item
      _id_item="[${_item_id_number}]"

      local _id_item_color
      _id_item_color="[$(_highlight "${_item_id_number}")]"

      # If a valid <selection> has been specified, skip the rest of the loop
      # unless the <selection> basename matches the current one.
      if [[ -n "${_selection_basename}" ]] &&
         [[ "${__basename}" != "${_selection_basename}" ]]
      then
        continue
      fi

      local _list_item_id="${__basename}"
      local _maybe_title
      if ((_list_titles))
      then
        _maybe_title="$(_get_title "${__basename}")"
        if [[ -n "${_maybe_title}" ]]
        then # note file has title.
          _list_item_id="${_maybe_title}"
        fi
      fi

      # Use calculated number of spaces for nicer formatting.
      local _spaces=''
      local _spaces_length=1
      _spaces_length=$(( ${#_max_id} + 3 - ${#_id_item} ))
      printf -v _spaces '%*s' "${_spaces_length}"

      local _list_item="${_id_item}${_spaces}${_list_item_id}"
      local _list_item_color="${_id_item_color}${_spaces}${_list_item_id}"

      if ((_no_id))
      then
        printf "%s" "${_list_item_id}"
      else
        if ((_no_color))
        then
          printf "%s" "${_list_item}"
        else
          printf "%s" "${_list_item_color}"
        fi
      fi

      # TODO: This is slow. Look for ways to speed up.
      if _file_is_encrypted "${NOTES_DATA_DIR}/${__basename}"
      then
        printf " ðŸ”’"
      fi

      # End of line.
      printf "\\n"

      if ((_print_excerpt)) && [[ "${_excerpt_length}" =~ ^[1-9] ]]
      then # excerpt is specified with a non-zero digit, as required by `head`.
        _print_line "${_list_item}"
        head -"${_excerpt_length}" "${NOTES_DATA_DIR}/${__basename}"
        printf "\\n"
      fi

      _counter=$((_counter+1))
    done
  fi
}

# ls ##########################################################################

desc "ls" <<HEREDOC
Usage:
  ${_ME} ls [<list options>...]

Description:
  List notebooks and notes in the current notebook. Options are passed through
  to \`list\`. For more information, see \`notes help list\`.
HEREDOC
_ls() {
  _debug printf "_ls() \${@:-}: '%s'\\n" "${@:-}"

  local _args=()
  local _auto_align=1 # auto-align by default.
  local _centered=0
  local _justified=0
  local _plain=0

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --auto-align)
        _auto_align=1
        ;;
      --centered)
        _centered=1
        ;;
      --justified)
        _justified=1
        ;;
      --plain)
        _plain=1
        ;;
      *)
        _args+=("${__arg}")
        ;;
    esac
  done

  _debug printf "_ls() \${_args[*]}: '%s'\\n" "${_args[*]:-}"

  {
    if [[ -z "${_args[*]:-}" ]]
    then
      # Build word-wrapping notebook line. `fold` doesn't account for
      # highlighting.
      #
      # Naive version:
      #
      # _notebooks --names \
      #   | tr '\n' ' ' \
      #   | fold -s "-w$(tput cols)" \
      #   && printf "\n"

      # _print_paddding()
      #
      # Usage:
      #   _print_padding <line> <columns> <aligned>
      _print_padding() {
        local _padding_line="${1:-}"
        local _padding_line_length="${#_padding_line}"
        local _padding_columns="${2:-}"
        local _padding_centered="${3:-}"

        local _padding_amount=$(( (_padding_columns-_padding_line_length) / 2 ))
        if ((_padding_centered)) && ((_padding_amount))
        then
          printf "%-${_padding_amount}s" " "
        fi
      }

      local _separator=
      if ! ((_plain))
      then
        _separator=" Â·"
      fi

      local _columns
      _columns="$(tput cols)"

      local _notebook_names_raw
      _notebook_names_raw=($(_notebooks --names --no-color))
      local _notebooks_count="${#_notebook_names_raw[@]}"

      local _notebook_names_hi
      _notebook_names_hi=($(_notebooks --names))

      local _line_number=0
      local _padding=

      local _test_line=
      local _line_raw=
      local _line_hi=
      local _output_raw=
      local _output_hi=

      for ((i=0;i < "${_notebooks_count}"; i++))
      do
        if [[ -z "${_test_line}" ]]
        then # first item in line
          _test_line="${_notebook_names_raw[i]}"
        else
          _test_line="${_test_line}${_separator} ${_notebook_names_raw[i]}"
        fi

        if [[ "${#_test_line}" -gt "${_columns}" ]]
        then # wrap to next line
          # Use the existing value of $_line_[highlighted|raw] without the current
          # name.
          if ((_auto_align)) || ((_centered)) && ! ((_justified))
          then
            _centered=1
            _padding="$(
              _print_padding "${_line_raw}" "${_columns}" "${_centered}"
            )"
          fi

          _output_hi="${_output_hi}${_padding}${_line_hi}\n"
          _output_raw="${_output_raw}${_padding}${_line_raw}\n"
          _line_number=$((_line_number + 1))

          # Start the line for the next iteration using the current name..
          _test_line="${_notebook_names_raw[i]}"
          _line_hi="${_notebook_names_hi[i]:-}"
          _line_raw="${_notebook_names_raw[i]}"
        else # add to line
          if [[ -z "${_line_hi}" ]]
          then # first item in highlighted line
            _line_hi="${_notebook_names_hi[i]:-}"
            _line_raw="${_notebook_names_raw[i]}"
          else
            _line_hi="${_line_hi}${_separator} ${_notebook_names_hi[i]:-}"
            _line_raw="${_line_raw}${_separator} ${_notebook_names_raw[i]}"
          fi
        fi

        if [[ "${#_notebook_names_raw[@]}" == $((i+1)) ]]
        then # end of list
          if ((_line_number)) && ! ((_justified)) &&
             ((_auto_align)) || ((_centered))
          then
            _centered=1
          fi
          _padding="$(
            _print_padding "${_line_raw}" "${_columns}" "${_centered}"
          )"

          _output_hi="${_output_hi}${_padding}${_line_hi}\n"
          _output_raw="${_output_raw}${_padding}${_line_raw}\n"
          _line_number=$((_line_number + 1))
        fi
      done
      printf "%b" "${_output_hi}"

      # Use control characters to disable wrapping for long lines.
      # Source: http://superuser.com/a/189068
      printf '\033[?7l'
      if ((_centered))
      then # print full-width line.
        _print_line "$(printf "%-${_columns}s" '.')" | tr -d '\n'
      else # print line the length of the first line.
        _print_line "$(
          # $_output_raw generates a line 2 characters too long. TODO: Review
          printf "%s" "${_output_raw}" | sed 's/..$//'
        )" | tr -d '\n'
      fi
      printf '\033[?7h'
      printf '\n'
    fi

    _list --titles "${_args[@]:-}"
  } | if hash "less" 2>/dev/null
      then
        less -X -F
      else
        cat
      fi
}

# move ########################################################################

desc "move" <<HEREDOC
Usage:
  ${_ME} move (<id> | <filename> | <path> | <title>) [--force] <notebook>

Description:
  Move the specified note to <notebook>.

Alias: \`mv\`
HEREDOC
_move() {
  local _basename=
  local _force=0
  local _selection=
  local _source_info_line=
  local _target_notebook=
  local _title=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        elif [[ -z "${_target_notebook}" ]]
        then
          _target_notebook="${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_move() \${_selection}: '%s'\\n" "${_selection}"
  _debug printf "_move() \${_target_notebook}: '%s'\\n" "${_target_notebook}"
  if [[ -z "${_selection:-}" ]] || [[ -z "${_target_notebook:-}" ]]
  then
    _help "move"
    return 1
  fi

  if [[ "${_target_notebook}" =~ :$ ]]
  then
    _target_notebook="$(printf "%s\\n" "${_target_notebook}" | tr -d ':')"
  fi
  _debug printf "_move() \${_target_notebook}: '%s'\\n" "${_target_notebook}"

  _basename="$(_get_selection_basename "${_selection}")"

  _set_selection_notebook "${_selection}"

  if [[ -z "${_basename}" ]] ||
     [[ ! -e "${NOTES_DIR}/${_target_notebook}/.git" ]]
  then
    _help "move"
    return 1
  elif [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then
    printf "Not Found: %s:%s\\n" "${_SCOPE}" "${_basename}"
    return 1
  elif [[ -e "${NOTES_DIR}/${_target_notebook}/${_basename}" ]]
  then
    printf "Already exists: %s:%s\\n" "${_SCOPE}" "${_basename}"
    return 1
  fi

  _debug printf "_move() \${_basename}: '%s'\\n" "${_basename}"

  _title="$(_get_title "${_basename}")"
  if [[ -n "${_title}" ]]
  then
    _source_info_line="${_SCOPE}:${_basename} '${_title}'"
  else
    _source_info_line="${_SCOPE}:${_basename}"
  fi

  if ! ((_force))
  then
    printf "Moving %s to '%s'\\n"  \
      "${_source_info_line}"    \
      "${_target_notebook}"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  cat "${NOTES_DATA_DIR}/${_basename}" \
    | "${_MY_PATH}" "${_target_notebook}:add" 1> /dev/null

  "${_MY_PATH}" delete "${_SCOPE}:${_basename}" --force 1> /dev/null

  if [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then
    printf "Moved to '%s':'%s'\\n"  \
      "${_target_notebook}"        \
      "${_basename}"
  fi
}
desc "mv" "$(_help 'move')"
_mv()    { _move "${@}"; }

# notebook ####################################################################

desc "notebook" <<HEREDOC
Usage:
  ${_ME} notebook

Description:
  Print the current notebook name.
HEREDOC
_notebook() {
  if [[ "${1:-}" == "open" ]]
  then
    open "${NOTES_DATA_DIR}"
  else
    _notebooks current
  fi
}
desc "nb" "$(_help 'notebook')"
_nb()    { _notebook "${@}"; }

# notebooks ###################################################################

desc "notebooks" <<HEREDOC
Usage:
  ${_ME} notebooks [<name>] [--names] [--no-color]
  ${_ME} notebooks add <name> [<remote-url>]
  ${_ME} notebooks current
  ${_ME} notebooks rename <old-name> <new-name>
  ${_ME} notebooks use <name>

Subcommands:
  (default)  List notebooks.
  add        Create a new notebook.
  current    Print the current notebook name.
  rename     Rename a notebook.
  use        Switch to a notebook.
HEREDOC
_notebooks() {
  # _notebooks_add()
  #
  # Usage:
  #   _notebooks_add <name> [<remote_url>]
  _notebooks_add() {
    local _name="${1:-}"
    if [[ -z "${_name}" ]]
    then
      _help notebooks
      return 1
    fi

    if [[ -e "${NOTES_DIR}/${_name}" ]]
    then
      printf "Already exists: %s\\n" "${_name}"
      return 1
    fi

    local _repo_url="${2:-}"
    if [[ -n "${_repo_url}" ]]
    then
      git clone "${_repo_url}" "${NOTES_DIR}/${_name}"
      printf "%s\\n" "${_name}" > "${NOTES_DIR}/.current"
    else
      mkdir -p "${NOTES_DIR}/${_name}"
      cd "${NOTES_DIR}/${_name}" &&
        git init 1>/dev/null &&
        touch "${NOTES_DIR}/${_name}/.index" &&
        _git_checkpoint "[NOTES] Initialize" "${NOTES_DIR}/${_name}"
    fi
    printf "Added: %s\\n" "${_name}"
  }
  # _notebooks_list()
  #
  # Usage:
  #   _notebooks_list [<name>] [--names]
  _notebooks_list() {
    local _files=()
    local _no_color=0
    local _only_names=0

    _debug printf "_notebooks_list() \${@:-}: '%s'\\n" "${@:-}"

    for __arg in "${@:-}"
    do
      case "${__arg}" in
        --names)
          _only_names=1
          ;;
        --nocolor|--no-color)
          _no_color=1
          ;;
        *)
          _files+=("${__arg}")
          ;;
      esac
    done

    if [[ -z "${_files[*]:-}" ]]
    then
      _files=($(ls -1 "${NOTES_DIR}"))
    fi

    _debug printf \
      "_notebooks_list() \${_only_names:-}: '%s'\\n" \
      "${_only_names:-}"
    _debug printf \
      "_notebooks_list() \${_files[*]}: '%s'\\n" \
      "${_files[*]:-}"

    for __item in "${_files[@]}"
    do
      if [[ -e "${NOTES_DIR}/${__item}/.git" ]]
      then # it's a git repository.
        local _current
        _current="$(_notebooks current)"
        local _formatted_name
        local _origin_url

        if [[ -n "${_current}" ]] &&
           [[ "${_current}" == "${__item}" ]] &&
           ! ((_no_color))
        then # it's the current repository.
          _formatted_name="$(_highlight "${__item}")"
        else
          _formatted_name="${__item}"
        fi

        local _origin_url
        if ! ((_only_names))
        then
          cd "${NOTES_DIR}/${__item}" ||
            _die printf "_notebooks() \`cd\` failed."
          _origin_url="$(git config --get remote.origin.url || echo '')"
        fi

        if [[ -n "${_origin_url:-}" ]]
        then
          printf "%s\\n" "${_formatted_name}	(${_origin_url})"
        else
          printf "%s\\n" "${_formatted_name}"
        fi
      fi
    done
  }
  # _notebooks_rename()
  #
  # Usage:
  #   _notebooks_rename <old> <new>
  _notebooks_rename() {
    local _old="${1:-}"
    local _new="${2:-}"

    if [[ -z "${_old}" ]] || [[ -z "${_new}" ]]
    then
      _help notebooks
      return 1
    elif [[ ! -d "${NOTES_DIR}/${_old}" ]]
    then
      printf "'%s' is not a valid notebook name.\\n" "${_old}"
      return 1
    elif [[ -e "${NOTES_DIR}/${_new}" ]]
    then
      printf "A notebook named '%s' already exists.\\n" "${_new}"
      return 1
    fi

    mv "${NOTES_DIR}/${_old}" "${NOTES_DIR}/${_new}"

    if [[ "$(cat "${NOTES_DIR}/.current")" == "${_old}" ]]
    then
      printf "%s\\n" "${_new}" > "${NOTES_DIR}/.current"
    fi

    printf "'%s' is now named '%s'\\n" "${_old}" "${_new}"
  }

  local _subcommand="${1:-}"
  local _name="${2:-}"

  case "${_subcommand}" in
    add)
      _notebooks_add "${_name:-}" "${3:-}"
      ;;
    current)
      basename "${NOTES_DATA_DIR}"
      ;;
    rename)
      _notebooks_rename "${_name:-}" "${3:-}"
      ;;
    use)
      if [[ -z "${_name}" ]]
      then
        _help notebooks
        return 1
      fi

      # Autocomplete can result in a trailing colon on the notebook name, so
      # remove it if present.
      if [[ "${_name}" =~ :$ ]]
      then
        _name=$(printf "%s\\n" "${_name}" | cut -f 1 -d ":")
      fi

      if [[ -d "${NOTES_DIR}/${_name}/.git" ]]
      then
        printf "%s\\n" "${_name}" > "${NOTES_DIR}/.current"
        printf "Now using %s.\\n" "$( _highlight "${_name}")"
      else
        printf "Not found: %s\\n" "${_name}"
        return 1
      fi
      ;;
    *)
      _notebooks_list "${@}"
      ;;
  esac
}
desc "nbs" "$(_help 'notebooks')"
_nbs()   { _notebooks "${@}"; }

# open ########################################################################

desc "open" <<HEREDOC
Usage:
  ${_ME} open

Description:
  Open the notebook directory in your file browser, explorer, or finder.
HEREDOC
_open() {
  if _command_exists "xdg-open"
  then
    xdg-open "${NOTES_DATA_DIR}"
  elif _command_exists "open"
  then
    open "${NOTES_DATA_DIR}"
  else
    printf "notes doesn't know how to open directories on your system.\n"
    return 1
  fi
}

# remote ######################################################################

desc "remote" <<HEREDOC
Usage:
  ${_ME} remote
  ${_ME} remote remove
  ${_ME} remote set <url> [--force]

Subcommands:
  (default)  Print the remote URL for the notebook.
  remove     Remove the remote URL from the notebook.
  set        Set the remote URL for the notebook.

Description:
  Get, set, and remove the remote repository URL for the current notebook.
HEREDOC
_remote() {
  local _existing_url=
  local _force=0
  local _remote_exists=0
  local _subcommand=
  local _url=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --force)
        _force=1
        ;;
      *)
        if [[ -z "${_subcommand}" ]]
        then
          _subcommand="${__arg}"
        elif [[ "${_subcommand}" == "set" ]] &&
             [[ -z "${_url}" ]]
        then
          _url="${__arg}"
        fi
        ;;
    esac
  done
  _debug printf "_remote() \${_subcommand}: '%s'\\n" "${_subcommand}"
  _debug printf "_remote() \${_url}: '%s'\\n" "${_url}"

  cd "${NOTES_DATA_DIR}" || _die printf "_git() \`cd\` failed.\\n"

  if [[ "$(git remote get-url origin 2>/dev/null)" ]]
  then
    _remote_exists=1
    _existing_url="$(git remote get-url origin)"
  fi

  _debug printf "_remote() \${_remote_exists}: '%s'\\n" "${_remote_exists}"
  _debug printf "_remote() \${_existing_url}: '%s'\\n" "${_existing_url}"

  case "${_subcommand}" in
    remove)
      if ((_remote_exists))
      then
        if ! ((_force))
        then
          while true
          do
            printf "Removing remote '%s'\n" \
              "${_existing_url}"
            read -r -p "Do you want to proceed? [y/N] " __yn
            case ${__yn} in
              [Yy]*)
                break
                ;;
              *)
                printf "Exiting...\\n"
                exit 0
                ;;
            esac
          done
        fi

        git remote rm origin &&
          printf "Removed remote '%s'\n" "${_existing_url}" &&
          return 0
      else
        printf "No remote configured.\n"
        return 1
      fi
      ;;
    set)
      if [[ -z "${_url}" ]]
      then
        _help remote
        return 1
      fi

      if ((_remote_exists))
      then
        if [[ "${_existing_url}" == "${_url}" ]]
        then
          printf "Remote already set to '%s'\n" "${_url}"
          return 1
        fi

        if ! ((_force))
        then
          while true
          do
            printf "Updating remote from '%s' to '%s'\n" \
              "${_existing_url}" "${_url}"
            read -r -p "Do you want to proceed? [y/N] " __yn
            case ${__yn} in
              [Yy]*)
                break
                ;;
              *)
                printf "Exiting...\\n"
                exit 0
                ;;
            esac
          done
        fi

        git remote set-url origin "${_url}" &&
          printf "Remote set to '%s'\n" "${_url}" &&
          return 0
      else
        git remote add origin "${_url}"  &&
          printf "Remote set to '%s'\n" "${_url}" &&
          return 0
      fi
      ;;
    *)
      if ((_remote_exists))
      then
        git remote get-url origin &&
        return 0
      else
        printf "No remote configured.\n"
        return 0
      fi
      ;;
  esac
}

# rename ######################################################################

desc "rename" <<HEREDOC
Usage:
  ${_ME} rename (<id> | <filename> | <path> | <title>) (<name> | --reset)

Options:
  --reset  Reset the filename to the timestamp at which it was last updated.

Description:
  Rename a note. Set the filename to <name> for the specified note file.
HEREDOC
_rename() {
  local _reset=0
  local _selection=
  local _target_name=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --reset)
        _reset=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        elif [[ -z "${_target_name}" ]]
        then
          _target_name="${__arg}"
        fi
        ;;
    esac
  done

  local _source_basename
  _source_basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"
  local _source_path="${NOTES_DATA_DIR}/${_source_basename}"

  if [[ -z "${_source_basename}" ]]
  then
    _help "rename"
    return 1
  fi
  _debug printf "_rename() \${_source_basename}: '%s'\\n" \
    "${_source_basename}"

  if ((_reset))
  then
    local _file_type="${NOTES_DEFAULT_EXTENSION}"
    local _timestamp

    if stat -c &>/dev/null
    then # GNU
      _timestamp="$(stat -c %Y "${_source_path}")"
    elif gstat -c &>/dev/null
    then # GNU prefixed
      _timestamp="$(gstat -c %Y "${_source_path}")"
    else
      _timestamp="$(stat -f '%m' "${_source_path}")"
    fi

    # Assign filename with unicode timestamp.
    local _target_basename
    _target_basename="$(date -r "${_timestamp}" -u "+%Y%m%d%H%M%S").${_file_type}"
    local _destination_path="${NOTES_DATA_DIR}/${_target_basename}"

    mv "${_source_path}" "${_destination_path}" &&
      _index update "${_source_basename}" "${_target_basename}" &&
      _git_checkpoint \
        "[NOTES] Rename: ${_source_basename} to ${_target_basename}"
    printf "%s renamed to %s\n" \
      "${_source_basename}"   \
       "${_target_basename}."
  elif [[ -n "${_target_name}" ]]
  then
    if [[ -e "${NOTES_DATA_DIR}/${_target_name}" ]]
    then
      printf "File already exists: '%s'\n" "${_target_name}"
      return 1
    fi

    mv "${_source_path}" "${NOTES_DATA_DIR}/${_target_name}" &&
      _index update "${_source_basename}" "${_target_name}" &&
      _git_checkpoint \
        "[NOTES] Rename: ${_source_basename} to ${_target_name}"
    printf "%s renamed to %s\n" \
      "${_source_basename}"   \
      "${_target_name}"
  else
    _help "rename"
    return 1
  fi
}

# search ######################################################################

desc "search" <<HEREDOC
Usage:
  ${_ME} search <query> [-a | --all] [--path]

Options:
  -a --all  Search all notebooks.
  --path    Print the full path for each file with query matches.

Description:
  Search notes. Uses the first available tool in the following list:
    1. \`rg\`    <https://github.com/BurntSushi/ripgrep>
    2. \`ag\`    <https://github.com/ggreer/the_silver_searcher>
    3. \`ack\`   <http://beyondgrep.com/>
    4. \`grep\`  <https://en.wikipedia.org/wiki/Grep>

Alias: \`q\`
HEREDOC
_search() {
  local _all=0
  local _arguments=("${@}")
  local _last_path=
  local _query=
  local _print_paths=0
  local _use_grep=0

  for __arg in "${_arguments[@]:-}"
  do
    case "${__arg}" in
      -a|--all)
        _all=1
        ;;
      --path)
        _print_paths=1
        ;;
      --use-grep)
        # The `--use-grep` option bypasses other search tools. Intended to be
        # used primarily for testing.
        _use_grep=1
        ;;
      *)
        if [[ -z "${_query}" ]]
        then
          _query="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_query:-}" ]]
  then
    _help "search"
    return 1
  else
    local _target_notebooks=()

    if ((_all))
    then
      _target_notebooks=($(_notebooks --names --no-color))
    else
      _target_notebooks=($(_notebook))
    fi

    _debug printf \
      "_search() \${_target_notebooks[*]}: '%s'\\n" \
      "${_target_notebooks[*]}"

    for __scope in "${_target_notebooks[@]:-}"
    do
      if _command_exists "rg" && ! ((_use_grep))
      then
        rg \
          --hidden \
          --iglob '!.git' \
          --ignore-case \
          --no-heading \
          --color always \
          --line-number \
          "${_query}" "${NOTES_DIR}/${__scope}" \
            || return 0 # Don't fail out within a single scope.
      elif _command_exists "ag" && ! ((_use_grep))
      then
        # TODO: `ag` outputs unordered results, which breaks tests/search.bats.
        # Determine how to test without relying on ordering.
        ag \
          --hidden \
          --ignore-case \
          --noheading \
          --color \
          --color-line-number '32' \
          --color-match '1;35' \
          "${_query}" "${NOTES_DIR}/${__scope}" \
            || return 0 # Don't fail out within a single scope.
      elif _command_exists "ack" && ! ((_use_grep))
      then # ack is available.
        ack "${_query}" "${NOTES_DIR}/${__scope}" \
          --ignore-case \
          --noheading \
          --color-lineno='bold green' \
          --color-match='black on_blue' \
            || return 0 # Don't fail out within a single scope.
      else # fall back to POSIX grep.
        # Add /dev/null so file path is printed even if there is only one
        # matching file. Reference: http://stackoverflow.com/a/15432718
        set +f
        grep \
          --ignore-case \
          --exclude '.git' \
          -n "${_query}" \
          "${NOTES_DIR}/${__scope}"/* "${NOTES_DIR}/${__scope}"/.[^.]* /dev/null \
            || return 0 # Don't fail out within a single scope.
        set -f
      fi | while read -r _line
      do
        local _path=
        local _filename=
        local _filename_color=
        local _filename_hit=0
        local _id=
        local _title=
        local _file_info=
        local _file_info_color=
        # Define `_id_filename` with and without color to have a version
        # without the additional length from `tput` calls.
        local _id_filename=
        local _id_filename_color=
        local _content_line_with_hit=

        # Use `sed` to remove color from output.
        # http://unix.stackexchange.com/a/140255
        _path="$(
          printf "%s\\n" "${_line}" \
            | cut -d: -f 1 \
            | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g"
        )"

        if [[ -z "${_line}" ]]
        then
          # Print nothing, skipping the blank line in `ag` output with
          # multiple matches.
          :
        elif ((_print_paths))
        then
          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf "%s\\n" "${_path}"
          fi
        else
          _filename="$(basename "${_path}")"
          _filename_color="${_filename}"

          # Use '.index' to match filenames.
          if [[ -n "${_filename:-}" ]] && [[ "${_filename:-}" == ".index" ]]
          then
            _filename_hit=1
            _filename_color="$(printf "%s\\n" "${_line}" | cut -d: -f 3-)"
            _filename="$(
              printf "%s\\n" "${_filename_color}" \
                | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g"
            )"
          fi

          _id="$("${_MY_PATH}" "${__scope}:index" get_id "${_filename}")"
          _title="$(_get_title "${_filename}" "${__scope}")"

          if [[ -n "${_title}" ]]
          then
            _file_info="${_filename} '${_title}'"
            _file_info_color="${_filename_color} '${_title}'"
          else
            _file_info="${_filename}"
            _file_info_color="${_filename_color}"
          fi

          if ((_all))
          then
            _id_filename="[${__scope}:${_id}] ${_file_info}"
            _id_filename_color="[$(_highlight "${__scope}:${_id}")] ${_file_info_color}"
          else
            _id_filename="[${_id}] ${_file_info}"
            _id_filename_color="[$(_highlight "${_id}")] ${_file_info_color}"
          fi

          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf '\033[?7l'
            printf "%s\\n" "${_id_filename_color}"
            _print_line "${_id_filename}"
            printf '\033[?7h'
          fi

          if ((_filename_hit))
          then
            _content_line_with_hit="Filename Match: $(printf "%s\\n" "${_line}" | cut -d: -f 3-)"
          else
            _content_line_with_hit="$(printf "%s\\n" "${_line}" | cut -d: -f 2-)"
          fi

          printf "%s\\n\\n" "${_content_line_with_hit}"
        fi

        _last_path="${_path}"
      done
    done | if read -r _line
    then # output is present
      # Print the test line then `cat` the rest.
      printf "%s\\n" "${_line}"
      cat
      return 0
    else
      return 1
    fi
  fi
}
desc "q" "$(_help 'search')"
_q() {  _search "${@}"; }

# settings ####################################################################

desc "settings" <<HEREDOC
Usage:
  ${_ME} settings

Description:
  Open the ~/.notesrc configuration file in \`\$EDITOR\`.

  For more information about .notesrc, visit:
  https://github.com/xwmx/notes#configuration
HEREDOC
_settings() {
  _edit_file "${HOME}/.notesrc"
}
desc "config" "$(_help 'settings')"
_config()    { _settings "${@}"; }

# show ########################################################################

desc "show" <<HEREDOC
Usage:
  ${_ME} show (<id> | <filename> | <path> | <title>) [--id | --path | --render]
             [--dump [--no-color]]

Options:
  --dump      Print to standard output.
  --id        Print the id number of the note file.
  --path      Print the full path of the note file.
  --no-color  When used with \`--dump\`, print the note without highlighting.
  --render    Use \`pandoc\` [1] to render the file to HTML and display with
              \`lynx\` [2] (if available) or \`w3m\` [3]. If \`pandoc\` is not
              available, \`--render\` is ignored.

            1. http://pandoc.org/
            2. https://en.wikipedia.org/wiki/Lynx_(web_browser)
            3. https://en.wikipedia.org/wiki/W3m

Description:
  Show a note. Notes in text file formats can be rendered or dumped to
  standard output. Non-text files will be opened in your system's preferred
  app or program for that file type.

  If Pygments <http://pygments.org/> is installed, notes are printed with
  syntax highlighting.

Alias: \`s\`
HEREDOC
_show() {
  _debug printf "_show() \${0:-}: '%s'\\n" "${0:-}"
  _debug printf "_show() \${1:-}: '%s'\\n" "${1:-}"
  _debug printf "_show() \${2:-}: '%s'\\n" "${2:-}"

  local _dump=0
  local _password=
  local _print_id=0
  local _print_no_color=0
  local _print_path=0
  local _render=0
  local _selection=

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --dump)
        _dump=1
        ;;
      --path)
        _print_path=1
        ;;
      --id|--index)
        _print_id=1
        ;;
      --password)
        if __option_value_is_present "${_val:-}"
        then
          _password="${_val:-}"
          shift
        else
          _help edit
          return 1
        fi
        ;;
      --raw|--no-color|--nocolor)
        _print_no_color=1
        ;;
      --render|-r)
        _render=1
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${_arg}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "_show() \${_render}: '%s'\\n" "${_render}"
  _debug printf "_show() \${_selection}: '%s'\\n" "${_selection}"

  if [[ -z "${_selection:-}" ]]
  then
    _help "show"
    return 1
  fi

  local _basename
  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_show() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    printf "Note not found.\n"
    return 1
  fi
  _set_selection_notebook "${_selection}"

  local _target_path="${NOTES_DATA_DIR}/${_basename}"

  if _file_is_encrypted "${_target_path}"
  then
    local _encrypted_path
    _encrypted_path="${_target_path}"

    if [[ -z "${_password}" ]]
    then
      # Request password without displaying it
      printf "Password: "
      read -r -s _password </dev/tty
      printf "\\n" # print newline to stop `read`.
    fi

    if [[ -z "${_password}" ]]
    then
      printf "Password required.\n"
      return 1
    fi

    local _decrypted_path
    _decrypted_path="$(_decrypt_file "${_target_path}" "${_password}")"

    _target_path="${_decrypted_path}"
  fi

  if _file_is_archive "${_target_path}"
  then
    printf "\
Can't show archives. Export archive and expand to edit.\n"
    exit 1
  fi

  if ! _file_is_text "${_target_path}"
  then
    if _command_exists "xdg-open"
    then
      xdg-open "${_target_path}" && return 0
    elif [[ "${OSTYPE}" =~ ^darwin ]]
    then
      open "${_target_path}" && return 0
    fi
  fi

  # Display file.
  if [[ -n "${_basename}" ]] && [[ -e "${_target_path}" ]]
  then # _basename is assigned and a note exists with that name.
    if ((_print_path))
    then # `notes show --path`
      printf "%s/%s\\n" "${NOTES_DATA_DIR}" "${_basename}"
    elif ((_print_id))
    then
      local _id
      _id="$(_index get_id "${_basename}")"
      printf "%s\\n" "${_id}"
    elif ((_render)) &&
         ((_dump))   &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render --dump` with `pandoc` and `w3m` available.
      pandoc "${_target_path}" \
        | w3m -dump -T text/html
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render` with `pandoc` and `w3m` available.
      pandoc "${_target_path}" \
        | w3m -T text/html
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "lynx"
    then # `notes show --render` with `pandoc` and `lynx` available.
      pandoc "${_target_path}" | lynx -stdin
    else # default
      if ((_dump))
      then # `notes show --dump [--no-color]`
        if ((_print_no_color))
        then # `notes show --dump --no-color`
          cat "${_target_path}"
        else # `notes show --dump`
          _highlight_syntax_if_available "${_target_path}"
        fi
      else # `notes show`
        if [[ -n "${PAGER:-}" ]]
        then
          _highlight_syntax_if_available "${_target_path}" \
            | "${PAGER}"
        else
          _highlight_syntax_if_available "${_target_path}"
        fi
      fi
    fi
  else # _basename is not assigned or no note exists with that name.
    printf "Selection not found.\\n"
    return 1
  fi

  if [[ -n "${_decrypted_path:-}" ]] && [[ -e "${_decrypted_path}" ]]
  then
    rm "${_decrypted_path}"
  fi
}
desc "s" "$(_help 'show')"
_s() { _show "${@}"; }

# status ######################################################################

desc "status" <<HEREDOC
Usage:
  ${_ME} status

Description:
  Run \`git status\` in the current notebook.
HEREDOC
_status() {
  cd "${NOTES_DATA_DIR}" || _die printf "_status() \`cd\` failed.\\n"
  git status
}

# sync ########################################################################

desc "sync" <<HEREDOC
Usage:
  ${_ME} sync [-a|--all]

Options:
  -a --all  Sync all notebooks.

Description:
  Sync the current local notebook with the remote repository.
HEREDOC
_sync() {
  local _notebooks

  _debug printf "_sync() \${*}: '%s'\\n" "${*}"

  if [[ -n "${1:-}" ]] && [[ "${1}" =~ ^-a|--all$ ]]
  then
    _debug printf "_sync() -a|--all\\n"
    _notebooks=($(_notebooks --names --no-color))
  else
    _notebooks=($(_notebook))
  fi

  _debug printf "_sync() \${_notebooks[*]:-}: '%s'\\n" "${_notebooks[*]:-}"

  printf "Syncing: "
  for __notebook in "${_notebooks[@]:-}"
  do
    printf "%s..." "${__notebook}"
    NOTES_DATA_DIR="${NOTES_DIR}/${__notebook}"
    (NOTES_AUTO_SYNC=1 _git_checkpoint "[NOTES] Sync" --spinner)
  done &&
    printf "Done!\\n" ||
    printf "Syncing failed!\\n"
}

# update ######################################################################

desc "update" <<HEREDOC
Usage:
  ${_ME} update

Description:
  Update ${_ME} to the latest version.
HEREDOC
_update() {
  if hash npm 2>/dev/null &&
     npm list | grep -q notes.sh &&
     [[ "${BASH_SOURCE[0]}" =~ \/node\/|\/node_modules\/ ]]
  then # installed with npm
    cat <<'HEREDOC'
Installed with npm. To update, run:
  npm update -g notes.sh
HEREDOC
  elif [[ "${OSTYPE}" =~ ^darwin ]] &&
       [[ "$(realpath "${BASH_SOURCE[0]}")" =~ Cellar ]]
  then
    cat <<'HEREDOC'
Installed with Homebrew. To update, run:
  brew upgrade xwmx/taps/notes
HEREDOC
  else
    _notes_url="https://raw.githubusercontent.com/xwmx/notes/master/notes"
    _temp_file="$(mktemp)"

    curl -s "${_notes_url}" -o "${_temp_file}"

    if [[ "$(_get_hash "${_temp_file}")" != "$(_get_hash "${BASH_SOURCE[0]}")" ]]
    then
      while true
      do
        read -r -p "Updating \`${_ME}\` in place. Are you sure you want to proceed? [y/N] " __yn
        case ${__yn} in
          [Yy]*)
            break
            ;;
          *)
            printf "Exiting...\\n"
            exit 0
            ;;
        esac
      done

      cat  "${_temp_file}" > "${BASH_SOURCE[0]}"
      printf "%s updated to the latest version.\n" "${_ME}"
    else
      printf "Already at the latest version.\n"
    fi

    if [[ -n "${_temp_file}" ]]
    then
      rm "${_temp_file}"
    fi
  fi
}

# use #########################################################################

desc "use" <<HEREDOC
Usage:
  ${_ME} use <notebook>

Description:
  Switch to the specified notebook. Shortcut for \`notes notebooks use\`.
HEREDOC
_use() {
  local _name="${1:-}"
  if [[ -z "${_name}" ]]
  then
    _help use
    return 1
  fi
  _notebooks use "${_name}"
}

# version ####################################################################

desc "version" <<HEREDOC
Usage:
  ${_ME} version

Description:
  Display version information.
HEREDOC
_version() {
  printf "%s\\n" "${_VERSION}"
}

###############################################################################
# _notes()
###############################################################################

# _notes()
#
# Description:
#   Call the appropriate subcommand.
_notes() {
  _debug printf "_notes() >> start\\n"
  _debug printf "_notes() \${@}: '%s'\\n" "${@}"
  _debug printf "_notes() \${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"

  # Set `$_SUBCOMMAND` if it's still blank.
  if [[ -z "${_SUBCOMMAND:-}" ]]
  then
    _SUBCOMMAND="ls"
  fi

  if [[ -n "${_SCOPE}" ]]
  then
    NOTES_DATA_DIR="${NOTES_DIR}/${_SCOPE}"
  else
    _SCOPE="$(basename "${NOTES_DATA_DIR}")"
  fi

  case "${_SUBCOMMAND}" in
    init|sync)
      _git_required
      "_${_SUBCOMMAND}" "${@}"
      ;;
    commands|env|help|version)
      "_${_SUBCOMMAND}" "${@}"
      ;;
    *)
      _git_required

      # Call `_init()` if configuration hasn't been initialized.
      if [[ ! -e "${NOTES_DIR}"       ]] &&
         [[ ! -e "${NOTESRC_PATH}"    ]] ||
         [[ ! -e "${NOTES_DATA_DIR}"  ]]
      then
        _git_required
        _init "${@}"
        _ls || true # returns 0 due to empty repository.
        return 0
      fi

      local _core_subcommands=(
        a
        add
        count
        d
        delete
        e
        edit
        list
        ls
        move
        mv
        nb
        nbs
        notebook
        notebooks
        q
        rename
        s
        show
        search
        use
      )
      local _core_subcommand_pattern
      _core_subcommand_pattern="^$(_join '$|^' "${_core_subcommands[@]}")$"

      _debug printf "\${_SUBCOMMAND}: %s\\n" "${_SUBCOMMAND}"
      _debug printf "\${_core_subcommand_pattern}: %s\\n" "${_core_subcommand_pattern}"

      if [[ "${_SUBCOMMAND}" =~ ${_core_subcommand_pattern} ]]
      then
        if _git_index_is_dirty
        then
          _index reconcile

          if _git_should_autosync
          then
            _debug \
              printf "_notes(): _git_index_is_dirty && ((NOTES_AUTO_SYNC))\\n"
            "${_MY_PATH}" sync
          else
            _debug \
              printf "_notes(): _git_index_is_dirty && ! ((NOTES_AUTO_SYNC))\\n"
            _git_checkpoint "[NOTES] Commit" --spinner
          fi
        elif _git_should_autosync
        then
          _debug \
            printf "_notes(): ! _git_index_is_dirty\\n"
          ("${_MY_PATH}" sync &>/dev/null) &
        fi
      fi

      "_${_SUBCOMMAND}" "${@}"
      ;;
  esac
}

###############################################################################
# Program Option Parsing
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring='h'

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while ((${#}))
do
  case "${1}" in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c="${1:i:1}"
        # add current char to options
        options+=("-${c}")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ "${optstring}" = *"${c}:"* && "${1:i+1}" ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_SCOPE=
_ARGUMENTS=()

# $_SUBCOMMANDS
#
# All available subcommands.
_SUBCOMMANDS=(
  a
  add
  commands
  config
  count
  d
  delete
  e
  edit
  export
  env
  git
  help
  history
  import
  index
  init
  list
  ls
  move
  mv
  nb
  nbs
  notebook
  notebooks
  open
  q
  remote
  rename
  s
  search
  settings
  show
  status
  sync
  update
  use
  version
)

# $_SUBCOMMANDS_PATTERN
#
# The contents of the `$_SUBCOMMANDS` array, joined with '|', with the
# `@(<pattern list>)` pattern matching operator, which matches one of the
# given patterns. This operator is enabled using `shopt -s extglob`.
#
# More information:
# http://stackoverflow.com/a/13254908
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
_SUBCOMMANDS_PATTERN="@($(_join '|' "${_SUBCOMMANDS[@]}"))"

_debug printf "\${_SUBCOMMANDS_PATTERN}: %s\\n" "${_SUBCOMMANDS_PATTERN}"

# _is_valid_subcommand()
#
# Usage:
#   _is_valid_subcommand <name>
#
# Returns:
#   0  If the given <name> is a valid subcommand name.
#   1  If not.
_is_valid_subcommand() {
  case "${1:-}" in
    ${_SUBCOMMANDS_PATTERN})
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# _require_argument()
#
# Usage:
#   _require_argument <option> <argument>
#
# If <argument> is blank or another option, print an error message and  exit
# with status 1.
_require_argument() {
  local _option="${1:-}"
  local _value="${2:-}"

  if [[ -z "${_value}" ]] || [[ "${_value}" =~ ^- ]]
  then
    _die printf "Option requires an argument: %s\\n" "${_option}"
  fi
}

# getopts and getopts have inconsistent behavior, so using a simple home-brewed
# while loop. This isn't perfectly compliant with POSIX, but it's close enough
# and this appears to be a widely used approach.
#
# More info:
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
while ((${#}))
do
  __opt="${1}"
  shift
  case "${__opt}" in
    -h|--help)
      _PRINT_HELP=1
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      _PRINT_VERSION=1
      ;;
    *:*)
      __parts=($(printf "%s\\n" "${__opt}" | tr ":" "\\n"))
      if [[ -z "${_SCOPE:-}"        ]] &&
         [[ -z "${_SUBCOMMAND:-}"   ]] &&
         [[ "${#__parts[@]}" -gt 0  ]]
      then
        if [[ -d "${NOTES_DIR}/${__parts[0]}" ]]
        then
          _SCOPE="${__parts[0]}"
          if _is_valid_subcommand "${__parts[1]:-}"
          then
            _SUBCOMMAND="${__parts[1]:-}"
          fi
        else
          printf "Notebook not found: %s\\n" "${__parts[0]}"
          exit 1
        fi
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
    --endopts)
      # Terminate option parsing.
      break
      ;;
    *)
      if [[ -z "${_SUBCOMMAND:-}" ]] && _is_valid_subcommand "${__opt}"
      then
        _SUBCOMMAND="${__opt}"
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
  esac
done

_debug printf "\${_SUBCOMMANDS[*]}: '%s'\\n" "${_SUBCOMMANDS[*]}"
_debug printf "\${_SUBCOMMANDS_PATTERN}: '%s'\\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"
_debug printf "\${_SCOPE}: '%s'\\n" "${_SCOPE}"
_debug printf "\${_ARGUMENTS[*:-]}: '%s'\\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# _main()
###############################################################################

# _main()
#
# Usage:
#   _main "$@"
#
# Describe:
#   Primary entry point for the program logic. Call this function at the end
#   of the script after everything has been defined.
_main() {
  if (("${_PRINT_HELP}"))
  then
    _help "${_SUBCOMMAND:-}"
  elif (("${_PRINT_VERSION}"))
  then
    _version
  else
    _notes "${_ARGUMENTS[@]:-}"
  fi
}

_main "${@:-}"
