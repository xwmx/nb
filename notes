#!/usr/bin/env bash
# __                _
# \ \   _ __   ___ | |_ ___  ___
#  \ \ | '_ \ / _ \| __/ _ \/ __|
#  / / | | | | (_) | ||  __/\__ \
# /_/  |_| |_|\___/ \__\___||___/
#
# Command line note-taking, bookmarking, and document management with
# encryption, advanced search, Git-backed versioning and syncing,
# Pandoc-backed format conversion, and more in a single portable script.
#
# https://github.com/xwmx/notes
#
# Based on Bash Boilerplate: https://github.com/xwmx/bash-boilerplate
#
# Copyright (c) 2015-present William Melody â€¢ hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
set -o noglob
IFS=$'\n\t'

###############################################################################
# Environment
###############################################################################

_VERSION="2.9.2"

# $_ME
#
# Set to the program's basename.
_ME="$(basename "${0}")"

# $_MY_PATH
#
# Set to the programs full path.
_MY_PATH="$(cd "$(dirname "$0")"; pwd)/$(basename "${0}")"

# extglob
#
# Enable extended pattern matching operators.
#
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
shopt -s extglob

# $_SED_I_COMMAND
#
# `sed -i` takes an extension on macOS, but that extension can cause errors in
# GNU `sed`.
#
# NOTE: To use this command, call it with `"${_SED_I_COMMAND[@]}"`
#
# https://stackoverflow.com/q/43171648
# http://stackoverflow.com/a/16746032
if sed --help >/dev/null 2>&1
then # GNU
  export _SED_I_COMMAND=(sed -i)
else # macOS
  export _SED_I_COMMAND=(sed -i '')
fi

###############################################################################
# .notesrc
###############################################################################

# .notesrc
#
# If a `.notesrc` file exists in `$HOME`, source it.
export NOTESRC_PATH="${NOTESRC_PATH:-${HOME}/.notesrc}"
if [[ -e "${NOTESRC_PATH}" ]]
then
  # shellcheck disable=SC1090
  #
  # Shellcheck can't follow non-constant source.
  #
  # More information:
  #   https://github.com/koalaman/shellcheck/wiki/SC1090
  source "${NOTESRC_PATH}"
fi

###############################################################################
# $EDITOR
###############################################################################

# Set default $EDITOR if one has not been set.
if [[ -z "${EDITOR:-}" ]]
then
  if hash "code" 2>/dev/null
  then
    export EDITOR="code"
  elif hash "subl" 2>/dev/null
  then
    export EDITOR="subl"
  elif hash "mate" 2>/dev/null
  then
    export EDITOR="mate"
  elif hash "nano" 2>/dev/null
  then
    export EDITOR="nano"
  elif hash "vi" 2>/dev/null
  then
    export EDITOR="vi"
  else
    _die printf "\$EDITOR not found. Set the editor in ~/.notesrc\n"
  fi
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  %s " "${__DEBUG_COUNTER}"
    "${@}"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "${@}"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "âŒ  "
  "${@}" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "${@}"
}

###############################################################################
# Setup
###############################################################################

# `$NOTES_DIR`
#
# Default: `$HOME/.notes`
export NOTES_DIR="${NOTES_DIR:-${HOME}/.notes}"

# `$NOTES_DATA_DIR`
#
# Default: `$NOTES_DIR/home`
export NOTES_DATA_DIR="${NOTES_DATA_DIR:-${NOTES_DIR}/home}"
_set_notes_data_dir() {
  if [[ -e "${NOTES_DIR}/.current" ]]
  then
    local _current
    _current="$(cat "${NOTES_DIR}/.current")"
    if [[ -e "${NOTES_DIR}/${_current}" ]]
    then
      NOTES_DATA_DIR="${NOTES_DIR}/${_current}"
    fi
  fi
} && _set_notes_data_dir

# `$NOTES_AUTO_SYNC`
#
# Default: 1
#
# When set to '1', each `_git_checkpoint()` call will automativally run
# `$_ME sync`. To disable this behavior, set the value to '0'.
export NOTES_AUTO_SYNC="${NOTES_AUTO_SYNC:-1}"

# `$NOTES_DEFAULT_EXTENSION`
#
# Default: 'md'
#
# Example Values: 'md' 'org'
export NOTES_DEFAULT_EXTENSION="${NOTES_DEFAULT_EXTENSION:-md}"

# `$NOTES_HIGHLIGHT_COLOR`
#
# Default: 11 (yellow) for 256 color terminals, 3 (yellow) for 8 color.
#
# Set highlighting color. This should be set to an xterm color number, usually
# a value between 1 and 256. For a table colors and their numbers run:
#
#   notes settings colors
#
# Supported Values: [0..255]
_set_notes_highlight_color() {
  local _colors=
  _colors="$(tput colors)"
  if [[ -n "${_colors}" ]] && [[ "${_colors}" -gt 8 ]]
  then
    export NOTES_HIGHLIGHT_COLOR="${NOTES_HIGHLIGHT_COLOR:-11}"
  else
    export NOTES_HIGHLIGHT_COLOR="${NOTES_HIGHLIGHT_COLOR:-3}"
  fi
} && _set_notes_highlight_color

# `$NOTES_ENCRYPTION_TOOL`
#
# Default: 'openssl'
#
# Supported Values: 'gpg' 'openssl'
export NOTES_ENCRYPTION_TOOL="${NOTES_ENCRYPTION_TOOL:-openssl}"

###############################################################################
# Temp Directory
###############################################################################

export _NOTES_TEMP_DIRECTORY
_NOTES_TEMP_DIRECTORY="$(mktemp -d)"

# Usage: _tempfile_path <basename>
_tempfile_path() {
  [[ -z "${1:-}" ]] && return 1
  printf "%s/%s" "${_NOTES_TEMP_DIRECTORY}" "${1:-}"
}

# Usage: _notes_cleanup_on_exit
_notes_cleanup_on_exit() {
  if [[ -n "${_NOTES_TEMP_DIRECTORY:-}" ]] &&
     [[ -e "${_NOTES_TEMP_DIRECTORY}"   ]]
  then
    rm -rf "${_NOTES_TEMP_DIRECTORY}"
  fi
}

trap _notes_cleanup_on_exit EXIT

###############################################################################
# Helpers
###############################################################################

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Takes a potential command name as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
#
# Returns:
#   0  If the item is included in the list.
#   1  If not.
_contains() {
  local _test_list=(${*:2})
  for __test_element in "${_test_list[@]:-}"
  do
    _debug printf "_contains() \${__test_element}: %s\\n" "${__test_element}"
    if [[ "${__test_element}" == "${1}" ]]
    then
      _debug printf "_contains() match: %s\\n" "${1}"
      return 0
    fi
  done
  return 1
}

# _decrypt_file
#
# Usage:
#   _decrypt_file <path> <password>
_decrypt_file() {
  local _encrypted_path="${1:-}"
  local _password="${2:-}"

  if [[ -z "${_password}" ]]
  then
    printf "Password required.\n"
    return 1
  fi

  if [[ -z "${_encrypted_path}" ]]
  then
    return 1
  fi

  local _basename
  _basename="$(basename "${_encrypted_path}")"

  local _unencrypted_basename
  _unencrypted_basename="$(printf "%s" "${_basename}" | sed 's/.enc$//')"

  local _unencrypted_path
  _unencrypted_path="$(_tempfile_path "${_unencrypted_basename}")"

  local _file_command_response
  _file_command_response="$(file "${_encrypted_path}")"

  if [[ "${_file_command_response}" =~ GPG ]]
  then
    if _command_exists "gpg"
    then
      printf "%s\\n" "${_password}" \
        | gpg \
          --quiet \
          --batch \
          --passphrase-fd 0 \
          --output "${_unencrypted_path}" \
          --decrypt "${_encrypted_path}"
    else
      printf "\
This note was encrypted with GPG, but the GPG command was not found.\n"
      return 1
    fi
  elif [[ "${_file_command_response}" =~ openssl ]]
  then
    openssl enc -d -aes-256-cbc \
      -in "${_encrypted_path}" -out "${_unencrypted_path}" \
      -pass file:<(printf "%s\\n" "${_password}") 2> /dev/null ||
      rm "${_unencrypted_path}"
  else
    printf "Unable to decrypt file.\\n"
    return 1
  fi

  if [[ ! -e "${_unencrypted_path}" ]]
  then
    printf "Decryption error.\n" 1>&2
    return 1
  fi

  printf "%s\n" "${_unencrypted_path}"
}

# _edit_file()
#
# Usage:
#   _edit_file <path> [--no-wait]
#
# Description:
#   Open the file in $EDITOR. Use the `-f` option in vim and `--wait` option in
#   other GUI editors to wait until the file is closed in the editor before
#   continuing, unless `--no-wait`.
_edit_file() {
  local _file_path="${1:-}"
  local _wait=1

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --no-wait)
        _wait=0
        ;;
      *)
        if [[ -z "${_file_path}" ]]
        then
          _file_path="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_file_path}" ]]
  then
    return 1
  fi

  cd "${NOTES_DATA_DIR}" || return 1

  if _file_is_encrypted "${_file_path}"
  then
    printf "\
Can't edit encrypted files. Export file and decrypt to edit.\n"
    exit 1
  fi

  if _file_is_archive "${_file_path}"
  then
    printf "\
Can't edit archives. Export archive and expand to edit.\n"
    exit 1
  fi

  if ! _file_is_text "${_file_path}"
  then
    if _command_exists "xdg-open"
    then
      xdg-open "${_file_path}" && return 0
    elif [[ "${OSTYPE}" =~ ^darwin ]]
    then
      open "${_file_path}" && return 0
    fi
  fi

  if ((_wait)) &&
     [[ "${EDITOR}" =~ mvim ]] ||
     [[ "${EDITOR}" =~ gvim ]]
  then
    "${EDITOR}" -f "${_file_path}"
  elif ((_wait)) &&
       [[ "${EDITOR}" =~ code ]] ||
       [[ "${EDITOR}" =~ mate ]] ||
       [[ "${EDITOR}" =~ subl ]]
  then
    "${EDITOR}" --wait "${_file_path}"
  else
    "${EDITOR}" "${_file_path}"
  fi
}

# _encrypt_file
#
# Usage:
#   _encrypt_file <decrypted path> <encrypted path> <password>
_encrypt_file() {
  local _decrypted_path="${1:-}"
  local _encrypted_path="${2:-}"
  local _password="${3:-}"

  if [[ -z "${_password}" ]]
  then
    printf "Password required.\n"
    return 1
  fi

  if [[ -z "${_decrypted_path}" ]] ||
     [[ -z "${_encrypted_path}" ]]
  then
    printf "Encrypted and decripted paths required.\n"
    return 1
  fi

  if [[ "${NOTES_ENCRYPTION_TOOL}" == "gpg" ]]
  then
    printf "%s\n" "${_password}" \
      | gpg \
        --quiet \
        --batch \
        --passphrase-fd 0 \
        --output "${_encrypted_path}" \
        --symmetric \
        --cipher-algo AES256 \
        "${_decrypted_path}"
  elif [[ "${NOTES_ENCRYPTION_TOOL}" == "openssl" ]]
  then
    openssl enc -aes-256-cbc \
      -in "${_decrypted_path}" \
      -out "${_encrypted_path}" \
      -pass file:<(printf "%s\n" "${_password}")
  else
    printf "\$NOTES_ENCRYPTION_TOOL must be set to either 'gpg' or 'openssl'."
    return 1
  fi

  if [[ ! -e "${_encrypted_path}" ]]
  then
    printf "Encryption error.\n"
    return 1
  fi
}

# _file_is_archive()
#
# Usage:
#   _file_is_archive <path>
#
# Returns:
#   1  If file is an archive.
#   0  if not.
_file_is_archive() {
  [[ "$(file "${1:-}" | cut -d: -f2)" =~ archive|compressed ]]
}

# _file_is_bookmark()
#
# Usage:
#   _file_is_bookmark <path>
#
# Returns:
#   1 If file is a bookmark.
#   0 if not.
_file_is_bookmark() {
  [[ "${1:-}" =~ .bookmark.md$      ]] ||
  [[ "${1:-}" =~ .bookmark.md.enc$  ]] ||
  [[ "${1:-}" =~ -bookmark.md$      ]] ||
  [[ "${1:-}" =~ -bookmark.md.enc$  ]]
}

# _file_is_encrypted()
#
# Usage:
#   _file_is_encrypted <path>
#
# Returns:
#   1  If file is encrypted.
#   0  if not.
_file_is_encrypted() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # `file` with 'soft' test is slow, so avoid calling it.
  [[ "${_file_type}" == "enc" ]] ||
    [[ ! "$(file "${1:-}" \
            -b --mime-type \
            --exclude=apptype \
            --exclude=encoding \
            --exclude=tokens \
            --exclude=cdf \
            --exclude=compress \
            --exclude=elf \
            --exclude=soft \
            --exclude=tar)" =~ ^text ]] &&
    # [[ "$(dd bs=1 count=6 if="${_file_path}" 2>/dev/null)" == 'Salted'  ]] ||
    [[ "$(file "${_file_path:-}" \
            --exclude=apptype \
            --exclude=encoding \
            --exclude=tokens \
            --exclude=cdf \
            --exclude=compress \
            --exclude=elf \
            --exclude=tar)" =~ encrypted|openssl ]]
}

# _file_is_text()
#
# Usage:
#   _file_is_text <path>
#
# Returns:
#   1  If file is text.
#   0  if not.
_file_is_text() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # Avoid calling `file` for better performance.
  [[ "${_file_type}" =~ ^html|latex|md|markdown|org|rst|textile|txt$ ]] ||
    [[ "$(file -b --mime-type "${1:-}")" =~ ^text ]]
}

# _get_hash()
#
# Usage:
#   _get_hash <path>
#
# Description:
#   Generate a hash for the file at the given <path>.
_get_hash() {
  local _hash
  if _command_exists "md5sum"
  then
    _hash="$(md5sum "${1:-}" | awk '{ print $1 }')"
  elif _command_exists "md5"
  then
    _hash="$(md5 -q "${1:-}")"
  fi
  printf "%s\\n" "${_hash}"
}

# _get_selection_basename()
#
# Usage:
#   _get_selection_basename <id>
#   _get_selection_basename <filename>
#   _get_selection_basename <path>
#   _get_selection_basename <title>
#
# Description:
#   Determine the basename of the file in `$NOTES_DATA_DIR` that is identified
#   by the given <id>, <filename>, <path>, or <title>.
_get_selection_basename() {
  local _basename=
  local _selection="${1:-}"
  local _identifier=
  if [[ -z "${_selection}" ]]
  then  # <selection> is blank.
    _basename=
  else

    _set_selection_notebook "${_selection}"
    _identifier="$(_get_selection_identifier "${_selection}")"

    if [[ -e "${_identifier}" ]] &&
       [[ "${_identifier}" =~ ${NOTES_DATA_DIR} ]]
    then # <selection> is a full path.
      _basename="$(basename "${_identifier}")"
    elif [[ -e "${NOTES_DATA_DIR}/${_identifier}" ]]
    then # <selection> is a filename.
      _basename="${_identifier}"
    elif [[ "${_identifier}" =~ ^[0-9]+$ ]]
    then # <selection> is an id.
      _basename="$(_index get_basename "${_identifier}")"
    else # <selection> might be a title.
      local _title
      local _filenames

      _filenames=($(_list_notes_files))
      for __file in "${_filenames[@]:-}"
      do
        _title="$(_get_title "${NOTES_DATA_DIR}/${__file}")"

        if [[ -n "${_title}" ]] &&
           [[ "${_title}" == "${_identifier}" ]]
        then
          _basename="${__file}"
          break
        fi
      done
    fi
  fi

  printf "%s\\n" "${_basename}"
}

# _get_selection_identifier()
#
# Usage:
#   _get_selection_identifier <selection>
#
# Description:
#   Given <selection>, print the identifier portion.
_get_selection_identifier() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))
  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    printf "%s\\n" "${_parts[1]:-}"
  else
    printf "%s\\n" "${_parts[0]:-}"
  fi
}

# _get_selection_parts()
#
# Usage:
#   _get_selection_parts <selection>
#
# Description:
#   Given <selection>, split on first colon.
_get_selection_parts() {
  local _identifier
  local _data_dir

  _data_dir=$(printf "%s\\n" "${1:-}" | cut -f 1 -d ":")

  if [[ "${1:-}" =~ ':'       ]] &&
     [[ -e "${NOTES_DIR}/${_data_dir}/.git" ]]
  then
    _identifier=$(printf "%s\\n" "${1:-}" | cut -f 2- -d ":")
    printf "%s\\n%s\\n" "${_data_dir}" "${_identifier}"
  else
    printf "%s\\n" "${1:-}"
  fi
}

# _get_title()
#
# Usage:
#   _get_title <path>
#
# Description:
#   Print the title, if present, of the note at the path. Supports both
#   Markdown h1 styles and YAML front matter.
_get_title() {
  local _in_front_matter=0
  local _maybe_title=
  local _path="${1:-}"
  local _title=

  if [[ -z "${_path}" ]]
  then
    _die printf "Usage: _get_title <path>\\n"
  elif [[ -e "${_path}" ]]
  then
    if _file_is_text "${_path}"
    then

      while IFS= read -r __line
      do
        if [[ "${__line}" =~ ^[[:space:]]*#\  ]]
        then # first line starts with an H1
          _title="$(
            printf "%s\\n" "${__line}" \
              | sed 's/^[[:space:]]*# //' \
              | sed 's/ #$//'
            )"
          break
        elif [[ "${__line}" =~ ^---$ ]]
        then
          if ((_in_front_matter))
          then
            _in_front_matter=0
          else
            _in_front_matter=1
          fi
        elif [[ "${__line}" =~ ^title\: ]]
        then
          _title="$(printf "%s\\n" "${__line}" | sed 's/^title: //')"
          break
        elif ! ((_in_front_matter))
        then
          if [[ -z "${_maybe_title}" ]] && [[ -n "${__line}" ]]
          then
            _maybe_title="${__line}"
          elif [[ "${__line}" =~ ^[[:space:]]*\=+$ ]]
          then
            _title="$(
              printf "%s\\n" "${_maybe_title}" | sed 's/^[[:space:]]*//'
            )"
            break
          elif [[ -n "${_maybe_title}" ]]
          then
            break
          else
            continue
          fi
        fi
      done < "${_path}"

      printf "%s\\n" "${_title}"
    fi
  fi
}

# _get_unique_basename()
#
# Usage:
#   _get_unique_basename [<file name> | <file extension>]
#
# Description:
#   Get a unique basename that doesn't conflict with any existing file.
_get_unique_basename() {
  local _file_basename="${1:-}"

  local _file_name="${_file_basename%.*}"
  if [[ -z "${_file_name}" ]]
  then
    _file_name="$(date -u "+%Y%m%d%H%M%S")"
  fi

  local _file_type="${_file_basename##*.}"
  if [[ -z "${_file_type}" ]]
  then
     _file_type="md"
  fi

  local _uniqueness_counter=0
  local _unique_filename="${_file_name}"
  while [[ -e "${NOTES_DATA_DIR}/${_unique_filename}.${_file_type}" ]]
  do
    printf -v _unique_filename -- "%s-%02d" \
      "${_file_name}" \
      "$(( ++_uniqueness_counter ))"
  done
  printf "%s\n" "${_unique_filename}.${_file_type}"
}

# _git_checkpoint()
#
# Usage:
#   _git_checkpoint <commit message> [<target-directory>]
#
# Description:
#   Commit all files in the repository with the provided commit message.
_git_checkpoint() {
  _git_checkpoint_commit() {
    [[ -z "${1:-}" ]] && _die printf "Usage: _git_checkpoint_commit <message>"
    _debug printf "_git_checkpoint() \$(ls -la): '%s'\n" \
      "$(ls -la)"

    git add --all && git commit -a -m "${1}"
  }
  _git_checkpoint_sync() {
    if git show-branch remotes/origin/master > /dev/null 2>&1
    then
      git fetch && git rebase origin/master && git push
    else
      git push
    fi
  }

  local _message=
  local _show_spinner=0
  local _target_directory=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --spinner)
        _show_spinner=1
        ;;
      *)
        if [[ -z "${_message}" ]]
        then
          _message="${__arg}"
        elif [[ -z "${_target_directory}" ]]
        then
          _target_directory="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_target_directory}" ]]
  then
    _target_directory="${NOTES_DATA_DIR}"
  fi

  _debug printf "_git_checkpoint() \${_target_directory}: '%s'\n" \
    "${_target_directory}"

  if [[ -z "${_message}" ]]
  then
    _die printf "Usage: _git_checkpoint <message>\\n"
    return 1
  fi

  if [[ -n "${2:-}" ]] && [[ "${2}" == "--spinner" ]]
  then
    _show_spinner=1
  fi

  cd "${_target_directory}" || _die printf "_git_checkpoint() \`cd\` failed.\\n"

  _debug printf "_git_checkpoint() \$(ls -la): '%s'\n" "$(ls -la)"

  if ((NOTES_AUTO_SYNC))
  then
    (
      # Only sync when the index is dirty to avoid fetching from and pushing
      # to origin.
      if _git_index_is_dirty "${_target_directory}"
      then
        _git_checkpoint_commit "${_message}" &>/dev/null
      fi && _git_checkpoint_sync &>/dev/null
    ) &
  else
    (
      _git_checkpoint_commit "${_message}" &>/dev/null
    ) &
  fi

  if ((_show_spinner))
  then
    _spinner ${!}
  fi
}

# _git_index_is_dirty()
#
# Usage:
#   _git_index_is_dirty [<target-directory>]
#
# Returns:
#   0  If there are uncommitted changes in `NOTES_DATA_DIR` or
#      <target-directory>.
#   1  If the `$NOTES_DATA_DIR` repository is clean.
_git_index_is_dirty() {
  local _target_directory="${1:-}"
  if [[ -z "${_target_directory}" ]]
  then
    _target_directory="${NOTES_DATA_DIR}"
  fi

  cd "${_target_directory}" ||
    _die printf "_git_index_is_dirty() \`cd\` failed.\\n"
  [[ -n "$(git status --porcelain)" ]]
}

# _git_required()
#
# Usage:
#   _git_required
#
# Description:
#   Exit with `_die` if `git` isn't found.
_git_required() {
  if ! _command_exists "git"
  then
    _die printf "\`git\` is required, but wasn't found.\\n"
  fi

  local _git_name
  _git_name="$(git config user.name || printf '')"
  local _git_email
  _git_email="$(git config user.email || printf '')"

  if [[ -z "${_git_name}" ]] || [[ -z "${_git_email}" ]]
  then
    printf "git configuration incomplete. To set your name and email, run:\\n"
    if [[ -z "${_git_name}" ]]
    then
      printf "git config --global user.name \"Your Name\"\\n"
    fi
    if [[ -z "${_git_email}" ]]
    then
      printf "git config --global user.email \"you@example.com\"\\n"
    fi
    return 1
  fi
}

# _git_should_autosync()
#
# Usage:
#   _git_should_autosync
#
# Returns:
#   0  If an autosync should be triggered.
#   1  If not.
_git_should_autosync() {
  local _last_fetch_timestamp
  local _current_timestamp

  if ! ((NOTES_AUTO_SYNC))
  then # autosync not enabled.
    return 1
  fi

  cd "${NOTES_DATA_DIR}" || _die printf "\`cd\` failed.\\n"
  if ! git config --get remote.origin.url &>/dev/null
  then # there is no remote configured.
    return 1
  fi

  if [[ ! -e "${NOTES_DATA_DIR}/.git/FETCH_HEAD" ]]
  then # no previous fetches, but has an origin and autosync is enabled.
    return 0
  fi

  if stat -c &>/dev/null
  then # GNU
    _last_fetch_timestamp="$(stat -c %Y .git/FETCH_HEAD)"
  elif gstat -c &>/dev/null
  then # GNU prefixed
    _last_fetch_timestamp="$(gstat -c %Y .git/FETCH_HEAD)"
  else
    _last_fetch_timestamp="$(stat -f '%m' .git/FETCH_HEAD)"
  fi
  _current_timestamp="$(date +%s)"

  _diff=$((_current_timestamp-_last_fetch_timestamp))
  _debug printf \
    "_git_should_sync() \${_last_fetch_timestamp}: %s\\n" \
    "${_last_fetch_timestamp}"
  _debug printf \
    "_git_should_sync() \${_current_timestamp}: %s\\n" \
    "${_current_timestamp}"
  _debug printf \
    "_git_should_sync() \${_diff}: %s\\n" \
    "${_diff}"

  [[ "${_diff}" -gt 300 ]]
}

# _highlight()
#
# Usage:
#   _highlight <string>
#
# Description:
#   Use `tput` to highlight the given string.
export _TPUT_HIGHLIGHT_COLOR
_TPUT_HIGHLIGHT_COLOR="$(tput setaf "${NOTES_HIGHLIGHT_COLOR}")"
export _TPUT_SGR0=    && _TPUT_SGR0="$(tput sgr0)"
_highlight() {
  local _input="${1:-}"
  if [[ -z "${_input}" ]]
  then
    _die printf "Usage: _highlight <string>"
  fi

  printf "${_TPUT_HIGHLIGHT_COLOR:-}%s${_TPUT_SGR0:-}\\n" "${_input}"
}

# _highlight_syntax_if_available()
#
# Usage:
#   _highlight_syntax_if_available [<path>]
#
# Description:
#   If Pygments is available, use it to highlight syntax. When it is not
#   available, just pipe through `cat`.
#
# References:
#   http://pygments.org/
_highlight_syntax_if_available() {
  if hash "pygmentize" 2>/dev/null
  then # pygments is installed.
    local _path="${1:-}"
    local _basename
    _basename="$(basename "${_path}")"

    local _extension="${_basename##*.}"

    # Markdown highlighting is better with explicit 'md' lexer.
    [[ ! "${_extension}" == "md" ]] &&
      pygmentize -O style=pastie "${@}" 2>/dev/null ||
      pygmentize -l md -O style=pastie "${@}"
  else
    cat "${@}"
  fi
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _join()
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
#
# Returns:
#   The list or array of items joined into a string with elements divided by
#   the optional separator if one is provided.
#
# More information:
#   https://stackoverflow.com/a/17841619
_join() {
  local _delimiter="${1}"
  shift
  printf "%s" "${1}"
  shift
  printf "%s" "${@/#/${_delimiter}}" | tr -d '[:space:]'
}

# _list_notes_files()
#
# Usage:
#   _list_notes_files [--sort] [--reverse]
#
# Description:
#   List note files with default sorting.
_list_notes_files() {
  # Relevant `ls` options:
  # --  Default sort order.
  # -t  Sort by time modified (most recently modified first) before sorting
  #     the operands by lexicographical order
  # -r  Reverse the order of the sort to get reverse order or the oldest
  #     entries first (or largest files last, combined with sort by size

  if [[ "${1:-}" == "--sort" ]]
  then
    local _filenames=()
    local _index_file
    _index_file="$(< "${NOTES_DATA_DIR}/.index")"

    for __line in "${_index_file[@]}"
    do
      if [[ -n "${__line}" ]]
      then
        _filenames+=("${__line}")
      fi
    done

    if [[ "${2:-}" == "--reverse" ]]
    then
      printf "%s\n" "${_filenames[@]}" | sort -r
    else
      printf "%s\n" "${_filenames[@]}"
    fi
  else
    ls -t "${NOTES_DATA_DIR}"
  fi
}

# __option_value_is_present()
#
# Usage:
#   __option_value_is_present "${variable}"
#
# Returns:
#   0  The argument is blank or matches as an option flag.
#   1  The argument is present and does not match an option flag.
__option_value_is_present() {
  [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
}

# _print_line()
#
# Usage:
#   _print_line <text>
#
# Description:
#   Print a line of dashes the length of <text>.
#
# More information:
#   http://wiki.bash-hackers.org/commands/builtin/printf
_print_line() {
  local _text="${1:-}"
  local _text_length=0
  local _line=
  _text_length=${#_text}
  printf -v _line '%*s' "${_text_length}"
  printf "%s\\n" "${_line// /-}"
}

# _set_selection_notebook()
#
# Usage:
#   _set_selection_notebook <selection>
#
# Description:
#   Given <selection>, set `$_SCOPE` and `$NOTES_DATA_DIR` with the notebook
#   name, if present.
_set_selection_notebook() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))
  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    _SCOPED=1
    NOTES_DATA_DIR="${NOTES_DIR}/${_parts[0]}"
    _SCOPE="$(basename "${NOTES_DATA_DIR}")"
  fi
}

# _spinner()
#
# Usage:
#   _spinner <pid>
#
# Description:
#   Display an ascii spinner while <pid> is running.
#
# Example Usage:
#   ```
#   _spinner_example() {
#     printf "Working..."
#     (sleep 1) &
#     _spinner $!
#     printf "Done!\\n"
#   }
#   (_spinner_example)
#   ```
#
# More Information:
#   http://fitnr.com/showing-a-bash-spinner.html
_spinner() {
  local _pid="${1:-}"
  local _delay=0.75
  local _spin_string="|/-\\"

  if [[ -z "${_pid}" ]]
  then
    _die printf "Usage: _spinner <pid>\\n"
  fi

  while ps a | awk '{print $1}' | grep -q "${_pid}"
  do
    local _temp="${_spin_string#?}"
    printf " [%c]  " "${_spin_string}"
    _spin_string="${_temp}${_spin_string%${_temp}}"
    sleep ${_delay}
    printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
#
# Examples:
# ```
#   desc "list" <<HEREDOC
# Usage:
#   ${_ME} list
#
# Description:
#   List items.
# HEREDOC
#
# desc --get "list"
# ```
#
# Set or print a description for a specified command or function <name>. The
# <description> text can be passed as the second argument or as standard input.
#
# To make the <description> text available to other functions, `desc()` assigns
# the text to a variable with the format `$___desc_<name>`.
#
# When the `--get` option is used, the description for <name> is printed, if
# one has been set.
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'HEREDOC'
# some message
# HEREDOC
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z "${1:-}" ]] && _die printf "desc(): No command name specified.\\n"

  if [[ "${1}" == "--get" ]]
  then # get ------------------------------------------------------------------
    [[ -z "${2:-}" ]] && _die printf "desc(): No command name specified.\\n"

    local _name="${2:-}"
    local _desc_var="___desc_${_name}"

    if [[ -n "${!_desc_var:-}" ]]
    then
      printf "%s\\n" "${!_desc_var}"
    else
      printf "No additional information for \`%s\`\\n" "${_name}"
    fi
  else # set ------------------------------------------------------------------
    if [[ -n "${2:-}" ]]
    then # argument is present
      read -r -d '' "___desc_${1}" <<HEREDOC
${2}
HEREDOC

      _debug printf "desc() set with argument: \${___desc_%s}\\n" "${1}"
    else # no argument is present, so assume piped input
      read -r -d '' "___desc_${1}"

      _debug printf "desc() set with pipe: \${___desc_%s}\\n" "${1}"
    fi
  fi
  set -e
}

###############################################################################
# help
###############################################################################

desc "help" <<HEREDOC
Usage:
  ${_ME} help [<subcommand>]

Description:
  Print the program help information. When a subcommand name is passed, print
  the help information for the subcommand.

Shortcut Alias: \`h\`
HEREDOC
_help() {
  if [[ -z "${1:-}" ]]
  then
    cat <<HEREDOC
__                _
\ \   _ __   ___ | |_ ___  ___
 \ \ | '_ \ / _ \| __/ _ \/ __|
 / / | | | | (_) | ||  __/\__ \\
/_/  |_| |_|\___/ \__\___||___/

Command line note-taking, bookmarking, and document management with
encryption, advanced search, Git-backed versioning and syncing,
Pandoc-backed format conversion, and more in a single portable script.

Usage:
  ${_ME} [<id> | <filename> | <path> | <title>] [<list options>]
  ${_ME} add [<filename> | <content>] [-c <content> | --content <content>]
            [-e | --encrypt] [-f <filename> | --filename <filename>]
            [-t <title> | --title <title>] [--type <type>]
  ${_ME} bookmark <url> [-c <comment> | --comment <comment>] [--edit]
                 [-e | --encrypt] [--skip-content] [--tags <tag1>,<tag2>...]
                 [--title <title>]
  ${_ME} bookmark (open | peek | url) (<id> | <filename> | <path> | <title>)
  ${_ME} count
  ${_ME} delete (<id> | <filename> | <path> | <title>) [-f | --force]
  ${_ME} edit (<id> | <filename> | <path> | <title>)
  ${_ME} export (<id> | <filename> | <path> | <title>) <path> [-f | --force]
               [<pandoc options>...]
  ${_ME} git <git options>...
  ${_ME} history [<id> | <filename> | <path> | <title>]
  ${_ME} import [copy | download | move] (<path> | <url>) [--convert]
  ${_ME} init [<remote-url>]
  ${_ME} list [-e [<length>] | --excerpt [<length>]] [--no-id]
             [-n <limit> | --<limit>] [-s | --sort] [-r | --reverse]
             [--titles] [<id> | <filename> | <path> | <title> | <query>]
  ${_ME} ls [<list options>...]
  ${_ME} move (<id> | <filename> | <path> | <title>) [-f | --force] <notebook>
  ${_ME} notebook [open]
  ${_ME} notebooks [<name>] [--names] [--no-color]
  ${_ME} notebooks add <name> [<remote-url>]
  ${_ME} notebooks current
  ${_ME} notebooks rename <old-name> <new-name>
  ${_ME} notebooks use <name>
  ${_ME} remote [remove | set <url> [-f | --force]]
  ${_ME} rename (<id> | <filename> | <path> | <title>) (<name> | --reset)
  ${_ME} search <query> [-a | --all] [--path]
  ${_ME} settings [colors | edit]
  ${_ME} settings (get | unset) <setting>
  ${_ME} settings set <setting> <value>
  ${_ME} shell [<subcommand> [<options>...] | --clear-history]
  ${_ME} show (<id> | <filename> | <path> | <title>) [--id | --path | --render]
             [--dump [--no-color]]
  ${_ME} sync [-a | --all]
  ${_ME} use <notebook>
  ${_ME} -i | --interactive [<subcommand> [<options>...]]
  ${_ME} -h | --help | help [<subcommand>]
  ${_ME} --version | version

Help:
  ${_ME} help [<subcommand>]

More Information:
  https://github.com/xwmx/notes
HEREDOC
  else
    desc --get "${@}"
  fi
}
desc "h" "$(_help 'help')"
_h() { _help "${@}"; }

###############################################################################
# Subcommands
###############################################################################

# add #########################################################################

desc "add" <<HEREDOC
Usage:
  ${_ME} add [<filename> | <content>] [-c <content> | --content <content>]
            [-e | --encrypt] [-f <filename> | --filename <filename>]
            [-t <title> | --title <title>] [--type <type>]

Options:
  -c --content   <content>    The content for the new note.
  -e --encrypt                Encrypt the note with a password.
  -f --filename  <filename>   The filename for the new note.
  -t --title     <title>      The title for a new note. If \`--title\` is
                              present, the filename will be derived from the
                              title, unless \`--filename\` is specified.
  --type         <type>       The file type for the new note, as a file
                              extension.

Description:
  Create a new note.

  If no arguments are passed, a new blank note file is opened with
  \`\$EDITOR\`, currently set to '${EDITOR}'. If a non-option argument is
  passed, \`notes\` will treat it as a <filenameâ‰¥ if a file extension is found.
  If no file extension is found, \`notes\` will treat the string as
  <content> and will create a new note without opening the editor.
  \`notes add\` can also create a new note with piped content.

  \`notes\` creates Markdown files by default. To create a note with a
  different file type, use the extension in the filename or use the \`--type\`
  option. To change the default file type, use \`notes settings\`.

  When the \`-e\` / \`--encrypt\` option is used, \`notes\` will encrypt the
  note with AES-256 using OpenSSL by default, or GPG, if configured in
  \`notes settings\`.

Examples:
  ${_ME} add
  ${_ME} add example.md
  ${_ME} add "Note content."
  ${_ME} add example.md --title "Example Title" --content "Example content."
  echo "Note content." | ${_ME} add
  ${_ME} add -t "Secret Document" --encrypt

Shortcut Alias: \`a\`
HEREDOC
_add() {
  local _basename=
  local _content=
  local _edit_before_save=0
  local _encrypt=0
  local _filename=
  local _maybe_filename_or_content=
  local _title=
  local _file_type="${NOTES_DEFAULT_EXTENSION}"
  local _arguments=()
  local _password=

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      -c|--content)
        if __option_value_is_present "${_val:-}"
        then
          _content="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      --edit)
        _edit_before_save=1
        ;;
      -e|--encrypt|--encrypted)
        _encrypt=1
        ;;
      -f|--filename)
        if __option_value_is_present "${_val:-}"
        then
          _filename="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      --password)
        if __option_value_is_present "${_val:-}"
        then
          _password="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      -t|--title)
        if __option_value_is_present "${_val:-}"
        then
          _title="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      --type)
        if __option_value_is_present "${_val:-}"
        then
          _file_type="${_val:-}"
          shift
        else
          _help add
          return 1
        fi
        ;;
      *)
        if [[ -z "${_maybe_filename_or_title:-}" ]]
        then
          _maybe_filename_or_content="${_arg:-}"
        else
          _arguments+=("${_arg:-}")
        fi
        ;;
    esac

    shift
  done

  local _maybe_filename_or_content_extension="${_maybe_filename_or_content##*\.}"
  if [[ -n "${_maybe_filename_or_content:-}" ]]
  then
    if [[ "${_maybe_filename_or_content:-}" =~ \.[A-Za-z0-9]+$ ]] &&
       [[ -n "${_maybe_filename_or_content_extension:-}" ]]
    then
      _filename="${_maybe_filename_or_content}"
    else
      _content="${_maybe_filename_or_content}"
    fi
  fi

  if [[ -n "${_filename:-}" ]]
  then
    _basename="$(_get_unique_basename "${_filename:-}")"
  elif [[ -n "${_title:-}" ]]
  then
    _filename="$(printf "%s" "${_title}" | tr '[:space:]' '_')"
    _basename="$(_get_unique_basename "${_filename}.${_file_type}")"
  else
    _basename="$(_get_unique_basename ".${_file_type}")" # !! note the '.'
  fi

  _target_path="${NOTES_DATA_DIR}/${_basename}"

  _debug printf "_show() \${_password}: '%s'\\n" "${_password}"

  if ((_encrypt))
  then
    if [[ -z "${_password}" ]]
    then
      printf "Password: "
      read -r -s _password </dev/tty
      printf "\\n" # print newline to stop `read`.

      if [[ -z "${_password:-}" ]]
      then
        printf "Password required.\n"
        return 1
      fi
    fi

    _target_path="$(_tempfile_path "${_basename}")"
  fi

  if [[ -n "${_title}" ]]
  then
    printf "%s\\n\\n" "# ${_title}" >> "${_target_path}"
  fi

  if [[ -n "${_content}" ]]
  then
    printf "%s\\n" "${_content}" >> "${_target_path}"
  fi

  if ! _interactive_input
  then # piped input
    cat >> "${_target_path}"
  fi

  if ((_edit_before_save)) || _interactive_input && [[ -z "${_content:-}" ]]
  then
    _edit_file "${_target_path}"
  fi

  if ((_encrypt)) && [[ -e "${_target_path}" ]]
  then
    local _decrypted_path="${_target_path}"
    local _encrypted_path="${NOTES_DATA_DIR}/${_basename}.enc"

    _encrypt_file "${_decrypted_path}" "${_encrypted_path}" "${_password}"

    if [[ -n "${_decrypted_path}" ]] && [[ -e "${_decrypted_path}" ]]
    then
      rm "${_decrypted_path}"
    fi

    _basename="${_basename}.enc"
    _target_path="${_encrypted_path}"
  fi

  _debug printf \
    "_add() \`\${_target_path}\`: '%s'\n" \
    "${_target_path:-}"

  if [[ -e "${_target_path}" ]]
  then
    _index add "${_basename}"

    local _id
    _id="$(_index get_id "${_basename}")"

    local _scoped_basename="${_basename}"

    if ((_SCOPED))
    then
      _id="${_SCOPE}:${_id}"
      _scoped_basename="${_SCOPE}:${_basename}"
    fi

    local _title
    _title="$(_get_title "${NOTES_DATA_DIR}/${_basename}")"
    if [[ -n "${_title}" ]]
    then
      printf "Added [%s] %s '%s'\\n" \
        "${_id}" \
        "${_scoped_basename}" \
        "${_title}"
    else
      printf "Added [%s] %s\\n" \
        "${_id}" \
        "${_scoped_basename}"
    fi
  fi &&
    _git_checkpoint "[NOTES] Add: ${_basename}"
}
desc "a" "$(_help 'add')"
_a() { _add "${@}"; }

# bookmark ####################################################################

desc "bookmark" <<HEREDOC
Usage:
  ${_ME} bookmark <url> [-c <comment> | --comment <comment>] [--edit]
                 [-e | --encrypt] [--skip-content] [--tags <tag1>,<tag2>...]
                 [--title <title>]
  ${_ME} bookmark (open | peek | url) (<id> | <filename> | <path> | <title>)

Options:
  -c --comment   <comment>      A comment or description for this bookmark.
  --edit                        Open the bookmark in your editor before saving.
  -e --encrypt                  Encrypt the bookmark with a password.
  --skip-content                Omit page content from the note.
  --tags         <tag1>,<tag2>  A comma-separated list of tags.
  --title        <title>        The bookmark title. When not specified,
                                \`notes\` will use the html <title> tag.

Subcommands:
  open    Open the bookmarked page in your system's primary web browser.
          Shortcut Alias: \`o\`
  peek    Open the bookmarked page in your terminal web browser.
          Shortcut Alias: \`p\`
  url     Print the URL for the specified bookmark.

Description:
  Create and view bookmarks.

  By default, the page content is saved within the bookmark, making the
  bookmarked page available for full-text search with \`notes search\`.
  When \`pandoc\` is installed, content will be converted to Markdown.

  Bookmark are identified by the \`.bookmark.md\` file extension. The bookmark
  URL is the first URL in the file within '<' and '>' characters:

    <https://www.example.com>

Examples:
  ${_ME} bookmark https://example.com
  ${_ME} bookmark https://example.com --tags example,sample,demo
  ${_ME} bookmark https://example.com/about --title 'Example Title'
  ${_ME} bookmark https://example.com -c 'Example comment.'
  ${_ME} bookmark open 5

Shortcut Alias: \`b\`
HEREDOC
_bookmark() {
  local _bookmark_content=
  local _comment=
  local _edit_before_save=0
  local _encrypt=0
  local _password=
  local _selection=
  local _skip_content=0
  local _subcommand=
  local _tag_list=
  local _title=
  local _url=

  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      -c|--comment)
        if __option_value_is_present "${_val:-}"
        then
          _comment="${_val:-}"
          shift
        else
          _help "bookmark"
          return 1
        fi
        ;;
      --edit)
        _edit_before_save=1
        ;;
      -e|--encrypt|--encrypted)
        _encrypt=1
        ;;
      --password)
        if __option_value_is_present "${_val:-}"
        then
          _password="${_val:-}"
          shift
        else
          _help edit
          return 1
        fi
        ;;
      --skip-content)
        _skip_content=1
        ;;
      --tags)
        if __option_value_is_present "${_val:-}"
        then
          _tag_list="${_val:-}"
          shift
        else
          _help "bookmark"
          return 1
        fi
        ;;
      --title)
        if __option_value_is_present "${_val:-}"
        then
          _title="${_val:-}"
          shift
        else
          _help "bookmark"
          return 1
        fi
        ;;
      open|o|peek|p|url)
        if __option_value_is_present "${_val:-}"
        then
          _subcommand="${_arg}"
          _selection="${_val:-}"
          shift
        else
          _help "bookmark"
          return 1
        fi
        ;;
      *)
        if [[ -z "${_url:-}" ]]
        then
          _url="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  if [[ "${_subcommand}" =~ ^open|o|peek|p|url$ ]]
  then
    local _basename
    _basename="$(_get_selection_basename "${_selection}")"
    if [[ -z "${_basename}" ]]
    then
      printf "Note not found: '%s'.\\n" "${_selection}"
      return 1
    fi
    _set_selection_notebook "${_selection}"

    local _target_path="${NOTES_DATA_DIR}/${_basename}"

    if [[ "${_subcommand}" =~ ^open|o|peek|p$ ]]
    then
      if [[ ! "${_basename}" =~ \.bookmark\.md$ ]] ||
         [[ ! "${_basename}" =~ \.bookmark\.md\.enc$ ]]
      then
        if [[ -n "${_password}" ]]
        then
          _show "${_selection}" --password "${_password}"
        else
          _show "${_selection}"
        fi
        return 0
      fi
    fi

    if _file_is_encrypted "${_target_path}"
    then
      local _encrypted_path
      _encrypted_path="${_target_path}"

      if [[ -z "${_password}" ]]
      then
        # Request password without displaying it
        printf "Password: "
        read -r -s _password </dev/tty
        printf "\\n" # print newline to stop `read`.
      fi

      if [[ -z "${_password}" ]]
      then
        printf "Password required.\n"
        return 1
      fi

      local _decrypted_path
      _decrypted_path="$(_decrypt_file "${_target_path}" "${_password}")"

      _target_path="${_decrypted_path}"
    fi

    local _target_url
    _target_url="$(
      awk -vRS=">" -vFS="<" '{print $2;exit}' "${_target_path}"
    )"

    if [[ "${_subcommand}" =~ ^peek|p$  ]]
    then
      if _command_exists 'w3m'
      then
        w3m "${_target_url}"
      elif _command_exists 'lynx'
      then
        lynx "${_target_url}"
      else
        curl -s "${_target_url}" | "${PAGER:-less}"
      fi

      return 0
    elif [[ "${_subcommand}" =~ ^open|o$ ]]
    then
      if _command_exists "xdg-open"
      then
        xdg-open "${_target_url}"
        return 0
      elif _command_exists "open"
      then
        open "${_target_url}"
        return 0
      else
        printf "notes doesn't know how to open URLs on your system.\n"
        return 1
      fi
    elif [[ "${_subcommand}" == "url" ]]
    then
      printf "%s\\n" "${_target_url}"
      return 0
    fi
  fi

  if [[ -z "${_url:-}" ]]
  then
    _help "bookmark"
    return 1
  fi

  local _basename
  _basename="$(_get_unique_basename "$(date -u '+%Y%m%d%H%M%S').bookmark.md")"

  _debug printf \
    "_bookmark() \`\${_basename}\`: '%s'\n" "${_basename:-}"

  local _target_path="${NOTES_DATA_DIR}/${_basename}"

  local _page_content
  if ! _page_content="$(curl -s "${_url}")" && [[ -z "${_page_content:-}" ]]
  then
    printf "Unable to download page at '%s'\\n" "${_url}"
    return 1
  fi

  if [[ -z "${_title}" ]]
  then
    _title="$(
      printf "%s\\n" "${_page_content}" \
        | awk -v IGNORECASE=1 -v RS='</title' 'RT{gsub(/.*<title[^>]*>/,"");print;exit}'
    )" || : # TODO: pipeline returns error status but still returns title
    local _domain
    _domain="$(printf "%s\\n" "${_url}" | awk -F[/:] '{print $4}')"
    if [[ -n "${_domain}" ]]
    then
      _title+=" (${_domain})"
    fi
  fi

  local _newline=$'\n'

  if [[ -n "${_title:-}" ]]
  then
    if _command_exists "w3m"
    then # convert html entities
      _title="$(
        printf "%s\n" "${_title}" | w3m -dump -T text/html -cols 1000
      )"
    fi

    _bookmark_content="# ${_title}${_newline}"
  fi

  _bookmark_content+="${_newline}<${_url}>${_newline}"

  if [[ -n "${_comment}" ]]
  then
    _bookmark_content+="${_newline}## Comment${_newline}"
    _bookmark_content+="${_newline}${_comment}${_newline}"
  fi

  if [[ -n "${_tag_list}" ]]
  then
    local _tags=()
    local _tag_string=

    IFS=',' read -ra _tags <<< "${_tag_list}"
    for __tag in "${_tags[@]:-}"
    do
      local _normalized_tag
      _normalized_tag="$(printf "%s\n" "${__tag}" | tr -d '#')"

      if [[ -z "${_tag_string}" ]]
      then
        _tag_string+="#${_normalized_tag}"
      else
        _tag_string+=" #${_normalized_tag}"
      fi
    done

    _bookmark_content+="${_newline}## Tags${_newline}"
    _bookmark_content+="${_newline}${_tag_string}${_newline}"
  fi

  if ! ((_skip_content))
  then
    _bookmark_content+="${_newline}## Content${_newline}"
    if _command_exists "pandoc"
    then
      local _processed_content
      _processed_content="$(
        printf "%s\\n" "${_page_content}" \
          | pandoc \
            --from html-native_divs-native_spans \
            --to markdown-grid_tables --wrap=none
        )"
      _bookmark_content+="${_newline}${_processed_content}${_newline}"
    else
      _bookmark_content+="${_newline}${_page_content}${_newline}"
    fi
  fi

  if [[ -n "${_bookmark_content}" ]]
  then
    local _add_options=()

    ((_encrypt))              && _add_options+=("--encrypt")
    ((_edit_before_save))     && _add_options+=("--edit")
    [[ -n "${_password:-}" ]] && _add_options+=("--password" "${_password}")

    _debug printf "_bookmark() \${_add_options[*]}}: '%s'\\n" "${_add_options[*]}"

    if [[ -n "${_add_options[*]}" ]]
    then
      printf "%s" "${_bookmark_content}" \
        | _add "${_basename}" "${_add_options[@]}"
    else
      printf "%s" "${_bookmark_content}" | _add "${_basename}"
    fi
  fi
}
desc "b" "$(_help 'bookmark')"
_b() { _bookmark "${@}"; }

# commands ####################################################################

desc "commands" <<HEREDOC
Usage:
  ${_ME} commands

Description:
  List available commands.
HEREDOC
_commands() {
  printf "%s\\n" "${_SUBCOMMANDS[*]}"
}

# count #######################################################################

desc "count" <<HEREDOC
Usage:
  ${_ME} count

Description:
  Print the number of notes files in the current notebook.
HEREDOC
_count() {
  _list_notes_files | wc -l
}

# delete ######################################################################

desc "delete" <<HEREDOC
Usage:
  ${_ME} delete (<id> | <filename> | <path> | <title>) [-f | --force]

Options:
  -f --force  Skip the confirmation prompt.

Description:
  Delete a note.

Examples:
  ${_ME} delete 3
  ${_ME} delete example.md
  ${_ME} delete 'A Document Title'

Shortcut Alias: \`d\`
HEREDOC
_delete() {
  local _basename=
  local _force=0
  local _note_info_line
  local _selection=
  local _title

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_delete() \${_selection}: '%s'\\n" "${_selection}"
  if [[ -z "${_selection:-}" ]]
  then
    _help "delete"
    return 1
  fi

  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_delete() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    printf "Note not found: '%s'.\\n" "${_selection}"
    return 1
  fi

  _set_selection_notebook "${_selection}"

  if [[ -z "${_basename}" ]]
  then
    _help "delete"
    return 1
  fi
  _debug printf "_delete() \${_basename}: '%s'\\n" "${_basename}"

  local _id
  _id="$(_index get_id "${_basename}")"

  local _scoped_basename="${_basename}"

  if ((_SCOPED))
  then
    _id="${_SCOPE}:${_id}"
    _scoped_basename="${_SCOPE}:${_basename}"
  fi

  _title="$(_get_title "${NOTES_DATA_DIR}/${_basename}")"
  if [[ -n "${_title}" ]]
  then
    _note_info_line="[${_id}] ${_scoped_basename} '${_title}'"
  else
    _note_info_line="[${_id}] ${_scoped_basename}"
  fi

  if ! ((_force))
  then
    printf "Deleting %s\\n" "${_note_info_line}"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    cd "${NOTES_DATA_DIR}" || _die printf "_delete() \`cd\` failed.\\n"
    git rm "${_basename}" 1>/dev/null

    if [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]]
    then
      _index delete "${_basename}"
      _git_checkpoint "[NOTES] Delete: ${_basename}"
      printf "Deleted %s\\n" "${_note_info_line}"
    fi
  else
    printf "Selection not found.\\n"
    return 1
  fi
}
desc "d" "$(_help 'delete')"
_d() { _delete "${@}"; }

# edit ########################################################################

desc "edit" <<HEREDOC
Usage:
  ${_ME} edit (<id> | <filename> | <path> | <title>)

Description:
  Open the specified note in \`\$EDITOR\`, currently set to '${EDITOR}'. Any
  data piped to \`notes edit\` will be appended to the file.

  Non-text files will be opened in your system's preferred app or program for
  that file type.

Examples:
  ${_ME} edit 3
  ${_ME} edit example.md
  ${_ME} edit 'A Document Title'
  echo "Content to append." | ${_ME} edit 1

Shortcut Alias: \`e\`
HEREDOC
_edit() {
  local _basename=
  local _password=
  local _selection="${1:-}"

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --password)
        if __option_value_is_present "${_val:-}"
        then
          _password="${_val:-}"
          shift
        else
          _help edit
          return 1
        fi
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${_arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "_edit() \${_selection}: %s\\n" "${_selection}"
  if [[ -z "${_selection:-}" ]]
  then
    _help "edit"
    return 1
  fi

  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_edit() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    printf "Note not found: '%s'.\\n" "${_selection}"
    return 1
  fi

  _set_selection_notebook "${_selection}"

  if [[ -n "${_basename}" ]] || [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # _basename is assigned and a note exists with that name.
    local _target_file="${NOTES_DATA_DIR}/${_basename}"

    local _before
    _before="$(_get_hash "${NOTES_DATA_DIR}/${_basename}")"

    if _file_is_encrypted "${_target_file}"
    then
      local _encrypted_path
      _encrypted_path="${_target_file}"

      if [[ -z "${_password}" ]]
      then
        # Request password without displaying it
        printf "Password: "
        read -r -s _password </dev/tty
        printf "\\n" # print newline to stop `read`.
      fi

      local _decrypted_path
      _decrypted_path="$(_decrypt_file "${_target_file}" "${_password}")"

      _target_file="${_decrypted_path}"
    fi

    if _interactive_input
    then # terminal input.
      if [[ -z "${_content:-}" ]]
      then
        _edit_file "${_target_file}"
      fi
    else # piped input.
      cat >> "${_target_file}"
    fi

    if [[ -n "${_encrypted_path:-}" ]] && [[ -e "${_decrypted_path}" ]]
    then
      local _temp_encrypted_path="${_decrypted_path}.tmp"
      mv "${_encrypted_path}" "${_temp_encrypted_path}"
      _encrypt_file "${_decrypted_path}" "${_encrypted_path}" "${_password}"
      rm "${_temp_encrypted_path}" && rm "${_decrypted_path}"
    fi

    _git_checkpoint "[NOTES] Edit: ${_basename}"

    _after="$(_get_hash "${NOTES_DATA_DIR}/${_basename}")"
    _debug printf "_edit() \${_before}: %s\\n" "${_before}"
    _debug printf "_edit() \${_after}: %s\\n" "${_after}"

    if [[ "${_before}" != "${_after}" ]]
    then
      local _id
      _id="$(_index get_id "${_basename}")"

      local _scoped_basename="${_basename}"

      if ((_SCOPED))
      then
        _id="${_SCOPE}:${_id}"
        _scoped_basename="${_SCOPE}:${_basename}"
      fi

      local _title
      _title="$(_get_title "${NOTES_DATA_DIR}/${_basename}")"
      if [[ -n "${_title}" ]]
      then
        printf "Updated [%s] %s '%s'\\n" \
          "${_id}" \
          "${_scoped_basename}" \
          "${_title}"
      else
        printf "Updated [%s] %s\\n" \
          "${_id}" \
          "${_scoped_basename}"
      fi
    fi
  else
    printf "Selection not found.\\n"
    return 1
  fi
}
desc "e" "$(_help 'edit')"
_e() { _edit "${@}"; }

# env #########################################################################

desc "env" <<HEREDOC
Usage:
  ${_ME} env

Description:
  Print program environment variables.
HEREDOC
_env() {
  printf "EDITOR=%s\\n" "${EDITOR}"
  printf "NOTES_AUTO_SYNC=%s\\n" "${NOTES_AUTO_SYNC}"
  printf "NOTES_DIR=%s\\n" "${NOTES_DIR}"
  printf "NOTES_DATA_DIR=%s\\n" "${NOTES_DATA_DIR}"
  printf "NOTES_DEFAULT_EXTENSION=%s\\n" "${NOTES_DEFAULT_EXTENSION}"
  printf "NOTES_ENCRYPTION_TOOL=%s\\n" "${NOTES_ENCRYPTION_TOOL}"
  printf "NOTES_HIGHLIGHT_COLOR=%s\\n" "${NOTES_HIGHLIGHT_COLOR}"
  printf "NOTESRC_PATH=%s\\n" "${NOTESRC_PATH}"
}

# export ######################################################################

desc "export" <<HEREDOC
Usage:
  ${_ME} export (<id> | <filename> | <path> | <title>) <path> [-f | --force]
               [<pandoc options>...]
  ${_ME} export pandoc (<id> | <filename> | <path> | <title>)
               [<pandoc options>...]

Options:
  -f --force  Skip the confirmation prompt when overwriting an existing file.

Subcommands:
  (default)   Export a file to <path>. If <path> has a different extension
              than the source note, convert the note using \`pandoc\`.
  pandoc      Export the file to standard output or a file using \`pandoc\`.
              \`export pandoc\` prints to standard output by default.

Description:
  Export a file from the notebook.

  If Pandoc [1] is available, convert the note from its current format
  to the format of the output file as indicated by the file extension
  in <path>. Any additional arguments are passed directly to Pandoc.
  See the Pandoc help information for available options.

    1. http://pandoc.org/

Examples:
  # Export an Emacs Org mode note
  ${_ME} export example.org /path/to/example.org

  # Export a Markdown note to HTML and print to standard output
  ${_ME} export pandoc example.md --from=markdown_strict --to=html

  # Export a Markdown note to a .docx Microsoft Office Word document
  ${_ME} export example.md /path/to/example.docx
HEREDOC
_export() {
  local _args=()
  local _force=0
  local _pandoc_only=0
  local _selection=
  local _target_path=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      pandoc)
        _pandoc_only=1
        ;;
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${__arg}"
        elif ! ((_pandoc_only)) && [[ -z "${_target_path:-}" ]]
        then
          _target_path="${__arg}"
        else
          _args+=("${__arg}")
        fi
        ;;
    esac
  done

  if [[ -z "${_selection:-}" ]]
  then
    _help "export"
    return 1
  fi
  _debug printf "_export() \${_selection}: %s\\n" "${_selection}"

  local _basename
  _basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"

  if [[ -z "${_basename:-}" ]] || [[ ! -e "${NOTES_DATA_DIR}/${_basename:-}" ]]
  then
    printf "Note not found: '%s'.\\n" "${_selection}"
    return 1
  fi
  _debug printf "_export() \${_basename}: %s\\n" "${_basename}"

  if ((_pandoc_only))
  then
    if _command_exists 'pandoc'
    then
      if [[ -n "${_args[*]:-}" ]]
      then
        pandoc "${NOTES_DATA_DIR}/${_basename}" "${_args[@]:-}"
      else
        pandoc "${NOTES_DATA_DIR}/${_basename}"
      fi
    else
      printf "Pandoc required. http://pandoc.org/\n"
      return 1
    fi
  else
    if [[ -z "${_target_path:-}" ]]
    then
      _help "export"
      return 1
    fi
    _debug printf "_export() \${target_path}: %s\\n" "${_target_path}"

    if [[ -e "${_target_path:-}" ]]
    then
      if ! ((_force))
      then
        printf "File exists at '%s'\\n"  \
          "${_target_path}"
        while true
        do
          read -r -p "Overwrite existing file? [y/N] " __yn
          case ${__yn} in
            [Yy]*)
              break
              ;;
            *)
              printf "Exiting...\\n"
              exit 0
              ;;
          esac
        done
      fi
    fi

    _source_file_type="${_basename##*.}"
    _target_file_type="${_target_path##*.}"

    if _command_exists 'pandoc' &&
       [[ "${_source_file_type}" != "${_target_file_type}" ]]
    then
      _debug printf "_export() \${_args}: %s\\n" "${_args[*]:-}"
      if [[ -n "${_args[*]:-}" ]]
      then
        pandoc \
          -o "${_target_path}" \
          --standalone \
          "${NOTES_DATA_DIR}/${_basename}" \
          "${_args[@]:-}"
      else
        pandoc \
          -o "${_target_path}" \
          --standalone \
          "${NOTES_DATA_DIR}/${_basename}"
      fi
    else
      cp "${NOTES_DATA_DIR}/${_basename}" "${_target_path}"
    fi &&
      printf "Exported '%s' to '%s'\n" "${_selection}" "${_target_path}"
  fi
}

# git #########################################################################

desc "git" <<HEREDOC
Usage:
  ${_ME} git <git options>...

Description:
  Alias for \`git\` within the current notebook.
HEREDOC
_git() {
  cd "${NOTES_DATA_DIR}" || _die printf "_git() \`cd\` failed.\\n"
  git "${@}"
}

# history #####################################################################

desc "history" <<HEREDOC
Usage:
  ${_ME} history [<id> | <filename> | <path> | <title>]

Description:
  Display notebook history using \`tig\` [1] (if available) or \`git log\`.
  When a note is specified, the history for that note is displayed.

    1. https://github.com/jonas/tig

Examples:
  ${_ME} history
  ${_ME} history example.md
HEREDOC
_history() {
  cd "${NOTES_DATA_DIR}" || _die printf "_history() \`cd\` failed.\\n"

  local _log_command="git log"
  if _command_exists "tig"
  then # tig <https://github.com/jonas/tig> is present.
    _log_command="tig --all"
  fi

  local _selection="${1:-}"
  _debug printf "_history() \${_selection}: '%s'\\n" "${_selection}"

  local _basename=
  _basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"
  _debug printf "_history() \${_basename}: '%s'\\n" "${_basename}"

  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    eval "${_log_command} -- ${_basename}"
  else
    eval "${_log_command}"
  fi
}

# import ######################################################################

desc "import" <<HEREDOC
Usage:
  ${_ME} import (<path> | <url>)
  ${_ME} import copy <path>
  ${_ME} import download <url> [--convert]
  ${_ME} import move <path>

Options:
  --convert    Convert HTML content to Markdown.

Subcommands:
  (default) Copy or download the file in <path> or <url>.
  copy      Copy the file at <path> into the current notebook.
  download  Download the file at <url> into the current notebook.
  move      Copy the file at <path> into the current notebook.

Description:
  Copy, move, or download a file into the current notebook.

Examples:
  ${_ME} import ~/Pictures/example.png
  ${_ME} import ~/Documents/example.docx
  ${_ME} import https://example.com/example.pdf
HEREDOC
_import() {
  # _import_validate_path()
  #
  # Usage:
  #   _import_validate_path <path>
  _import_validate_path() {
    if [[ -z "${1:-}" ]]
    then
      _help import
      return 1
    elif [[ ! -e "${1:-}" ]]
    then
      printf "File not found: %s\n" "${1:-}"
      return 1
    fi
  }

  # _import_get_valid_basename()
  #
  # Usage:
  #   _import_get_valid_basename <basename>
  _import_get_valid_basename() {
    local _target_basename="${1:-}"
    if [[ -e "${NOTES_DATA_DIR}/${_target_basename}" ]]
    then
      _target_basename="$(_get_unique_basename "${_target_basename}")"
    fi
    printf "%s\n" "${_target_basename}"
  }

  local _basename=
  local _convert=0
  local _path=
  local _subcommand=
  local _url=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      copy|download|move)
        _subcommand="${__arg}"
        ;;
      --convert)
        _convert=1
        ;;
      *)
        if [[ -n "${_subcommand:-}" ]]
        then
          if [[ "${_subcommand}" == "download" ]]
          then
            _url="${__arg:-}"
          else
            _path="${__arg:-}"
          fi
        else
          if [[ "${__arg:-}" =~ ^http\:|^file\: ]]
          then
            _subcommand="download"
            _url="${__arg:-}"
          else
            _subcommand="copy"
            _path="${__arg:-}"
          fi
        fi
        ;;
    esac
  done

  case "${_subcommand}" in
    copy)
      _import_validate_path "${_path:-}"

      _basename="$(basename -- "${_path}")"
      _basename="$(_import_get_valid_basename "${_basename}")"

      cp "${_path}" "${NOTES_DATA_DIR}/${_basename}" &&
        _index add "${_basename}" &&
        _git_checkpoint "[NOTES] Import: ${_basename}"
      printf "Imported '%s' to '%s'\n" "${_path}" "${_basename}"
      ;;
    download)
      _basename="$(basename -- "${_url}" | tr -d '[:space:]')"
      if [[ "${_url}" =~ \/$ ]]
      then
        _basename="${_basename}.html"
      fi
      _basename="$(_import_get_valid_basename "${_basename}")"

      if ((_convert))
      then
        curl -s "${_url}" | pandoc \
          --from html --to markdown \
          -o "${NOTES_DATA_DIR}/${_basename}"
      else
        curl "${_url}" -o "${NOTES_DATA_DIR}/${_basename}"
      fi &&
        _index add "${_basename}" &&
        _git_checkpoint "\
[NOTES] Import: ${_basename}

Source:
${_url}
"
      printf "Imported '%s' to '%s'\n" "${_url}" "${_basename}"
      ;;
    move)
      _import_validate_path "${_path:-}"
      _basename="$(basename -- "${_path}")"
      _basename="$(_import_get_valid_basename "${_basename}")"

      mv "${_path}" "${NOTES_DATA_DIR}/${_basename}" &&
        _index add "${_basename}" &&
        _git_checkpoint "[NOTES] Import: ${_basename}"
      printf "Imported '%s' to '%s'\n" "${_path}" "${_basename}"
      ;;
    *)
      _help import
      return 1
      ;;
  esac
}

# index #######################################################################

desc "index" <<HEREDOC
Usage:
  ${_ME} index add <filename>
  ${_ME} index delete <filename>
  ${_ME} index get_basename <id>
  ${_ME} index get_id <filename>
  ${_ME} index get_max_id
  ${_ME} index rebuild
  ${_ME} index reconcile
  ${_ME} index show
  ${_ME} index update <existing-filename> <new-filename>
  ${_ME} index verfiy

Subcommands:
  add           Add <filename> to the index.
  delete        Delete <filename> from the index.
  get_basename  Print the filename / basename at the specified <id>.
  get_id        Get the id for <filename>.
  get_max_id    Get the maximum id for the notebook.
  rebuild       Rebuild the index. Some ids might change.
  reconcile     Remove duplicates and update index for added and deleted files.
  show          Print the index.
  update        Overwrite the <existing-filename> entry with <new-filename>.
  verify        Verify that the index matches the notebook contents.

Description:
  Manage the index for the current notebook. This subcommand is used
  internally by \`notes\` and using it manually will probably mess up
  the index. If something goes wrong with the index, fix it with
  \`notes index reconcile\`.

  The index is a text file named '.index' in the notebook directory containing
  a list of filenames, and the line number of each filename represents the id.
  .index is included in the git repository so ids are preserved across systems.
HEREDOC
_index() {
  local _subcommand="${1:-}"
  local _index_path="${NOTES_DATA_DIR}/.index"

  if [[ ! -e "${_index_path}" ]] &&
     [[ ! "${_subcommand}" == "rebuild" ]]
  then
    _index rebuild
  fi

  case "${_subcommand}" in
    add)
      local _basename="${2:-}"
      if [[ -z "${_basename}" ]]
      then
        _help index
        return 1
      fi
      if [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]]
      then
        printf "File not found: %s\n" "${_basename}"
        return 1
      fi

      if ! grep -q "^${_basename}$" "${_index_path}"
      then
        _debug printf "_index() add \$_basename: %s\n" "${_basename}"
        printf "%s\n" "${_basename}" >> "${_index_path}"
      fi
      ;;
    delete)
      local _basename="${2:-}"
      _debug printf "_index() delete \${_basename}: '%s'\n" "${_basename}"

      if [[ -z "${_basename}" ]]
      then
        _help index
        return 1
      fi

      if grep -q "^${_basename}$" "${_index_path}"
      then
        "${_SED_I_COMMAND[@]}" -e "s/^${_basename}$//g" "${_index_path}"
      else
        return 1
      fi
      ;;
    get_basename)
      # Usage: _index_get_basename <id> <index path>
      _index_get_basename() {
        sed "${1:-}q;d" "${2:-}"
      }

      local _id_number="${2:-}"
      if [[ -z "${_id_number}" ]]
      then
        _help index
        return 1
      fi

      local _basename
      _basename="$(_index_get_basename "${_id_number}" "${_index_path}")"

      if [[ -z "${_basename}" ]]
      then
        _index reconcile &&
          _basename="$(_index_get_basename "${_id_number}" "${_index_path}")"
      fi

      if [[ -z "${_basename}" ]]
      then
        return 1
      else
        printf "%s\n" "${_basename}"
      fi
      ;;
    get_id)
      # Usage: _index_get_id <basename> <index path>
      _index_get_id() {
        grep -n "^${1:-}$" "${2:-}" | cut -f1 -d:
      }

      local _basename="${2:-}"
      if [[ -z "${_basename}" ]]
      then
        _help index
        return 1
      fi

      local _id
      _id="$(_index_get_id "${_basename}" "${_index_path}")"

      if [[ -z "${_id}" ]]
      then
        _index reconcile &&
          _id="$(_index_get_id "${_basename}" "${_index_path}")"
      fi

      if [[ -z "${_id}" ]]
      then
        return 1
      else
        printf "%s\n" "${_id}"
      fi
      ;;
    get_max_id)
      wc -l < "${_index_path}" | tr -d '[:space:]'
      ;;
    rebuild)
      _debug printf "_index() rebuild\n"
      _debug printf \
        "_index() rebuild: \`ls \${NOTES_DATA_DIR}\`: '%s'\n" \
        "$(ls "${NOTES_DATA_DIR}")"
      ls "${NOTES_DATA_DIR}" > "${_index_path}" &&
        _git_checkpoint "[NOTES] Rebuild Index"
      ;;
    reconcile)
      _index_reconcile_remove_duplicates() {
        local _reconcle_index_path="${1:-}"
        [[ -z "${_reconcle_index_path:-}" ]] && return 1

        local _tmp_file
        _tmp_file="$(mktemp)"
        exec 3> "${_tmp_file}"
        exec 4< "${_tmp_file}"
        rm "${_tmp_file}"

        # Remove duplicates
        awk '!seen[$0]++' "${_reconcle_index_path}" >&3
        cat <&4 > "${_reconcle_index_path}"

        exec 3>&-
        exec 4<&-
      }

      local _index_list
      _index_list=($(<"${_index_path}"))

      local _file_list
      _file_list=($(ls "${NOTES_DATA_DIR}"))

      _index_reconcile_remove_duplicates "${_index_path}"

      _debug printf \
        "_index() reconcile: \`\${_index_list[*]}\`: '%s'\n" \
        "${_index_list[*]:-}"
      _debug printf \
        "_index() reconcile: \`\${_file_list[*]}\`: '%s'\n" \
        "${_file_list[*]:-}"

      for __item in "${_index_list[@]:-}"
      do
        if [[ -n "${__item}" ]]
        then
          _contains "${__item}" "${_file_list[*]:-}" ||
            _index delete "${__item}"
        fi
      done

      for __item in "${_file_list[@]:-}"
      do
        if [[ -n "${__item}" ]]
        then
          _contains "${__item}" "${_index_list[*]:-}" ||
            _index add "${__item}"
        fi
      done
      ;;
    show)
      cat "${_index_path}"
      ;;
    update)
      local _old_basename="${2:-}"
      local _new_basename="${3:-}"
      if [[ -z "${_old_basename}" ]] || [[ -z "${_new_basename}" ]]
      then
        _help index
        return 1
      fi

      if grep -q "^${_old_basename}$" "${_index_path}"
      then
        "${_SED_I_COMMAND[@]}" \
          -e "s/^${_old_basename}$/${_new_basename}/g" "${_index_path}"
      else
        return 1
      fi
      ;;
    verify)
      local _index_list
      _index_list=($(<"${_index_path}"))
      local _file_list
      _file_list=($(ls "${NOTES_DATA_DIR}"))
      local _errors=0

      for __item in "${_index_list[@]:-}"
      do
        _contains "${__item}" "${_file_list[*]:-}" || _errors=1
      done
      for __item in "${_file_list[@]:-}"
      do
        _contains "${__item}" "${_index_list[*]:-}" || _errors=1
      done

      if ((_errors))
      then
        printf "Index corrupted. To fix, run:\n  %s index reconcile\n" \
          "${_ME}"
        return 1
      fi
      ;;
    *)
      :
      ;;
  esac
}

# init ########################################################################

desc "init" <<HEREDOC
Usage:
  ${_ME} init [<remote-url>]

Description:
  Initialize the local data directory and generate a ~/.notesrc configuration
  file if it doesn't exist.

Examples:
  ${_ME} init
  ${_ME} init https://github.com/example/example.git
HEREDOC
_init() {
  if [[ -e "${NOTES_DIR}" ]] && [[ ! -d "${NOTES_DIR}" ]]
  then
    printf "\`init\`: %s already exists and is not a directory.\\n" \
      "${NOTES_DIR}"
    return 1
  elif [[ -e "${NOTES_DATA_DIR}" ]]
  then
    printf "\`init\`: %s already exists.\\n" \
      "${NOTES_DATA_DIR}"
    return 1
  fi

  cat <<HEREDOC
Welcome to
             _
 _ __   ___ | |_ ___  ___
| '_ \ / _ \| __/ _ \/ __|
| | | | (_) | ||  __/\__ \\
|_| |_|\___/ \__\___||___/

Initializing...
HEREDOC
  if [[ ! -e "${NOTES_DIR}" ]]
  then
    mkdir -p "${NOTES_DIR}"
    printf "Created %s\\n" "${NOTES_DIR}"
  fi

  if [[ ! -e "${NOTESRC_PATH}" ]]
  then
    cat <<HEREDOC > "${NOTESRC_PATH}"
###############################################################################
# .notesrc
#
# Configuration file for \`notes\`, a command line note-taking and document
# management tool with encryption, advanced search, Git-backed syncing, and
# more in a single portable script.
#
# https://github.com/xwmx/notes
###############################################################################

# \$EDITOR
#
# Default: inherits the global \`\$EDITOR\` value.
#
# Reassign \`\$EDITOR\` to use a specific editor with notes, overriding the
# global \`\$EDITOR\` setting.
#
# Example Values: 'vim' 'emacs' 'subl' 'atom' 'code' 'macdown'
# export EDITOR="code"

# \$NOTES_AUTO_SYNC
#
# Default: 1
#
# By default, operations that trigger a git commit like \`add\`, \`edit\`,
# and \`delete\` will sync notebook changes to the remote repository, if
# one is set.
#
# To disable this behavior, uncomment the following line.
# export NOTES_AUTO_SYNC=0

# \$NOTES_DEFAULT_EXTENSION
#
# Default: 'md'
#
# The default extension to use for notes files. Change to 'org' for Emacs Org
# mode files, 'rst' for reStructuredText, 'txt' for plain text, or whatever
# you prefer.

# Example Values: 'md' 'org' 'txt' 'rst'
# export NOTES_DEFAULT_EXTENSION="org"

# \$NOTES_DIR
#
# Default: "\$HOME/.notes"
#
# The location of the directory that contains the notebooks.
# export NOTES_DIR="\$HOME/.notes"

# \$NOTES_ENCRYPTION_TOOL
#
# Default: 'openssl'
#
# The tool used for encrypting notes.
#
# Supported Values: 'openssl' 'gpg'
# export NOTES_ENCRYPTION_TOOL="gpg"

# \$NOTES_HIGHLIGHT_COLOR
#
# Default: 11 (yellow) for 256 color terminals, 3 (yellow) for 8 color.
#
# Set highlighting color. This should be set to an xterm color number between
# 0 and 255. To display a table of available colors by number, run:
#
#   notes settings colors
#
# Supported Values: [0..255]
# export NOTES_HIGHLIGHT_COLOR=213
HEREDOC
    printf "Created %s\\n" "${NOTESRC_PATH}"
  fi

  local _repo_url="${1:-}"
  if [[ -n "${_repo_url}" ]]
  then
    git clone "${_repo_url}" "${NOTES_DATA_DIR}"
  else
    mkdir -p "${NOTES_DATA_DIR}"
    cd "${NOTES_DATA_DIR}" &&
      git init 1>/dev/null &&
      touch "${NOTES_DATA_DIR}/.index" &&
      _git_checkpoint "[NOTES] Initialize"
  fi
  printf "home\\n" > "${NOTES_DIR}/.current"

  printf "Created 'home' notebook\\n"
}

# list ########################################################################

desc "list" <<HEREDOC
Usage:
  ${_ME} list [-e [<length>] | --excerpt [<length>]] [--no-id]
             [-n <limit> | --<limit>] [-s | --sort] [-r | --reverse]
             [--titles] [<id> | <filename> | <path> | <title> | <query>]

Options:
  -e --excerpt <length>  Print an excerpt <length> lines long under each
                         note's filename [default: 3].
  --no-id                Don't print the id next to each note's filename.
  -n           <limit>   The maximum number of notes to list.
  --<limit>              Shortcut for \`-n <limit>\`.
  -s --sort              Order notes by id.
  -r --reverse           Order notes by id descending.
  --titles               Show title instead of filename when present.

Description:
  List notes in the current notebook.

  When <id>, <filename>, <path>, or <title> are present, the listing for the
  matching note will be displayed. When no match is found, titles and
  filenames will be searched for any that match <query> as a case-insensitive
  regular expression.

Examples:
  ${_ME} list
  ${_ME} list example.md -e 10
  ${_ME} list --excerpt --no-id
  ${_ME} list --titles --reverse
  ${_ME} list '^Example.*'
  ${_ME} list --10
HEREDOC
_list() {
  _debug printf "_list() \${1:-}: '%s'\\n" "${1:-}"
  _debug printf "_list() \${2:-}: '%s'\\n" "${2:-}"
  _debug printf "_list() \${3:-}: '%s'\\n" "${3:-}"

  local _excerpt_length=3
  local _print_excerpt=0
  local _limit=
  local _list_titles=0
  local _no_color=0
  local _no_id=0
  local _reverse=0
  local _selection
  local _sort=0

  _debug printf "_list() \${@:-}: '%s'\\n" "${@:-}"

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      -e|--excerpt)
        _print_excerpt=1
        if __option_value_is_present "${_val:-}"
        then
          _excerpt_length="${_val:-}"
          shift
        fi
        ;;
      --no-id|--noid|--noindex|--no-index)
        _no_id=1
        ;;
      --nocolor|--no-color)
        _no_color=1
        ;;
      -n)
        if __option_value_is_present "${_val:-}"
        then
          _limit="${_val:-}"
          shift
        fi
        ;;
      --titles)
        _list_titles=1
        ;;
      -s|--sort)
        _sort=1
        ;;
      -r|--reverse)
        _reverse=1
        ;;
      *)
        _debug printf "_list() *: '%s'\\n" "${_arg:-}"
        if [[ "${_arg:-}" =~ ^--[0-9]+$ ]] && [[ -z "${_limit}" ]]
        then
          _limit="${_arg:-}"
        else
          _selection="${_arg:-}"
        fi
        ;;
    esac
    shift
  done

  _debug printf "_list() \${_limit}: '%s'\\n" "${_limit:-}"
  _debug printf "_list() \${_print_excerpt}: '%s'\\n" "${_print_excerpt:-}"
  _debug printf "_list() \${_excerpt_length}: '%s'\\n" "${_excerpt_length:-}"
  _debug printf "_list() \${_selection}: '%s'\\n" "${_selection:-}"
  _debug printf "_list() \${_sort}: '%s'\\n" "${_sort:-}"

  local _selection_basename=
  if [[ -n "${_selection:-}" ]]
  then
    _selection_basename="$(_get_selection_basename "${_selection}")"
    _set_selection_notebook "${_selection}"
  fi
  _debug printf "list() \${_selection_basename}: '%s'\\n" "${_selection_basename}"

  local _filenames=()
  if ((_reverse))
  then
    _filenames=($(_list_notes_files --sort --reverse))
  elif ((_sort))
  then
    _filenames=($(_list_notes_files --sort))
  else
    _filenames=($(_list_notes_files))
  fi
  local _filenames_count="${#_filenames[@]}"

  _debug printf "list() \${_filenames_count}: '%s'\\n" "${_filenames_count[@]}"

  if [[ "${_filenames_count}" -eq 0 ]]
  then # no files in `$NOTES_DATA_DIR`
    cat <<HEREDOC
0 notes.

Add a note:
  ${_ME} add
Usage information:
  ${_ME} help
HEREDOC
    return 1
  else
    local _counter=0
    local _max_id
    _max_id="$(_index get_max_id)"
    local _maybe_title=

    for __basename in "${_filenames[@]}"
    do
      _debug printf "list() \${__basename}: '%s'\\n" "${__basename}"
      if [[ -n "${_selection:-}" ]]
      then
        # If a valid <selection> has been specified, skip the rest of the loop
        # unless the <selection> basename matches the current one.
        if [[ -n "${_selection_basename}" ]]
        then
          if [[ "${__basename}" != "${_selection_basename}" ]]
          then
            continue
          fi
        else

          # Turn on a case-insensitive matching (-s set nocasematch)
          shopt -s nocasematch

          if [[ "${__basename:-}" =~ ${_selection} ]]
          then
            : # include the note in the list
          else
            _maybe_title="$(_get_title "${NOTES_DATA_DIR}/${__basename}")"
            if [[ "${_maybe_title:-}" =~ ${_selection} ]]
            then
              : # include the note in the list
            else
              continue # don't include not in list
            fi
          fi

          # Turn off a case-insensitive matching (-u unset nocasematch)
          shopt -u nocasematch
        fi
      fi

      if [[ -n "${_limit:-}" ]] && [[ "${_counter}" -eq "${_limit}" ]]
      then # the limit has been reached.

        _debug printf "list() \${#_limit}: '%s'\\n" "${#_limit}"
        _debug printf "list() \${#_counter}: '%s'\\n" "${#_counter}"

        local _difference
        _difference=$((_filenames_count-_counter))
        printf "%s omitted. %s total.\\n" "${_difference}" "${_filenames_count}"
        break
      fi

      # NOTE: Plain version serves as the reference version and can be used
      # for length calculations.
      local _item_id_number
      _item_id_number="$(_index get_id "${__basename}")"

      local _id_item
      _id_item="[${_item_id_number}]"

      local _id_item_color
      _id_item_color="[$(_highlight "${_item_id_number}")]"

      local _list_item_id="${__basename}"
      if ((_list_titles))
      then
        _maybe_title="$(_get_title "${NOTES_DATA_DIR}/${__basename}")"
        if [[ -n "${_maybe_title}" ]]
        then # note file has title.
          _list_item_id="${_maybe_title}"
        fi
      fi

      # Use calculated number of spaces for nicer formatting.
      local _spaces=''
      local _spaces_length=1
      _spaces_length=$(( ${#_max_id} + 3 - ${#_id_item} ))
      printf -v _spaces '%*s' "${_spaces_length}"

      local _list_item="${_id_item}${_spaces}${_list_item_id}"
      local _list_item_color="${_id_item_color}${_spaces}${_list_item_id}"

      if ((_no_id))
      then
        printf "%s" "${_list_item_id}"
      else
        if ((_no_color))
        then
          printf "%s" "${_list_item}"
        else
          printf "%s" "${_list_item_color}"
        fi
      fi

      if _file_is_bookmark "${NOTES_DATA_DIR}/${__basename}"
      then
        printf " ðŸ”–"
      fi

      # TODO: This is slow. Look for ways to speed up.
      if _file_is_encrypted "${NOTES_DATA_DIR}/${__basename}"
      then
        printf " ðŸ”’"
      fi

      # End of line.
      printf "\\n"

      if ((_print_excerpt)) &&
         [[ "${_excerpt_length}" =~ ^[1-9] ]] &&
         _file_is_text "${NOTES_DATA_DIR}/${__basename}"
      then # excerpt is specified with a non-zero digit, as required by `head`.
        _print_line "${_list_item}"
        head -"${_excerpt_length}" "${NOTES_DATA_DIR}/${__basename}"
        printf "\\n"
      fi

      _counter=$((_counter+1))
    done

    if ! ((_counter)) && [[ -n "${_selection:-}" ]]
    then
      printf "Note not found: '%s'.\\n" "${_selection}"
      printf "Help & Usage Info:\n"
      printf "  notes help\\n"
      return 1
    fi
  fi
}

# ls ##########################################################################

desc "ls" <<HEREDOC
Usage:
  ${_ME} ls [-e [<length>] | --excerpt [<length>]] [--no-id]
           [-n <limit> | --<limit>] [-s | --sort] [-r | --reverse]
           [<id> | <filename> | <path> | <title> | <query>]

Options:
  -e --excerpt <length>  Print an excerpt <length> lines long under each
                         note's filename [default: 3].
  --no-id                Don't print the id next to each note's filename.
  -n           <limit>   The maximum number of notes to list.
  --<limit>              Shortcut for \`-n <limit>\`.
  -s --sort              Order notes by id.
  -r --reverse           Order notes by id descending.

Description:
  List notebooks and notes in the current notebook, displaying note titles
  when available. \`notes ls\` is a combination of the \`notes notebooks\`
  and \`notes list --titles\` commands in one view.

  When <id>, <filename>, <path>, or <title> are present, the listing for the
  matching note will be displayed. When no match is found, titles and
  filenames will be searched for any that match <query> as a case-insensitive
  regular expression.

  Options are passed through to \`list\`. For more information, see
  \`notes help list\`.

Examples:
  ${_ME} ls
  ${_ME} ls example.md -e 10
  ${_ME} ls --excerpt --no-id
  ${_ME} ls --reverse
  ${_ME} list '^Example.*'
  ${_ME} list --10
HEREDOC
_ls() {
  _debug printf "_ls() \${@:-}: '%s'\\n" "${@:-}"

  local _args=()
  local _auto_align=1 # auto-align by default.
  local _centered=0
  local _justified=0
  local _plain=0

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --auto-align)
        _auto_align=1
        ;;
      --centered)
        _centered=1
        ;;
      --justified)
        _justified=1
        ;;
      --plain)
        _plain=1
        ;;
      *)
        _args+=("${__arg}")
        ;;
    esac
  done

  _debug printf "_ls() \${_args[*]}: '%s'\\n" "${_args[*]:-}"

  {
    if [[ -z "${_args[*]:-}" ]]
    then
      # Build word-wrapping notebook line. `fold` doesn't account for
      # highlighting.
      #
      # Naive version:
      #
      # _notebooks --names \
      #   | tr '\n' ' ' \
      #   | fold -s "-w$(tput cols)" \
      #   && printf "\n"

      # _print_paddding()
      #
      # Usage:
      #   _print_padding <line> <columns> <aligned>
      _print_padding() {
        local _padding_line="${1:-}"
        local _padding_line_length="${#_padding_line}"
        local _padding_columns="${2:-}"
        local _padding_centered="${3:-}"

        local _padding_amount=$(( (_padding_columns-_padding_line_length) / 2 ))
        if ((_padding_centered)) && ((_padding_amount))
        then
          printf "%-${_padding_amount}s" " "
        fi
      }

      local _separator=
      if ! ((_plain))
      then
        _separator=" Â·"
      fi

      local _columns
      _columns="$(tput cols)"

      local _notebook_names_raw
      _notebook_names_raw=($(_notebooks --names --no-color))
      local _notebooks_count="${#_notebook_names_raw[@]}"

      local _notebook_names_hi
      _notebook_names_hi=($(_notebooks --names))

      local _line_number=0
      local _padding=

      local _test_line=
      local _line_raw=
      local _line_hi=
      local _output_raw=
      local _output_hi=

      for ((i=0;i < "${_notebooks_count}"; i++))
      do
        if [[ -z "${_test_line}" ]]
        then # first item in line
          _test_line="${_notebook_names_raw[i]}"
        else
          _test_line="${_test_line}${_separator} ${_notebook_names_raw[i]}"
        fi

        if [[ "${#_test_line}" -gt "${_columns}" ]]
        then # wrap to next line
          # Use the existing value of $_line_[highlighted|raw] without the current
          # name.
          if ((_auto_align)) || ((_centered)) && ! ((_justified))
          then
            _centered=1
            _padding="$(
              _print_padding "${_line_raw}" "${_columns}" "${_centered}"
            )"
          fi

          _output_hi="${_output_hi}${_padding}${_line_hi}\n"
          _output_raw="${_output_raw}${_padding}${_line_raw}\n"
          _line_number=$((_line_number + 1))

          # Start the line for the next iteration using the current name..
          _test_line="${_notebook_names_raw[i]}"
          _line_hi="${_notebook_names_hi[i]:-}"
          _line_raw="${_notebook_names_raw[i]}"
        else # add to line
          if [[ -z "${_line_hi}" ]]
          then # first item in highlighted line
            _line_hi="${_notebook_names_hi[i]:-}"
            _line_raw="${_notebook_names_raw[i]}"
          else
            _line_hi="${_line_hi}${_separator} ${_notebook_names_hi[i]:-}"
            _line_raw="${_line_raw}${_separator} ${_notebook_names_raw[i]}"
          fi
        fi

        if [[ "${#_notebook_names_raw[@]}" == $((i+1)) ]]
        then # end of list
          if ((_line_number)) && ! ((_justified)) &&
             ((_auto_align)) || ((_centered))
          then
            _centered=1
          fi
          _padding="$(
            _print_padding "${_line_raw}" "${_columns}" "${_centered}"
          )"

          _output_hi="${_output_hi}${_padding}${_line_hi}\n"
          _output_raw="${_output_raw}${_padding}${_line_raw}\n"
          _line_number=$((_line_number + 1))
        fi
      done
      printf "%b" "${_output_hi}"

      # Use control characters to disable wrapping for long lines.
      # Source: http://superuser.com/a/189068
      printf '\033[?7l'
      if ((_centered))
      then # print full-width line.
        _print_line "$(printf "%-${_columns}s" '.')" | tr -d '\n'
      else # print line the length of the first line.
        _print_line "$(
          # $_output_raw generates a line 2 characters too long. TODO: Review
          printf "%s" "${_output_raw}" | sed 's/..$//'
        )" | tr -d '\n'
      fi
      printf '\033[?7h'
      printf '\n'
    fi

    _list --titles "${_args[@]:-}"
  } | if hash "less" 2>/dev/null      &&
         [[ "${PAGER:-}" == 'less' ]] ||
         [[ -z "${PAGER:-}" ]]
      then
        less -R -X -F
      else
        cat
      fi
}

# move ########################################################################

desc "move" <<HEREDOC
Usage:
  ${_ME} move (<id> | <filename> | <path> | <title>) [-f | --force] <notebook>

Options:
  -f --force  Skip the confirmation prompt.

Description:
  Move the specified note to <notebook>.

Examples:
  ${_ME} move 1 example-notebook
  ${_ME} move example.md example-notebook

Shortcut Alias: \`mv\`
HEREDOC
_move() {
  local _basename=
  local _force=0
  local _selection=
  local _source_info_line=
  local _target_notebook=
  local _title=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        elif [[ -z "${_target_notebook}" ]]
        then
          _target_notebook="${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_move() \${_selection}: '%s'\\n" "${_selection}"
  _debug printf "_move() \${_target_notebook}: '%s'\\n" "${_target_notebook}"
  if [[ -z "${_selection:-}" ]] || [[ -z "${_target_notebook:-}" ]]
  then
    _help "move"
    return 1
  fi

  if [[ "${_target_notebook}" =~ :$ ]]
  then
    _target_notebook="$(printf "%s\\n" "${_target_notebook}" | tr -d ':')"
  fi
  _debug printf "_move() \${_target_notebook}: '%s'\\n" "${_target_notebook}"

  _basename="$(_get_selection_basename "${_selection}")"

  _set_selection_notebook "${_selection}"

  if [[ -z "${_basename}" ]] ||
     [[ ! -e "${NOTES_DIR}/${_target_notebook}/.git" ]]
  then
    _help "move"
    return 1
  elif [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then
    printf "Not Found: %s:%s\\n" "${_SCOPE}" "${_basename}"
    return 1
  elif [[ -e "${NOTES_DIR}/${_target_notebook}/${_basename}" ]]
  then
    printf "Already exists: %s:%s\\n" "${_SCOPE}" "${_basename}"
    return 1
  fi

  _debug printf "_move() \${_basename}: '%s'\\n" "${_basename}"

  _title="$(_get_title "${NOTES_DATA_DIR}/${_basename}")"
  if [[ -n "${_title}" ]]
  then
    _source_info_line="${_SCOPE}:${_basename} '${_title}'"
  else
    _source_info_line="${_SCOPE}:${_basename}"
  fi

  if ! ((_force))
  then
    printf "Moving %s to '%s'\\n"  \
      "${_source_info_line}"    \
      "${_target_notebook}"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  cat "${NOTES_DATA_DIR}/${_basename}" \
    | "${_MY_PATH}" "${_target_notebook}:add" "${_basename}" 1> /dev/null

  "${_MY_PATH}" delete "${_SCOPE}:${_basename}" --force 1> /dev/null

  local _id
  _id="$(
    "${_MY_PATH}" "${_target_notebook}:index" get_id "${_basename}"
  )"

  if [[ ! -e "${NOTES_DATA_DIR}/${_basename}" ]] ||
     [[ -e "${NOTES_DIR}/${_target_notebook}/${_basename}" ]]
  then
    printf "Moved to [%s:%s] %s:%s\\n"  \
      "${_target_notebook}" \
      "${_id}" \
      "${_target_notebook}"        \
      "${_basename}"
  fi
}
desc "mv" "$(_help 'move')"
_mv()    { _move "${@}"; }

# notebook ####################################################################

desc "notebook" <<HEREDOC
Usage:
  ${_ME} notebook [open]

Subcommands:
  open  Open the notebook directory in your file browser, explorer, or finder.

Description:
  Print the current notebook name or open the directory in your file browser.

Shortcut Alias: \`nb\`
HEREDOC
_notebook() {
  if [[ "${1:-}" == "open" ]]
  then
    if _command_exists "xdg-open"
    then
      xdg-open "${NOTES_DATA_DIR}"
    elif _command_exists "open"
    then
      open "${NOTES_DATA_DIR}"
    else
      printf "notes doesn't know how to open directories on your system.\n"
      return 1
    fi
  else
    _notebooks current
  fi
}
desc "nb" "$(_help 'notebook')"
_nb()    { _notebook "${@}"; }

# notebooks ###################################################################

desc "notebooks" <<HEREDOC
Usage:
  ${_ME} notebooks [<name>] [--names] [--no-color]
  ${_ME} notebooks add <name> [<remote-url>]
  ${_ME} notebooks current
  ${_ME} notebooks rename <old-name> <new-name>
  ${_ME} notebooks use <name>

Subcommands:
  (default)  List notebooks.
  add        Create a new notebook.
  current    Print the current notebook name.
  rename     Rename a notebook.
  use        Switch to a notebook.

Description:
  Manage notebooks.

Examples:
  ${_ME} notebooks --names
  ${_ME} notebooks add Example1
  ${_ME} notebooks add Example2 https://github.com/example/example.git

Shortcut Alias: \`nbs\`
HEREDOC
_notebooks() {
  # _notebooks_add()
  #
  # Usage:
  #   _notebooks_add <name> [<remote_url>]
  _notebooks_add() {
    local _name="${1:-}"
    if [[ -z "${_name}" ]]
    then
      _help notebooks
      return 1
    fi

    if [[ -e "${NOTES_DIR}/${_name}" ]]
    then
      printf "Already exists: %s\\n" "${_name}"
      return 1
    fi

    local _repo_url="${2:-}"
    if [[ -n "${_repo_url}" ]]
    then
      git clone "${_repo_url}" "${NOTES_DIR}/${_name}"
      printf "%s\\n" "${_name}" > "${NOTES_DIR}/.current"
    else
      mkdir -p "${NOTES_DIR}/${_name}"
      cd "${NOTES_DIR}/${_name}" &&
        git init 1>/dev/null &&
        touch "${NOTES_DIR}/${_name}/.index" &&
        _git_checkpoint "[NOTES] Initialize" "${NOTES_DIR}/${_name}"
    fi
    printf "Added: %s\\n" "${_name}"
  }
  # _notebooks_list()
  #
  # Usage:
  #   _notebooks_list [<name>] [--names]
  _notebooks_list() {
    local _notebook_directories=()
    local _no_color=0
    local _only_names=0

    _debug printf "_notebooks_list() \${@:-}: '%s'\\n" "${@:-}"

    for __arg in "${@:-}"
    do
      case "${__arg}" in
        --names)
          _only_names=1
          ;;
        --nocolor|--no-color)
          _no_color=1
          ;;
        *)
          _notebook_directories+=("${__arg}")
          ;;
      esac
    done

    if [[ -z "${_notebook_directories[*]:-}" ]]
    then
      _notebook_directories=($(ls -1 "${NOTES_DIR}"))
    fi

    _debug printf \
      "_notebooks_list() \${_only_names:-}: '%s'\\n" \
      "${_only_names:-}"
    _debug printf \
      "_notebooks_list() \${_notebook_directories[*]}: '%s'\\n" \
      "${_notebook_directories[*]:-}"

    if ! ((_no_color))
    then
      local _current
      _current="$(_notebooks current)"
    fi

    for __item in "${_notebook_directories[@]}"
    do
      if [[ -e "${NOTES_DIR}/${__item}/.git" ]]
      then # it's a git repository.
        local _formatted_name
        local _origin_url

        if ! ((_no_color)) &&
           [[ -n "${_current}" ]] &&
           [[ "${_current}" == "${__item}" ]]
        then # it's the current repository.
          _formatted_name="$(_highlight "${__item}")"
        else
          _formatted_name="${__item}"
        fi

        local _origin_url
        if ! ((_only_names))
        then
          cd "${NOTES_DIR}/${__item}" ||
            _die printf "_notebooks() \`cd\` failed."
          _origin_url="$(git config --get remote.origin.url || echo '')"
        fi

        if [[ -n "${_origin_url:-}" ]]
        then
          printf "%s\\n" "${_formatted_name}	(${_origin_url})"
        else
          printf "%s\\n" "${_formatted_name}"
        fi
      fi
    done
  }
  # _notebooks_rename()
  #
  # Usage:
  #   _notebooks_rename <old> <new>
  _notebooks_rename() {
    local _old="${1:-}"
    local _new="${2:-}"

    if [[ -z "${_old}" ]] || [[ -z "${_new}" ]]
    then
      _help notebooks
      return 1
    elif [[ ! -d "${NOTES_DIR}/${_old}" ]]
    then
      printf "'%s' is not a valid notebook name.\\n" "${_old}"
      return 1
    elif [[ -e "${NOTES_DIR}/${_new}" ]]
    then
      printf "A notebook named '%s' already exists.\\n" "${_new}"
      return 1
    fi

    mv "${NOTES_DIR}/${_old}" "${NOTES_DIR}/${_new}"

    if [[ "$(cat "${NOTES_DIR}/.current")" == "${_old}" ]]
    then
      printf "%s\\n" "${_new}" > "${NOTES_DIR}/.current"
    fi

    printf "'%s' is now named '%s'\\n" "${_old}" "${_new}"
  }

  local _subcommand="${1:-}"
  local _name="${2:-}"

  case "${_subcommand}" in
    add)
      _notebooks_add "${_name:-}" "${3:-}"
      ;;
    current)
      basename "${NOTES_DATA_DIR}"
      ;;
    rename)
      _notebooks_rename "${_name:-}" "${3:-}"
      ;;
    use)
      if [[ -z "${_name}" ]]
      then
        _help notebooks
        return 1
      fi

      # Autocomplete can result in a trailing colon on the notebook name, so
      # remove it if present.
      if [[ "${_name}" =~ :$ ]]
      then
        _name=$(printf "%s\\n" "${_name}" | cut -f 1 -d ":")
      fi

      if [[ -d "${NOTES_DIR}/${_name}/.git" ]]
      then
        printf "%s\\n" "${_name}" > "${NOTES_DIR}/.current"
        printf "Now using %s.\\n" "$( _highlight "${_name}")"
      else
        printf "Not found: %s\\n" "${_name}"
        return 1
      fi
      ;;
    *)
      _notebooks_list "${@}"
      ;;
  esac
}
desc "nbs" "$(_help 'notebooks')"
_nbs()   { _notebooks "${@}"; }

# open ########################################################################

desc "open" "$(_help 'bookmark')"
_open() { _bookmark open "${@}"; }
desc "o" "$(_help 'open')"
_o() {
  if [[ -n "${1:-}" ]]
  then
    _open "${@}"
  else
    _ls "${@}"
  fi
}

# peek ########################################################################

desc "peek" "$(_help 'bookmark')"
_peek() { _bookmark peek "${@}"; }
desc "p" "$(_help 'bookmark')"
_p() {
  if [[ -n "${1:-}" ]]
  then
    _peek "${@}"
  else
    _ls "${@}"
  fi
}

# remote ######################################################################

desc "remote" <<HEREDOC
Usage:
  ${_ME} remote
  ${_ME} remote remove
  ${_ME} remote set <url> [-f | --force]

Subcommands:
  (default)  Print the remote URL for the notebook.
  remove     Remove the remote URL from the notebook.
  set        Set the remote URL for the notebook.

Options:
  -f --force  Skip the confirmation prompt.

Description:
  Get, set, and remove the remote repository URL for the current notebook.

Examples:
  ${_ME} remote set https://github.com/example/example.git
  ${_ME} remove remove
HEREDOC
_remote() {
  local _existing_url=
  local _force=0
  local _remote_exists=0
  local _subcommand=
  local _url=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_subcommand}" ]]
        then
          _subcommand="${__arg}"
        elif [[ "${_subcommand}" == "set" ]] &&
             [[ -z "${_url}" ]]
        then
          _url="${__arg}"
        fi
        ;;
    esac
  done
  _debug printf "_remote() \${_subcommand}: '%s'\\n" "${_subcommand}"
  _debug printf "_remote() \${_url}: '%s'\\n" "${_url}"

  cd "${NOTES_DATA_DIR}" || _die printf "_git() \`cd\` failed.\\n"

  if [[ "$(git remote get-url origin 2>/dev/null)" ]]
  then
    _remote_exists=1
    _existing_url="$(git remote get-url origin)"
  fi

  _debug printf "_remote() \${_remote_exists}: '%s'\\n" "${_remote_exists}"
  _debug printf "_remote() \${_existing_url}: '%s'\\n" "${_existing_url}"

  case "${_subcommand}" in
    remove)
      if ((_remote_exists))
      then
        if ! ((_force))
        then
          while true
          do
            printf "Removing remote '%s'\n" \
              "${_existing_url}"
            read -r -p "Do you want to proceed? [y/N] " __yn
            case ${__yn} in
              [Yy]*)
                break
                ;;
              *)
                printf "Exiting...\\n"
                exit 0
                ;;
            esac
          done
        fi

        git remote rm origin &&
          printf "Removed remote '%s'\n" "${_existing_url}" &&
          return 0
      else
        printf "No remote configured.\n"
        return 1
      fi
      ;;
    set)
      if [[ -z "${_url}" ]]
      then
        _help remote
        return 1
      fi

      if ((_remote_exists))
      then
        if [[ "${_existing_url}" == "${_url}" ]]
        then
          printf "Remote already set to '%s'\n" "${_url}"
          return 1
        fi

        if ! ((_force))
        then
          while true
          do
            printf "Updating remote from '%s' to '%s'\n" \
              "${_existing_url}" "${_url}"
            read -r -p "Do you want to proceed? [y/N] " __yn
            case ${__yn} in
              [Yy]*)
                break
                ;;
              *)
                printf "Exiting...\\n"
                exit 0
                ;;
            esac
          done
        fi

        git remote set-url origin "${_url}" &&
          printf "Remote set to '%s'\n" "${_url}" &&
          return 0
      else
        git remote add origin "${_url}"  &&
          printf "Remote set to '%s'\n" "${_url}" &&
          return 0
      fi
      ;;
    *)
      if ((_remote_exists))
      then
        git remote get-url origin &&
        return 0
      else
        printf "No remote configured.\n"
        return 0
      fi
      ;;
  esac
}

# rename ######################################################################

desc "rename" <<HEREDOC
Usage:
  ${_ME} rename (<id> | <filename> | <path> | <title>) (<name> | --reset)

Options:
  --reset  Reset the filename to the timestamp at which it was last updated.

Description:
  Rename a note. Set the filename to <name> for the specified note file.
HEREDOC
_rename() {
  local _reset=0
  local _selection=
  local _target_name=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --reset)
        _reset=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        elif [[ -z "${_target_name}" ]]
        then
          _target_name="${__arg}"
        fi
        ;;
    esac
  done

  local _source_basename
  _source_basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"
  local _source_path="${NOTES_DATA_DIR}/${_source_basename}"

  if [[ -z "${_source_basename}" ]]
  then
    _help "rename"
    return 1
  fi
  _debug printf "_rename() \${_source_basename}: '%s'\\n" \
    "${_source_basename}"

  if ((_reset))
  then
    local _file_type="${NOTES_DEFAULT_EXTENSION}"
    local _timestamp

    if stat -c &>/dev/null
    then # GNU
      _timestamp="$(stat -c %Y "${_source_path}")"
    elif gstat -c &>/dev/null
    then # GNU prefixed
      _timestamp="$(gstat -c %Y "${_source_path}")"
    else
      _timestamp="$(stat -f '%m' "${_source_path}")"
    fi

    # Assign filename with unicode timestamp.
    local _target_basename
    _target_basename="$(date -r "${_timestamp}" -u "+%Y%m%d%H%M%S").${_file_type}"
    local _destination_path="${NOTES_DATA_DIR}/${_target_basename}"

    mv "${_source_path}" "${_destination_path}" &&
      _index update "${_source_basename}" "${_target_basename}" &&
      _git_checkpoint \
        "[NOTES] Rename: ${_source_basename} to ${_target_basename}"
    printf "%s renamed to %s\n" \
      "${_source_basename}"   \
       "${_target_basename}."
  elif [[ -n "${_target_name}" ]]
  then
    if [[ -e "${NOTES_DATA_DIR}/${_target_name}" ]]
    then
      printf "File already exists: '%s'\n" "${_target_name}"
      return 1
    fi

    mv "${_source_path}" "${NOTES_DATA_DIR}/${_target_name}" &&
      _index update "${_source_basename}" "${_target_name}" &&
      _git_checkpoint \
        "[NOTES] Rename: ${_source_basename} to ${_target_name}"
    printf "%s renamed to %s\n" \
      "${_source_basename}"   \
      "${_target_name}"
  else
    _help "rename"
    return 1
  fi
}

# search ######################################################################

desc "search" <<HEREDOC
Usage:
  ${_ME} search <query> [-a | --all] [--path]

Options:
  -a --all  Search all notebooks.
  --path    Print the full path for each file with query matches.

Description:
  Search notes. Uses the first available tool in the following list:
    1. \`rg\`    https://github.com/BurntSushi/ripgrep
    2. \`ag\`    https://github.com/ggreer/the_silver_searcher
    3. \`ack\`   http://beyondgrep.com/
    4. \`grep\`  https://en.wikipedia.org/wiki/Grep

Examples:
  # search current notebook for 'example query'
  ${_ME} search 'example query'

  # search all notebooks for 'example query'
  ${_ME} search 'example query' --all

  # search notes for 'Example' OR 'Sample'
  ${_ME} search 'Example|Sample'

  # search for notes containing the hashtag '#example'
  ${_ME} search '#example'

  # search with a regular expression for notes containing phone numbers
  ${_ME} search '^(1?(-?\\d{3})-?)?(\\d{3})(-?\\d{4})$'

Shortcut Alias: \`q\`
HEREDOC
_search() {
  local _all=0
  local _arguments=("${@}")
  local _last_path=
  local _query=
  local _print_paths=0
  local _use_grep=0

  for __arg in "${_arguments[@]:-}"
  do
    case "${__arg}" in
      -a|--all)
        _all=1
        ;;
      --path)
        _print_paths=1
        ;;
      --use-grep)
        # The `--use-grep` option bypasses other search tools. Intended to be
        # used primarily for testing.
        _use_grep=1
        ;;
      *)
        if [[ -z "${_query}" ]]
        then
          _query="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_query:-}" ]]
  then
    _help "search"
    return 1
  else
    local _target_notebooks=()

    if ((_all))
    then
      _target_notebooks=($(_notebooks --names --no-color))
    else
      _target_notebooks=($(_notebook))
    fi

    _debug printf \
      "_search() \${_target_notebooks[*]}: '%s'\\n" \
      "${_target_notebooks[*]}"

    for __scope in "${_target_notebooks[@]:-}"
    do
      if _command_exists "rg" && ! ((_use_grep))
      then
        rg \
          --hidden \
          --iglob '!.git' \
          --ignore-case \
          --no-heading \
          --color always \
          --line-number \
          "${_query}" "${NOTES_DIR}/${__scope}" \
            || return 0 # Don't fail out within a single scope.
      elif _command_exists "ag" && ! ((_use_grep))
      then
        # TODO: `ag` outputs unordered results, which breaks tests/search.bats.
        # Determine how to test without relying on ordering.
        ag \
          --hidden \
          --ignore-case \
          --noheading \
          --color \
          --color-line-number '32' \
          --color-match '1;35' \
          "${_query}" "${NOTES_DIR}/${__scope}" \
            || return 0 # Don't fail out within a single scope.
      elif _command_exists "ack" && ! ((_use_grep))
      then # ack is available.
        ack "${_query}" "${NOTES_DIR}/${__scope}" \
          --ignore-case \
          --noheading \
          --color-lineno='bold green' \
          --color-match='black on_blue' \
            || return 0 # Don't fail out within a single scope.
      else # fall back to POSIX grep.
        # Add /dev/null so file path is printed even if there is only one
        # matching file. Reference: http://stackoverflow.com/a/15432718
        set +f
        grep \
          --ignore-case \
          --exclude '.git' \
          -n "${_query}" \
          "${NOTES_DIR}/${__scope}"/* "${NOTES_DIR}/${__scope}"/.[^.]* /dev/null \
            || return 0 # Don't fail out within a single scope.
        set -f
      fi | while read -r _line
      do
        local _path=
        local _filename=
        local _filename_color=
        local _filename_hit=0
        local _id=
        local _title=
        local _file_info=
        local _file_info_color=
        # Define `_id_filename` with and without color to have a version
        # without the additional length from `tput` calls.
        local _id_filename=
        local _id_filename_color=
        local _content_line_with_hit=

        # Use `sed` to remove color from output.
        # http://unix.stackexchange.com/a/140255
        _path="$(
          printf "%s\\n" "${_line}" \
            | cut -d: -f 1 \
            | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g"
        )"

        if [[ -z "${_line}" ]]
        then
          # Print nothing, skipping the blank line in `ag` output with
          # multiple matches.
          :
        elif ((_print_paths))
        then
          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf "%s\\n" "${_path}"
          fi
        else
          _filename="$(basename "${_path}")"
          _filename_color="${_filename}"

          # Use '.index' to match filenames.
          if [[ -n "${_filename:-}" ]] && [[ "${_filename:-}" == ".index" ]]
          then
            _filename_hit=1
            _filename_color="$(printf "%s\\n" "${_line}" | cut -d: -f 3-)"
            _filename="$(
              printf "%s\\n" "${_filename_color}" \
                | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g"
            )"
          fi

          _id="$(NOTES_DATA_DIR="${NOTES_DIR}/${__scope}" _index get_id "${_filename}")"
          _title="$(_get_title "${NOTES_DIR}/${__scope}/${_filename}")"

          if [[ -n "${_title}" ]]
          then
            _file_info="${_filename} '${_title}'"
            _file_info_color="${_filename_color} '${_title}'"
          else
            _file_info="${_filename}"
            _file_info_color="${_filename_color}"
          fi

          if ((_all))
          then
            _id_filename="[${__scope}:${_id}] ${_file_info}"
            _id_filename_color="[$(_highlight "${__scope}:${_id}")] ${_file_info_color}"
          else
            _id_filename="[${_id}] ${_file_info}"
            _id_filename_color="[$(_highlight "${_id}")] ${_file_info_color}"
          fi

          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf '\033[?7l'
            printf "%s\\n" "${_id_filename_color}"
            _print_line "${_id_filename}"
            printf '\033[?7h'
          fi

          if ((_filename_hit))
          then
            _content_line_with_hit="Filename Match: $(printf "%s\\n" "${_line}" | cut -d: -f 3-)"
          else
            _content_line_with_hit="$(printf "%s\\n" "${_line}" | cut -d: -f 2-)"
          fi

          printf "%s\\n\\n" "${_content_line_with_hit}"
        fi

        _last_path="${_path}"
      done
    done | if read -r _line
    then # output is present
      # Print the test line then `cat` the rest.
      printf "%s\\n" "${_line}"
      cat
      return 0
    else
      return 1
    fi
  fi
}
desc "q" "$(_help 'search')"
_q() {  _search "${@}"; }

# settings ####################################################################

desc "settings" <<HEREDOC
Usage:
  ${_ME} settings
  ${_ME} settings colors
  ${_ME} settings edit
  ${_ME} settings get <setting>
  ${_ME} settings set <setting> <value>
  ${_ME} settings unset <setting>

Subcommands:
  (default)  Print this help information.
  colors     Print a table of available colors and their xterm color numbers.
  edit       Open the ~/.notesrc configuration file in \`\$EDITOR\`.
  get        Print the current value of <setting>.
  set        Assign <value> to <setting>
  unset      Unset <setting>, returning it to the default value.

Description:
  Configure \`notes\`. Use \`settings set\` to customize a setting and
  \`settings unset\` to restore the default for a setting.

Settings:
  EDITOR
    The command line text editor to use with \`notes\`. Example Values:
    'vim', 'emacs', 'code', 'subl', 'atom', 'macdown'

  NOTES_AUTO_SYNC
    Default: '1'

    By default, operations that trigger a git commit like \`add\`, \`edit\`,
    and \`delete\` will sync notebook changes to the remote repository, if one
    is set. To disable this behavior, set this to '0'.

  NOTES_DEFAULT_EXTENSION
    Default: 'md'

    The default extension to use for notes files. Change to 'org' for Emacs
    Org mode files, 'rst' for reStructuredText, 'txt' for plain text, or
    whatever you prefer.

  NOTES_DIR
    Default: '~/.notes'

    The location of the directory that contains the notebooks.

  NOTES_ENCRYPTION_TOOL
    Default: 'openssl'

    The tool used for encrypting notes. Supported Values: 'openssl', 'gpg'

  NOTES_HIGHLIGHT_COLOR
    Default: 11 (yellow) for 256 color terminals, 3 (yellow) for 8 color.

    Set highlighting color. This should be set to an xterm color number between
    0 and 255. To view a table of available colors and numbers, run:
    \`notes settings colors\`.

Example:
  ${_ME} settings set NOTES_DEFAULT_EXTENSION 'org'
  ${_ME} settings unset NOTES_HIGHLIGHT_COLOR
  ${_ME} settings colors
HEREDOC
_settings() {
  # Usage: _notes_settings_colors
  _notes_settings_colors() {
    _notes_settings_print_color(){
        for __color_number
        do
          printf '\e[38;5;%dm %3d ' \
            "${__color_number}" \
            "${__color_number}"
        done
        # printf '\e[0m \n'
        printf '\e[0m '
    }

    _notes_settings_print_color {0..15}

    for ((_i=0;_i<6;_i++))
    do
      _notes_settings_print_color $(seq $((_i*36+16)) $((_i*36+51)))
    done

    _notes_settings_print_color {232..255}

    printf "\\n"
  }

  # Usage: _notes_settings_get <setting>
  _notes_settings_get() {
    _notes_settings_validate "${1}" &&
      _env | grep "${1}" | cut -d= -f2
  }

  # Usage: _notes_settings_set <setting> <value>
  _notes_settings_set() {
    local _entry=
    _entry="export ${1:-}=${2:-} # Added by \`notes\` â€¢ $(date)"
    local _stripped=

    _notes_settings_validate "${1:-}" &&
      _notes_settings_validate_value "${1:-}" "${2:-}" &&
      _notes_settings_unset "${1}" > /dev/null 2>&1     &&
      printf "\\n%s\\n" "${_entry}" >> "${NOTESRC_PATH}" &&
      printf "%s set to '%s'\\n" "${1:-}" "${2:-}"
  }

  # Usage: _notes_settings_unset <setting>
  _notes_settings_unset() {
    _notes_settings_validate "${1}" &&
      "${_SED_I_COMMAND[@]}" \
        -e "s/^export ${1}.*Added by.*$//g" \
        "${NOTESRC_PATH}" &&
        {
          _stripped=$(<"${NOTESRC_PATH}")
          printf "%s\\n" "${_stripped}" > "${NOTESRC_PATH}"
        } &&
        printf "%s restored to the default: '%s'\\n" \
          "${1:-}" \
          "$(eval "${1:-}='' ${_MY_PATH} settings get ${1:-}")"
  }

  # Usage: _notes_settings_validate <setting>
  _notes_settings_validate() {
    local _match=0
    local _available_settings=(
      EDITOR
      NOTES_AUTO_SYNC
      NOTES_DEFAULT_EXTENSION
      NOTES_DIR
      NOTES_ENCRYPTION_TOOL
      NOTES_HIGHLIGHT_COLOR
    )
    for __setting in "${_available_settings[@]}"
    do
      if [[ "${__setting}" == "${1:-}" ]]
      then
        _match=1
      fi
    done

    if ! ((_match))
    then
      printf "Setting not found: '%s'\n" "${1:-}"
      return 1
    fi
  }

  # Usage: _notes_settings_validate_color <setting> <value>
  _notes_settings_validate_value() {
    if [[ "${1:-}" == 'EDITOR' ]] ||
       [[ "${1:-}" == 'NOTES_DEFAULT_EXTENSION' ]] ||
       [[ "${1:-}" == 'NOTES_DIR' ]]
    then
      if [[ -n "${2:-}" ]]
      then
        return 0
      else
        printf "%s requires a value.\\n" "${1:-}"
        return 1
      fi
    elif [[ "${1:-}" == 'NOTES_AUTO_SYNC' ]]
    then
      if [[ "${2:-}" =~ ^0|1$ ]]
      then
        return 0
      else
        printf "NOTES_AUTO_SYNC must be either '0' or '1'.\\n"
        return 1
      fi
    elif [[ "${1:-}" == 'NOTES_ENCRYPTION_TOOL' ]]
    then
      if [[ "${2:-}" =~ ^openssl|gpg$ ]]
      then
        return 0
      else
        printf "NOTES_ENCRYPTION_TOOL must be either 'openssl' or 'gpg'.\\n"
        return 1
      fi
    elif [[ "${1:-}" == 'NOTES_HIGHLIGHT_COLOR' ]]
    then
      if [[ "${2:-}" =~ ^[0-9]{1,3}$ ]] &&
         [[ "${2:-}" -lt '256' ]]
      then
        return 0
      else
        printf "NOTES_HIGHLIGHT_COLOR must be number between 0 and 255.\\n"
        return 1
      fi
    else
      return 0
    fi
  }

  local _subcommand=

  while ((${#}))
  do
    local _arg="${1:-}"

    case "${_arg}" in
      color|colors)
        _notes_settings_colors
        return 0
        ;;
      edit)
        _edit_file "${NOTESRC_PATH}" --no-wait
        return 0
        ;;
      get)
        if [[ -z "${2:-}" ]]
        then
          _help settings
          return 1
        fi

        _notes_settings_get "${2:-}"
        return 0
        ;;
      set)
        if [[ -z "${2:-}" ]] || [[ -z "${3:-}" ]]
        then
            _help settings
            return 1
        fi

        _notes_settings_set "${2:-}" "${3:-}"
        return 0
        ;;
      unset)
        if [[ -z "${2:-}" ]]
        then
          _help settings
          return 1
        fi

        _notes_settings_unset "${2:-}"
        return 0
        ;;
      *)
        _help settings
        return 0
        ;;
    esac

    shift
  done
}
desc "config" "$(_help 'settings')"
_config()    { _settings "${@}"; }

# shell  ######################################################################

desc "shell" <<HEREDOC
Usage:
  ${_ME} shell [<subcommand> [<options>...] | --clear-history]

Optons:
  --clear-history  Clear the \`${_ME}\` shell history.

Description:
  Start the \`${_ME}\` interactive shell. Type 'exit' to exit.

  When <subcommand> is present, the command will run as the shell is opened.

Example:
  $ ${_ME} shell
  ${_ME}> ls 3
  [3] Example

  ${_ME}> edit 3 --content "New content."
  Updated [3] Example

  ${_ME}> notebook
  home

  ${_ME}> exit
  $
HEREDOC
_shell() {
  HISTFILE="${HOME}/.${_ME}_history"
  set -o history

  local _initial_command=
  local _prompt=
  _prompt="$(_highlight "${_ME}")> "

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --clear-history)
        if [[ -e "${HISTFILE}" ]]
        then
          rm "${HISTFILE}"
          printf "History cleared.\n"
          return 0
        fi
        ;;
      *)
        if [[ -n "${__arg}" ]]
        then
          _initial_command+=" ${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_shell() \${_initial_command:-}: '%s'\\n" \
    "${_initial_command:-}"

  if [[ -n "${_initial_command:-}" ]]
  then
    eval "${_MY_PATH} ${_initial_command}"
  fi

  while true
  do
    while IFS='' read -r -e -d $'\n' -p "${_prompt}" _options
    do
      history -s "${_options}"
      if [[ "${_options}" =~ ^exit|quit$ ]]
      then
       return 0
      else
       eval "${_MY_PATH} ${_options}" || :
      fi
    done
  done
}

# show ########################################################################

desc "show" <<HEREDOC
Usage:
  ${_ME} show (<id> | <filename> | <path> | <title>) [--id | --path | --render]
             [--dump [--no-color]]

Options:
  --dump      Print to standard output.
  --id        Print the id number of the note file.
  --path      Print the full path of the note file.
  --no-color  When used with \`--dump\`, print the note without highlighting.
  --render    Use \`pandoc\` [1] to render the file to HTML and display with
              \`lynx\` [2] (if available) or \`w3m\` [3]. If \`pandoc\` is not
              available, \`--render\` is ignored.

Description:
  Show a note. Notes in text file formats can be rendered or dumped to
  standard output. Non-text files will be opened in your system's preferred
  app or program for that file type.

  If Pygments [4] is installed, notes are printed with syntax highlighting.

    1. http://pandoc.org/
    2. https://en.wikipedia.org/wiki/Lynx_(web_browser)
    3. https://en.wikipedia.org/wiki/W3m
    4. http://pygments.org/

Examples:
  ${_ME} show 1
  ${_ME} show example.md --render
  ${_ME} show 'A Document Title' --dump --no-color

Shortcut Alias: \`s\`
HEREDOC
_show() {
  _debug printf "_show() \${0:-}: '%s'\\n" "${0:-}"
  _debug printf "_show() \${1:-}: '%s'\\n" "${1:-}"
  _debug printf "_show() \${2:-}: '%s'\\n" "${2:-}"

  local _dump=0
  local _password=
  local _print_id=0
  local _print_no_color=0
  local _print_path=0
  local _render=0
  local _selection=

  # Parse function options.
  while ((${#}))
  do
    local _arg="${1:-}"
    local _val="${2:-}"

    case "${_arg}" in
      --dump)
        _dump=1
        ;;
      --path)
        _print_path=1
        ;;
      --id|--index)
        _print_id=1
        ;;
      --password)
        if __option_value_is_present "${_val:-}"
        then
          _password="${_val:-}"
          shift
        else
          _help edit
          return 1
        fi
        ;;
      --raw|--no-color|--nocolor)
        _print_no_color=1
        ;;
      --render|-r)
        _render=1
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${_arg}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "_show() \${_render}: '%s'\\n" "${_render}"
  _debug printf "_show() \${_selection}: '%s'\\n" "${_selection}"

  if [[ -z "${_selection:-}" ]]
  then
    _help "show"
    return 1
  fi

  local _basename
  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_show() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    printf "Note not found: '%s'.\\n" "${_selection}"
    return 1
  fi
  _set_selection_notebook "${_selection}"

  local _target_path="${NOTES_DATA_DIR}/${_basename}"

  if _file_is_encrypted "${_target_path}"
  then
    local _encrypted_path
    _encrypted_path="${_target_path}"

    if [[ -z "${_password}" ]]
    then
      # Request password without displaying it
      printf "Password: "
      read -r -s _password </dev/tty
      printf "\\n" # print newline to stop `read`.
    fi

    if [[ -z "${_password}" ]]
    then
      printf "Password required.\n"
      return 1
    fi

    local _decrypted_path
    _decrypted_path="$(_decrypt_file "${_target_path}" "${_password}")"

    _target_path="${_decrypted_path}"
  fi

  if _file_is_archive "${_target_path}"
  then
    printf "\
Can't show archives. Export archive and expand to edit.\n"
    exit 1
  fi

  if ! _file_is_text "${_target_path}"
  then
    if _command_exists "xdg-open"
    then
      xdg-open "${_target_path}" && return 0
    elif [[ "${OSTYPE}" =~ ^darwin ]]
    then
      open "${_target_path}" && return 0
    fi
  fi

  # Display file.
  if [[ -n "${_basename}" ]] && [[ -e "${_target_path}" ]]
  then # _basename is assigned and a note exists with that name.
    if ((_print_path))
    then # `notes show --path`
      printf "%s/%s\\n" "${NOTES_DATA_DIR}" "${_basename}"
    elif ((_print_id))
    then
      local _id
      _id="$(_index get_id "${_basename}")"
      printf "%s\\n" "${_id}"
    elif ((_render)) &&
         ((_dump))   &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render --dump` with `pandoc` and `w3m` available.
      pandoc "${_target_path}" \
        | w3m -dump -T text/html
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render` with `pandoc` and `w3m` available.
      pandoc "${_target_path}" \
        | w3m -T text/html
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "lynx"
    then # `notes show --render` with `pandoc` and `lynx` available.
      pandoc "${_target_path}" | lynx -stdin
    else # default
      if ((_dump))
      then # `notes show --dump [--no-color]`
        if ((_print_no_color))
        then # `notes show --dump --no-color`
          cat "${_target_path}"
        else # `notes show --dump`
          _highlight_syntax_if_available "${_target_path}"
        fi
      else # `notes show`
        if [[ -n "${PAGER:-}" ]]
        then
          _highlight_syntax_if_available "${_target_path}" \
            | "${PAGER}"
        else
          _highlight_syntax_if_available "${_target_path}"
        fi
      fi
    fi
  else # _basename is not assigned or no note exists with that name.
    printf "Selection not found.\\n"
    return 1
  fi

  if [[ -n "${_decrypted_path:-}" ]] && [[ -e "${_decrypted_path}" ]]
  then
    rm "${_decrypted_path}"
  fi
}
desc "s" "$(_help 'show')"
_s() { _show "${@}"; }

# status ######################################################################

desc "status" <<HEREDOC
Usage:
  ${_ME} status

Description:
  Run \`git status\` in the current notebook.
HEREDOC
_status() {
  cd "${NOTES_DATA_DIR}" || _die printf "_status() \`cd\` failed.\\n"
  git status
}

# sync ########################################################################

desc "sync" <<HEREDOC
Usage:
  ${_ME} sync [-a | --all]

Options:
  -a --all  Sync all notebooks.

Description:
  Sync the current local notebook with the remote repository.
HEREDOC
_sync() {
  local _notebooks

  _debug printf "_sync() \${*}: '%s'\\n" "${*}"

  if [[ -n "${1:-}" ]] && [[ "${1}" =~ ^-a|--all$ ]]
  then
    _debug printf "_sync() -a|--all\\n"
    _notebooks=($(_notebooks --names --no-color))
  else
    _notebooks=($(_notebook))
  fi

  _debug printf "_sync() \${_notebooks[*]:-}: '%s'\\n" "${_notebooks[*]:-}"

  printf "Syncing: "
  for __notebook in "${_notebooks[@]:-}"
  do
    printf "%s..." "${__notebook}"
    NOTES_DATA_DIR="${NOTES_DIR}/${__notebook}"
    (NOTES_AUTO_SYNC=1 _git_checkpoint "[NOTES] Sync" --spinner)
  done &&
    printf "Done!\\n" ||
    printf "Syncing failed!\\n"
}

# update ######################################################################

desc "update" <<HEREDOC
Usage:
  ${_ME} update

Description:
  Update ${_ME} to the latest version.
HEREDOC
_update() {
  if hash npm 2>/dev/null &&
     npm list | grep -q notes.sh &&
     [[ "${BASH_SOURCE[0]}" =~ \/node\/|\/node_modules\/ ]]
  then # installed with npm
    cat <<'HEREDOC'
Installed with npm. To update, run:
  npm update -g notes.sh
HEREDOC
  elif [[ "${OSTYPE}" =~ ^darwin ]] &&
       [[ "$(realpath "${BASH_SOURCE[0]}")" =~ Cellar ]]
  then
    cat <<'HEREDOC'
Installed with Homebrew. To update, run:
  brew upgrade xwmx/taps/notes
HEREDOC
  else
    _notes_url="https://raw.githubusercontent.com/xwmx/notes/master/notes"
    _temp_file="$(mktemp)"

    curl -s "${_notes_url}" -o "${_temp_file}"

    if [[ "$(_get_hash "${_temp_file}")" != "$(_get_hash "${BASH_SOURCE[0]}")" ]]
    then
      while true
      do
        read -r -p "Updating \`${_ME}\` in place. Are you sure you want to proceed? [y/N] " __yn
        case ${__yn} in
          [Yy]*)
            break
            ;;
          *)
            printf "Exiting...\\n"
            exit 0
            ;;
        esac
      done

      cat  "${_temp_file}" > "${BASH_SOURCE[0]}"
      printf "%s updated to the latest version.\n" "${_ME}"
    else
      printf "Already at the latest version.\n"
    fi

    if [[ -n "${_temp_file}" ]]
    then
      rm "${_temp_file}"
    fi
  fi
}

# use #########################################################################

desc "use" <<HEREDOC
Usage:
  ${_ME} use <notebook>

Description:
  Switch to the specified notebook. Shortcut for \`notes notebooks use\`.

Shortcut Alias: \`u\`
HEREDOC
_use() {
  local _name="${1:-}"
  if [[ -z "${_name}" ]]
  then
    _help use
    return 1
  fi
  _notebooks use "${_name}"
}
desc "u" "$(_help 'use')"
_u() { _use "${@}"; }

# version ####################################################################

desc "version" <<HEREDOC
Usage:
  ${_ME} version

Description:
  Display version information.
HEREDOC
_version() {
  printf "%s\\n" "${_VERSION}"
}

###############################################################################
# _notes()
###############################################################################

# _notes()
#
# Description:
#   Call the appropriate subcommand.
_notes() {
  _debug printf "_notes() >> start\\n"
  _debug printf "_notes() \${@}: '%s'\\n" "${@}"
  _debug printf "_notes() \${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"

  # Set `$_SUBCOMMAND` if it's still blank.
  if [[ -z "${_SUBCOMMAND:-}" ]]
  then
    _SUBCOMMAND="ls"
  fi

  if [[ -n "${_SCOPE}" ]]
  then
    _SCOPED=1
    NOTES_DATA_DIR="${NOTES_DIR}/${_SCOPE}"
  else
    _SCOPE="$(basename "${NOTES_DATA_DIR}")"
  fi

  case "${_SUBCOMMAND}" in
    init|sync)
      _git_required
      "_${_SUBCOMMAND}" "${@}"
      ;;
    commands|env|help|version)
      "_${_SUBCOMMAND}" "${@}"
      ;;
    *)
      _git_required

      # Call `_init()` if configuration hasn't been initialized.
      if [[ ! -e "${NOTES_DIR}"       ]] &&
         [[ ! -e "${NOTESRC_PATH}"    ]] ||
         [[ ! -e "${NOTES_DATA_DIR}"  ]]
      then
        _git_required
        _init "${@}"
        _ls || true # returns 0 due to empty repository.
        return 0
      fi

      local _core_subcommands=(
        a
        add
        b
        bookmark
        count
        d
        delete
        e
        edit
        list
        ls
        move
        mv
        nb
        nbs
        notebook
        notebooks
        q
        rename
        s
        show
        search
        use
        u
      )
      local _core_subcommand_pattern
      _core_subcommand_pattern="^$(_join '$|^' "${_core_subcommands[@]}")$"

      _debug printf "\${_SUBCOMMAND}: %s\\n" "${_SUBCOMMAND}"
      _debug printf "\${_core_subcommand_pattern}: %s\\n" "${_core_subcommand_pattern}"

      if [[ "${_SUBCOMMAND}" =~ ${_core_subcommand_pattern} ]]
      then
        if _git_index_is_dirty
        then
          _index reconcile

          if _git_should_autosync
          then
            _debug \
              printf "_notes(): _git_index_is_dirty && ((NOTES_AUTO_SYNC))\\n"
            "${_MY_PATH}" sync
          else
            _debug \
              printf "_notes(): _git_index_is_dirty && ! ((NOTES_AUTO_SYNC))\\n"
            _git_checkpoint "[NOTES] Commit" --spinner
          fi
        elif _git_should_autosync
        then
          _debug \
            printf "_notes(): ! _git_index_is_dirty\\n"
          ("${_MY_PATH}" sync &>/dev/null) &
        fi
      fi

      "_${_SUBCOMMAND}" "${@}"
      ;;
  esac
}

###############################################################################
# Program Option Parsing
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring='h'

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while ((${#}))
do
  case "${1}" in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c="${1:i:1}"
        # add current char to options
        options+=("-${c}")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ "${optstring}" = *"${c}:"* && "${1:i+1}" ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_SCOPE=
_SCOPED=0
_ARGUMENTS=()

# $_SUBCOMMANDS
#
# All available subcommands.
_SUBCOMMANDS=(
  a
  add
  b
  bookmark
  commands
  config
  count
  d
  delete
  e
  edit
  export
  env
  git
  h
  help
  history
  import
  index
  init
  list
  ls
  move
  mv
  nb
  nbs
  notebook
  notebooks
  o
  open
  p
  peek
  q
  remote
  rename
  s
  search
  settings
  shell
  show
  status
  sync
  update
  use
  u
  version
)

# $_SUBCOMMANDS_PATTERN
#
# The contents of the `$_SUBCOMMANDS` array, joined with '|', with the
# `@(<pattern list>)` pattern matching operator, which matches one of the
# given patterns. This operator is enabled using `shopt -s extglob`.
#
# More information:
# http://stackoverflow.com/a/13254908
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
_SUBCOMMANDS_PATTERN="@($(_join '|' "${_SUBCOMMANDS[@]}"))"

_debug printf "\${_SUBCOMMANDS_PATTERN}: %s\\n" "${_SUBCOMMANDS_PATTERN}"

# _is_valid_subcommand()
#
# Usage:
#   _is_valid_subcommand <name>
#
# Returns:
#   0  If the given <name> is a valid subcommand name.
#   1  If not.
_is_valid_subcommand() {
  case "${1:-}" in
    ${_SUBCOMMANDS_PATTERN})
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# _require_argument()
#
# Usage:
#   _require_argument <option> <argument>
#
# If <argument> is blank or another option, print an error message and  exit
# with status 1.
_require_argument() {
  local _option="${1:-}"
  local _value="${2:-}"

  if [[ -z "${_value}" ]] || [[ "${_value}" =~ ^- ]]
  then
    _die printf "Option requires an argument: %s\\n" "${_option}"
  fi
}

# getopts and getopts have inconsistent behavior, so using a simple home-brewed
# while loop. This isn't perfectly compliant with POSIX, but it's close enough
# and this appears to be a widely used approach.
#
# More info:
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
while ((${#}))
do
  __opt="${1}"
  shift
  case "${__opt}" in
    -h|--help)
      if [[ "${_SUBCOMMAND}" == "git" ]]
      then
        _ARGUMENTS+=("${__opt}")
      else
        _PRINT_HELP=1
      fi
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      if [[ "${_SUBCOMMAND}" == "git" ]]
      then
        _ARGUMENTS+=("${__opt}")
      else
        _PRINT_VERSION=1
      fi
      ;;
    -i|--interactive)
      _SUBCOMMAND="shell"
      ;;
    *:*)
      __parts=($(printf "%s\\n" "${__opt}" | tr ":" "\\n"))
      if [[ -z "${_SCOPE:-}"        ]] &&
         [[ -z "${_SUBCOMMAND:-}"   ]] &&
         [[ "${#__parts[@]}" -gt 0  ]]
      then
        if [[ -d "${NOTES_DIR}/${__parts[0]}" ]]
        then
          _SCOPE="${__parts[0]}"
          if _is_valid_subcommand "${__parts[1]:-}"
          then
            _SUBCOMMAND="${__parts[1]:-}"
          fi
        else
          printf "Notebook not found: %s\\n" "${__parts[0]}"
          exit 1
        fi
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
    --endopts)
      # Terminate option parsing.
      break
      ;;
    *)
      if [[ -z "${_SUBCOMMAND:-}" ]] && _is_valid_subcommand "${__opt}"
      then
        _SUBCOMMAND="${__opt}"
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
  esac
done

_debug printf "\${_SUBCOMMANDS[*]}: '%s'\\n" "${_SUBCOMMANDS[*]}"
_debug printf "\${_SUBCOMMANDS_PATTERN}: '%s'\\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"
_debug printf "\${_SCOPE}: '%s'\\n" "${_SCOPE}"
_debug printf "\${_ARGUMENTS[*:-]}: '%s'\\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# _main()
###############################################################################

# _main()
#
# Usage:
#   _main "$@"
#
# Describe:
#   Primary entry point for the program logic. Call this function at the end
#   of the script after everything has been defined.
_main() {
  if (("${_PRINT_HELP}"))
  then
    _help "${_SUBCOMMAND:-}"
  elif (("${_PRINT_VERSION}"))
  then
    _version
  else
    _notes "${_ARGUMENTS[@]:-}"
  fi
}

_main "${@:-}"
