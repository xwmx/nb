#!/usr/bin/env bash
#              _
#  _ __   ___ | |_ ___  ___
# | '_ \ / _ \| __/ _ \/ __|
# | | | | (_) | ||  __/\__ \
# |_| |_|\___/ \__\___||___/
#
# Based on Bash Boilerplate: https://github.com/alphabetum/bash-boilerplate
#
# Copyright (c) 2015 William Melody â€¢ hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
IFS=$'\n\t'

###############################################################################
# Environment
###############################################################################

_VERSION="0.0.0-alpha"

# $_ME
#
# Set to the program's basename.
_ME=$(basename "$0")

# extglob
#
# Enable extended pattern matching operators.
#
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
shopt -s extglob

###############################################################################
# .notesrc
###############################################################################

# .notesrc
#
# If a `.notesrc` file exists in `$HOME`, source it.
export NOTESRC_PATH="${NOTESRC_PATH:-${HOME}/.notesrc}"
if [[ -e "${NOTESRC_PATH}" ]]
then
  # shellcheck disable=SC1090
  #
  # Shellcheck can't follow non-constant source.
  #
  # More information:
  #   https://github.com/koalaman/shellcheck/wiki/SC1090
  source "${NOTESRC_PATH}"
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  %s " "${__DEBUG_COUNTER}"
    "$@"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "$@"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "âŒ  "
  "$@" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "$@"
}

###############################################################################
# Setup
###############################################################################

# `$NOTES_DIR`
#
# Default: `$HOME/.notes`
export NOTES_DIR="${NOTES_DIR:-${HOME}/.notes}"

# `$NOTES_DATA_DIR`
#
# Default: `$NOTES_DIR/home`
export NOTES_DATA_DIR="${NOTES_DATA_DIR:-${NOTES_DIR}/home}"
_set_notes_data_dir() {
  if [[ -e "${NOTES_DIR}/.current" ]]
  then
    local _current
    _current="$(cat "${NOTES_DIR}/.current")"
    if [[ -e "${NOTES_DIR}/${_current}" ]]
    then
      NOTES_DATA_DIR="${NOTES_DIR}/${_current}"
    fi
  fi
}
_set_notes_data_dir

# `$NOTES_AUTO_SYNC`
#
# Default: 1
#
# When set to '1', each `_git_checkpoint()` call will automativally run
# `$_ME sync`. To disable this behavior, set the value to '0'.
export NOTES_AUTO_SYNC="${NOTES_AUTO_SYNC:-1}"

# `$NOTES_DEFAULT_EXTENSION`
#
# Default: 'md'
#
# Example Values: 'md' 'org'
export NOTES_DEFAULT_EXTENSION="${NOTES_DEFAULT_EXTENSION:-md}"

###############################################################################
# Helpers
###############################################################################

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Takes a potential command name as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "$1" 2>/dev/null
}

# _get_index()
#
# Usage:
#   _get_index <item> <list>
#
# Description:
#   Print the index of <item> in <list>
#
# Returns:
#   0  <item> is found in <list>.
#   1  <item> is not found in <list>.
_get_index() {
  # _debug printf "_get_index() \${1}: '%s'\n" "${1:-}"
  # _debug printf "_get_index() \${@:2}: '%s'\n" "${@:2}"

  local _filename="${1:-}"
  local -a _files=(${@:2})

  # _debug printf "_get_index() \${_files[@]}: '%s'\n" "${_files[@]}"

  if [[ -z "${_filename}" ]] || [[ -z "${_files[*]}" ]]
  then
    _die printf "Usage: _get_index <item> <list>"
  fi

  for _i in "${!_files[@]}"
  do
    # _debug printf "_get_index() \${_files[$_i]} : '%s'\n" "${_files[$_i]}"
    if [[ "${_files[$_i]}" == "${_filename}" ]]
    then
      printf "%s\n" "${_i}"
      return 0
    fi
  done
  return 1
}

# _get_selection_basename()
#
# Usage:
#   _get_selection_basename <index>
#   _get_selection_basename <filename>
#   _get_selection_basename <path>
#   _get_selection_basename <title>
#
# Description:
#   Determine the basename of the file in `$NOTES_DATA_DIR` that is identified
#   by the given <index>, <filename>, <path>, or <title>.
_get_selection_basename() {
  local _basename=
  local _selection="${1:-}"
  local _identifier=
  if [[ -z "${_selection}" ]]
  then  # <selection> is blank.
    _basename=
  else

    NOTES_DATA_DIR="$(_get_selection_notebook "${_selection}")"
    _identifier="$(_get_selection_identifier "${_selection}")"

    if [[ -e "${_identifier}" ]] && [[ "${_identifier}" =~ $NOTES_DATA_DIR ]]
    then # <selection> is a full path.
      _basename="$(basename "${_identifier}")"
    elif [[ -e "${NOTES_DATA_DIR}/${_identifier}" ]]
    then # <selection> is a filename.
      _basename="${_identifier}"
    elif [[ "${_identifier}" =~ ^[0-9]+$ ]]
    then # <selection> is an id.
      local _filenames=($(_list_notes_files))
      _debug printf \
        "_get_selection_basename() \$_filenames[*]: '%s'\n" \
        "${_filenames[*]:-}"
      _basename="${_filenames[${_identifier}]:-}"
    else # <selection> might be a title.
      local _title
      local _filenames

      _filenames=($(_list_notes_files))
      for _file in "${_filenames[@]:-}"
      do
        _title="$(_get_title "${_file}")"

        if [[ -n "${_title}" ]] &&
           [[ "${_title}" == "${_identifier}" ]]
        then
          _basename="${_file}"
          break
        fi
      done
    fi
  fi

  printf "%s\n" "${_basename}"
}

# _get_selection_notebook()
#
# Usage:
#   _get_selection_notebook <selection>
#
# Description:
#   Given <selection>, print the notebook portion, if present.
_get_selection_notebook() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))
  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    printf "%s\n" "${NOTES_DIR}/${_parts[0]}"
  else
    printf "%s\n" "${NOTES_DATA_DIR}"
  fi
}

# _get_selection_identifier()
#
# Usage:
#   _get_selection_identifier <selection>
#
# Description:
#   Given <selection>, print the identifier portion.
_get_selection_identifier() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))
  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    printf "%s\n" "${_parts[1]:-}"
  else
    printf "%s\n" "${_parts[0]:-}"
  fi
}

# _get_selection_parts()
#
# Usage:
#   _get_selection_parts <selection>
#
# Description:
#   Given <selection>, split on first colon.
_get_selection_parts() {
  local _identifier
  local _data_dir

  _data_dir=$(printf "%s\n" "${1:-}" | cut -f 1 -d ":")

  if [[ "${1:-}" =~ ':'       ]] &&
     [[ -e "${NOTES_DIR}/${_data_dir}/.git" ]]
  then
    _identifier=$(printf "%s\n" "${1:-}" | cut -f 2- -d ":")
    printf "%s\n%s\n" "${_data_dir}" "${_identifier}"
  else
    printf "%s\n" "${1:-}"
  fi
}

# _get_title()
#
# Usage:
#   _get_title <basename>
#
# Description:
#   Print the title, if present, of the note with the given basename.
_get_title() {
  local _basename="${1:-}"
  local _title=
  if [[ -z "${_basename}" ]]
  then
    _die printf "Usage: _get_title <basename>\n"
  fi
  _maybe_title="$(head -1 "${NOTES_DATA_DIR}/${_basename}")"
  if [[ "${_maybe_title}" =~ ^#\  ]]
  then # first line starts with an H1
    _title="$(printf "%s\n" "${_maybe_title}" | sed 's/^\# //')"
  fi
  printf "%s\n" "${_title}"
}

# _git_checkpoint()
#
# Usage:
#   _git_checkpoint <commit message>
#
# Description:
#   Commit all files in the repository with the provided commit message.
_git_checkpoint() {
  _git_checkpoint_commit() {
    [[ -z "${1:-}" ]] && _die printf "Usage: _git_checkpoint_commit <message>"
    git add --all && git commit -a -m "${1}"
  }
  _git_checkpoint_sync() {
    git fetch && git rebase origin/master && git push
  }

  local _message="${1:-}"
  local _show_spinner=0

  if [[ -z "${_message}" ]]
  then
    _die printf "Usage: _git_checkpoint <message>\n"
    return 1
  fi

  if [[ -n "${2:-}" ]] && [[ "${2}" == "--spinner" ]]
  then
    _show_spinner=1
  fi

  cd "${NOTES_DATA_DIR}" || _die printf "_git_checkpoint() \`cd\` failed.\n"

  if ((NOTES_AUTO_SYNC))
  then
    (
      # Only sync when the index is dirty to avoid fetching from and pushing
      # to origin.
      if _git_index_is_dirty
      then
        _git_checkpoint_commit "${_message}" &>/dev/null
      fi && _git_checkpoint_sync &>/dev/null
    ) &
  else
    (
      _git_checkpoint_commit "${_message}" &>/dev/null
    ) &
  fi

  if ((_show_spinner))
  then
    _spinner $!
  fi
}

# _git_index_is_dirty()
#
# Usage:
#   _git_index_is_dirty
#
# Returns:
#   0  If there are uncommitted changes in the `NOTES_DATA_DIR` repository.
#   1  If the `$NOTES_DATA_DIR` repository is clean.
_git_index_is_dirty() {
  cd "${NOTES_DATA_DIR}" \
    || _die printf "_git_index_is_dirty() \`cd\` failed.\n"
  [[ -n "$(git status --porcelain)" ]]
}

# _git_required()
#
# Usage:
#   _git_required
#
# Description:
#   Exit with `_die` if `git` isn't found.
_git_required() {
  if ! _command_exists "git"
  then
    _die printf "\`git\` is required, but wasn't found.\n"
  fi
}

# _git_should_autosync()
#
# Usage:
#   _git_should_autosync
#
# Returns:
#   0  If an autosync should be triggered.
#   1  If not.
_git_should_autosync() {
  local _last_fetch_timestamp
  local _current_timestamp

  if ! ((NOTES_AUTO_SYNC))
  then # autosync not enabled.
    return 1
  fi

  cd "${NOTES_DATA_DIR}" || _die printf "\`cd\` failed.\n"
  if ! git config --get remote.origin.url &>/dev/null
  then # there is no remote configured.
    return 1
  fi

  if [[ ! -e "${NOTES_DATA_DIR}/.git/FETCH_HEAD" ]]
  then # no previous fetches, but has an origin and autosync is enabled.
    return 0
  fi

  if stat -c &>/dev/null
  then # GNU
    _last_fetch_timestamp="$(stat -c %Y .git/FETCH_HEAD)"
  elif gstat -c &>/dev/null
  then # GNU prefixed
    _last_fetch_timestamp="$(gstat -c %Y .git/FETCH_HEAD)"
  else
    _last_fetch_timestamp="$(stat -f '%m' .git/FETCH_HEAD)"
  fi
  _current_timestamp="$(date +%s)"

  _diff=$((_current_timestamp-_last_fetch_timestamp))
  _debug printf \
    "_git_should_sync() \$_last_fetch_timestamp: %s\n" \
    "${_last_fetch_timestamp}"
  _debug printf \
    "_git_should_sync() \$_current_timestamp: %s\n" \
    "${_current_timestamp}"
  _debug printf \
    "_git_should_sync() \$_diff: %s\n" \
    "${_diff}"

  [[ "$_diff" -gt 300 ]]
}

# _highlight()
#
# Usage:
#   _highlight <string>
#
# Description:
#   Use `tput` to highlight the given string.
_highlight() {
  local _input="${1:-}"
  if [[ -z "${_input}" ]]
  then
    _die printf "Usage: _highlight <string>"
  fi
  printf "$(tput setaf 3)%s$(tput sgr0)\n" "${_input}"
}

# _highlight_syntax_if_available()
#
# Usage:
#   _highlight_syntax_if_available [<path>]
#
# Description:
#   If Pygments and pygments-markdown-lexer are available, use them to
#   highlight markdown syntax. When they are not available, just pipe through
#   `cat`.
#
# References:
#   http://pygments.org/
#   https://github.com/jhermann/pygments-markdown-lexer
_highlight_syntax_if_available() {
  if hash "pygmentize" 2>/dev/null &&
    pygmentize -l markdown &>/dev/null /dev/null
  then # pygments and the markdown lexer are installed.
    pygmentize -l markdown "${@}"
  else
    cat "${@}"
  fi
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _join()
#
# Usage:
#   _join <separator> <array>
#
# Examples:
#   _join , a "b c" d     => a,b c,d
#   _join / var local tmp => var/local/tmp
#   _join , "${FOO[@]}"   => a,b,c
#
# More Information:
#   http://stackoverflow.com/a/17841619
_join() {
  local IFS="$1"
  shift
  printf "%s\n" "$*"
}

# _list_notes_files()
#
# Usage:
#   _list_notes_files
#
# Description:
#   List note files with default sorting.
_list_notes_files() {
  # Relevant `ls` options:
  # -t  Sort by time modified (most recently modified first) before sorting
  #     the operands by lexicographical order
  # -r  Reverse the order of the sort to get reverse order or the oldest
  #     entries first (or largest files last, combined with sort by size
  ls -t "${NOTES_DATA_DIR}"
}

# _print_line()
#
# Usage:
#   _print_line <text>
#
# Description:
#   Print a line of dashes the length of <text>.
#
# More information:
#   http://wiki.bash-hackers.org/commands/builtin/printf
_print_line() {
  local _text="${1:-}"
  local _text_length=0
  local _line=
  _text_length=${#_text}
  printf -v _line '%*s' "${_text_length}"
  printf "%s\n" "${_line// /-}"
}

# _spinner()
#
# Usage:
#   _spinner <pid>
#
# Description:
#   Display an ascii spinner while <pid> is running.
#
# Example Usage:
#   ```
#   _spinner_example() {
#     printf "Working..."
#     (sleep 1) &
#     _spinner $!
#     printf "Done!\n"
#   }
#   (_spinner_example)
#   ```
#
# More Information:
#   http://fitnr.com/showing-a-bash-spinner.html
_spinner() {
  local _pid="${1:-}"
  local _delay=0.75
  local _spin_string="|/-\\"

  if [[ -z "${_pid}" ]]
  then
    _die printf "Usage: _spinner <pid>\n"
  fi

  while ps a | awk '{print $1}' | grep -q "${_pid}"
  do
    local _temp="${_spin_string#?}"
    printf " [%c]  " "${_spin_string}"
    _spin_string="${_temp}${_spin_string%${_temp}}"
    sleep ${_delay}
    printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'EOM'
# some message
# EOM
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z $1 ]] && _die printf "desc: No command name specified.\n"
  if [[ -n ${2:-} ]]
  then
    read -r -d '' "_${_ME}_desc_${1}" <<EOM
$2
EOM
    _debug printf "desc() set with argument: \$_%s_desc_%s\n" "${_ME}" "${1}"
  else
    read -r -d '' "_${_ME}_desc_${1}"
    _debug printf "desc() set with pipe: \$_%s_desc_%s\n" "${_ME}" "${1}"
  fi
  set -e
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  local _method_name="${1:-}"
  local var="_${_ME}_desc_${_method_name}"
  if [[ -n ${!var:-} ]]
  then
    printf "%s\n" "${!var}"
  else
    printf "No additional information for \`%s\`\n" "${_method_name}"
  fi
}

###############################################################################
# Subcommands
###############################################################################

# add #########################################################################

desc "add" <<HEREDOC
Usage:
  $_ME add [<note>] [--type <type>]

Options:
  --type  The file extension for the note file type [default: 'md'].

Description:
  Create a new note. Any arguments passed to \`add\` are written to the note
  file. When no arguments are passed, a new note file is opened with
  \`\$EDITOR\`, currently set to '$EDITOR'.

Examples:
  notes add
  notes add "Note content."
  echo "Note content." | notes add
HEREDOC
_add() {
  local _file_type="${NOTES_DEFAULT_EXTENSION}"
  local _arguments=()

  # Parse function options.
  while (($#))
  do
    # __option_value_is_present()
    #
    # Usage:
    #   __option_value_is_present "${variable}"
    #
    # Returns:
    #   0  The argument is blank or matches as an option flag.
    #   1  The argument is present and does not match an option flag.
    __option_value_is_present() {
      [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
    }
    local _arg="${1:-}"
    local _val="${2:-}"
    case "$_arg" in
      -t|--type)
        if __option_value_is_present "${_val:-}"
        then
          _file_type="${_val:-}"
          shift
        else
          _die "${_ME}" help add
        fi
        ;;
      *)
        _arguments+=("${_arg:-}")
        ;;
    esac
    shift
  done

  # Assign filename with unicode timestamp.
  local _basename
  _basename="$(date -u "+%Y%m%d%H%M%S").${_file_type}"
  local _filename
  _filename="${NOTES_DATA_DIR}/${_basename}"

  if _interactive_input
  then # terminal input.
    if [[ -z "${_arguments[*]:-}" ]]
    then # argument array is blank.
      eval "${EDITOR}" "${_filename}"
    else
      printf "%s\n" "${_arguments[*]:-}" >> "${_filename}"
    fi
  else # piped input.
    cat >> "${_filename}"
  fi
  _git_checkpoint "[NOTES] Add: ${_basename}"
}

# count #######################################################################

desc "count" <<HEREDOC
Usage:
  $_ME count

Description:
  Print the number of notes files in the current notebook.
HEREDOC
_count() {
  _list_notes_files | wc -l
}

# delete ######################################################################

desc "delete" <<HEREDOC
Usage:
  $_ME delete <index>
  $_ME delete <filename>
  $_ME delete <path>
  $_ME delete <title>

Description:
  Delete a note.
HEREDOC
_delete() {
  local _selection="${1:-}"
  local _basename=

  _debug printf "_delete() \$_selection: '%s'\n" "${_selection}"

  _basename="$(_get_selection_basename "${_selection}")"
  NOTES_DATA_DIR="$(_get_selection_notebook "${_selection}")"
  if [[ -z "${_basename}" ]]
  then
    $_ME help "delete"
    return 1
  fi
  _debug printf "_delete() \$_basename: '%s'\n" "${_basename}"

  if [[ -n "$_basename" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    cd "${NOTES_DATA_DIR}" || _die printf "_delete() \`cd\` failed.\n"
    git rm "${_basename}"
    _git_checkpoint "[NOTES] Delete: ${_basename}"
  else
    _die printf "Selection not found.\n"
  fi
}

# edit ########################################################################

desc "edit" <<HEREDOC
Usage:
  $_ME edit <index>
  $_ME edit <filename>
  $_ME edit <path>
  $_ME edit <title>

Description:
  Open the specified note in \`\$EDITOR\`, currently set to '$EDITOR'.
HEREDOC
_edit() {
  local _selection="${1:-}"
  local _basename=

  _debug printf "_edit() \$_selection: %s\n" "${_selection}"

  _basename="$(_get_selection_basename "${_selection}")"
  NOTES_DATA_DIR="$(_get_selection_notebook "${_selection}")"
  if [[ -z "${_basename}" ]]
  then
    $_ME help "edit"
    return 1
  fi
  _debug printf "_edit() \$_basename: '%s'\n" "${_basename}"

  if [[ -n "$_basename" ]] || [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # _basename is assigned and a note exists with that name.
    eval "$EDITOR" "${NOTES_DATA_DIR}/${_basename}"
    _git_checkpoint "[NOTES] Edit: ${_basename}"
  else
    _die printf "Selection not found.\n"
  fi
}

# env #############################################@###########################

desc "env" <<HEREDOC
Usage:
  $_ME env

Description:
  Print program environment variables.
HEREDOC
_env() {
  printf "NOTES_DIR=%s\n" "$NOTES_DIR"
  printf "NOTES_DATA_DIR=%s\n" "$NOTES_DATA_DIR"
  printf "NOTES_AUTO_SYNC=%s\n" "$NOTES_AUTO_SYNC"
  printf "NOTESRC_PATH=%s\n" "$NOTESRC_PATH"
}

# git #############################################@###########################

desc "git" <<HEREDOC
Usage:
  $_ME git <arguments>

Description:
  Alias for \`git\`, with commands run in \`\$NOTES_DATA_DIR\`.
HEREDOC
_git() {
  cd "${NOTES_DATA_DIR}" || _die printf "_git() \`cd\` failed.\n"
  git "${@}"
}

# help ########################################################################

desc "help" <<HEREDOC
Usage:
  $_ME help [<subcommand>]

Description:
  Print the program help information. When a subcommand name is passed, the
  print the help information for the subcommand.
HEREDOC
_help() {
  if [[ -z "${1:-}" ]]
  then
    cat <<HEREDOC
             _
 _ __   ___ | |_ ___  ___
| '_ \ / _ \| __/ _ \/ __|
| | | | (_) | ||  __/\__ \\
|_| |_|\___/ \__\___||___/

Usage:
  $_ME [<number>] [<list options>]
  $_ME add [<note>] [--type <type>]
  $_ME count
  $_ME delete (<index> | <filename> | <path> | <title>)
  $_ME edit (<index> | <filename> | <path> | <title>)
  $_ME history [<selection>]
  $_ME init [<remote-url>]
  $_ME list [(-e | --excerpt) [<length>]] [--noindex] [-n <limit>] [<selection>]
  $_ME ls [<list options>]
  $_ME notebook
  $_ME notebook add <name> [<remote-url>]
  $_ME notebook list [<name>] [--names]
  $_ME notebook rename <old-name> <new-name>
  $_ME notebook use <name>
  $_ME search <query> [-a | --all] [--path]
  $_ME show (<index> | <filename> | <path> | <title>)
  $_ME show <selection> ([--index] | [--path] | [---render]) [--dump [--raw]]
  $_ME sync [-a|--all]
  $_ME -h | --help | help [<subcommand>]
  $_ME --version | version

Help:
  $_ME help [<subcommand>]

Subcommands:
  (default)  List notes. This is an alias for \`$_ME ls\`.
  add        Add a new note.
  count      Print the number of notes.
  delete     Delete a note.
  edit       Edit a note.
  env        Print program environment variables.
  help       Display this help information.
  history    Display git history for the current notebook or a note.
  init       Initialize the first notebook.
  list       List all notes.
  ls         Shortcut for \`list --titles\`.
  notebook   Manage notebooks.
  search     Search notes.
  show       Show a note.
  status     Run \`git status\` in \`\$NOTES_DATA_DIR\`.
  sync       Sync local notebook with the remote repository.
  version    Display version information.

Program Options:
  -h --help              Display this help information.
  --version              Display version information.
HEREDOC
  else
    _print_desc "${@}"
  fi
}

# history #####################################################################

desc "history" <<HEREDOC
Usage:
  $_ME history [<selection>]

Description:
  Display git history using \`tig\` [1] (if available) or \`git log\`. When a
  <selection> is specified, the history for that note is displayed.

  1. https://github.com/jonas/tig
HEREDOC
_history() {
  cd "${NOTES_DATA_DIR}" || _die printf "_history() \`cd\` failed.\n"

  local _log_command="git log"
  if _command_exists "tig"
  then # tig <https://github.com/jonas/tig> is present.
    _log_command="tig --all"
  fi

  local _selection="${1:-}"
  _debug printf "_history() \$_selection: '%s'\n" "${_selection}"

  local _basename=
  _basename="$(_get_selection_basename "${_selection}")"
  NOTES_DATA_DIR="$(_get_selection_notebook "${_selection}")"
  _debug printf "_history() \$_basename: '%s'\n" "${_basename}"

  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    eval "${_log_command} -- ${_basename}"
  else
    eval "${_log_command}"
  fi
}

# init ########################################################################

desc "init" <<HEREDOC
Usage:
  $_ME init [<remote-url>]

Description:
  Initialize the local data directory and generate a ~/.notesrc configruation
  file if it doesn't exist.
HEREDOC
_init() {
  if [[ -e "${NOTES_DIR}" ]] && [[ ! -d "${NOTES_DIR}" ]]
  then
    _die \
      printf "\`init\`: %s already exists and is not a directory.\n"
      "${NOTES_DIR}"
  elif [[ -e "${NOTES_DATA_DIR}" ]]
  then
    _die \
      printf "\`init\`: %s already exists.\n" \
      "${NOTES_DATA_DIR}"
  fi

  if [[ ! -e "${NOTESRC_PATH}" ]]
  then
    cat <<HEREDOC > "${NOTESRC_PATH}"
###############################################################################
# .notesrc
#
# Configuration file for notes
#
# https://github.com/alphabetum/notes
###############################################################################

# $NOTES_AUTO_SYNC
#
# Default: 1
#
# By default, operations that trigger a git commit like `add`, `edit`,
# and `delete` will also sync notebook changes to the remote repository, if
# one is set.
#
# To disable this behavior, uncomment the following line.
# export NOTES_AUTO_SYNC=0

# $NOTES_DIR
#
# Default: "$HOME/.notes"
#
# The location of the notes directory that contains the notebooks.
# export NOTES_DIR="$HOME/.notes"

# $NOTES_DEFAULT_EXTENSION
#
# Default: 'md'
#
# Example Values: 'md' 'org'
# export NOTES_DEFAULT_EXTENSION="${NOTES_DEFAULT_EXTENSION:-md}"
HEREDOC
  fi

  local _repo_url="${1:-}"
  if [[ -n "${_repo_url}" ]]
  then
    git clone "${_repo_url}" "${NOTES_DATA_DIR}"
  else
    mkdir -p "${NOTES_DATA_DIR}"
    cd "${NOTES_DATA_DIR}" && git init
  fi
  printf "home\n" > "${NOTES_DIR}/.current"
}

# list ########################################################################

desc "list" <<HEREDOC
Usage:
  $_ME list [(-e | --excerpt) [<length>]] [--noindex] [-n <limit>] [<selection>]

Options:
  -e --excerpt <length>  Print an excerpt <length> lines long under each
                         note's filename [default: 3].
  --noindex              Don't print an index next to each note's filename.
  -n <limit>             The maximum number of notes to list.

Description:
  List all notes.

  If Pygments [1] and the Markdown lexer [2] are installed, excerpts are
  printed with syntax highlighting.

  1. http://pygments.org/
  2. https://github.com/jhermann/pygments-markdown-lexer

Examples:
  $_ME list
  $_ME list -e 10
  $_ME list --excerpt --noindex
HEREDOC
_list() {
  _debug printf "_list() \$1: '%s'\n" "${1:-}"
  _debug printf "_list() \$2: '%s'\n" "${2:-}"
  _debug printf "_list() \$3: '%s'\n" "${3:-}"

  local _print_excerpt=0
  local _excerpt_length=3
  local _no_index=0
  local _no_color=0
  local _list_titles=0
  local _limit
  local _selection

  _debug printf "_list() \$@: '%s'\n" "${@:-}"

  # Parse function options.
  while (($#))
  do
    # __option_value_is_present()
    #
    # Usage:
    #   __option_value_is_present "${variable}"
    #
    # Returns:
    #   0  The argument is blank or matches as an option flag.
    #   1  The argument is present and does not match an option flag.
    __option_value_is_present() {
      [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
    }
    local _arg="${1:-}"
    local _val="${2:-}"
    case "$_arg" in
      -e|--excerpt)
        _print_excerpt=1
        if __option_value_is_present "${_val:-}"
        then
          _excerpt_length="${_val:-}"
          shift
        fi
        ;;
      --noindex|--no-index)
        _no_index=1
        ;;
      --nocolor|--no-color)
        _no_color=1
        ;;
      -n)
        if __option_value_is_present "${_val:-}"
        then
          _limit="${_val:-}"
          shift
        fi
        ;;
      --titles)
        _list_titles=1
        ;;
      *)
        _debug printf "_list() *: '%s'\n" "${_arg:-}"
        _selection="${_arg:-}"
        ;;
    esac
    shift
  done

  _debug printf "_list() \$_print_excerpt: '%s'\n" "${_print_excerpt:-}"
  _debug printf "_list() \$_excerpt_length: '%s'\n" "${_excerpt_length:-}"

  local _selection_basename=
  if [[ -n "${_selection:-}" ]]
  then
    _selection_basename="$(_get_selection_basename "${_selection}")"
    NOTES_DATA_DIR="$(_get_selection_notebook "${_selection}")"
  fi

  local _filenames
  _filenames=($(_list_notes_files))
  local _filenames_count="${#_filenames[@]:-}"

  _debug printf "list() \${_filenames_count}: '%s'\n" "${_filenames_count[@]}"

  if [[ "${_filenames_count}" -eq 0 ]]
  then # no files in `$NOTES_DATA_DIR`
    cat <<HEREDOC
0 notes.

Add a note:
  $_ME add
Usage information:
  $_ME help
HEREDOC
    return 1
  else
    local _counter=0
    for _basename in "${_filenames[@]}"
    do
      if [[ -n "${_limit:-}" ]] && [[ "${_counter}" -eq "${_limit}" ]]
      then # the limit has been reached.

        _debug printf "list() \${#_limit}: '%s'\n" "${#_limit}"
        _debug printf "list() \${#_counter}: '%s'\n" "${#_counter}"

        local _difference
        _difference=$((_filenames_count-_counter))
        printf "%s omitted. %s total.\n" "${_difference}" "${_filenames_count}"
        break
      fi

      # NOTE: Plain version serves as the reference version and can be used
      # for length calculations.
      local _counter_item="[${_counter}]"
      local _counter_item_color
      _counter_item_color="[$(_highlight "${_counter}")]"
      _counter=$((_counter+1))

      # If a valid <selection> has been specified, skip the rest of the loop
      # unless the <selection> basename matches the current one.
      if [[ -n "${_selection_basename}" ]] &&
         [[ "${_basename}" != "${_selection_basename}" ]]
      then
        continue
      fi

      local _list_item_id="${_basename}"
      local _maybe_title
      if ((_list_titles))
      then
        _maybe_title="$(_get_title "${_basename}")"
        if [[ -n "${_maybe_title}" ]]
        then # note file has title.
          _list_item_id="${_maybe_title}"
        fi
      fi

      # Use calculated number of spaces for nicer formatting.
      local _spaces=''
      local _spaces_length=1
      # Avoid error when `$((5-5))` returns `1`.
      if [[ "${_counter}" -le 100 ]]
      then
        _spaces_length=$((5-${#_counter_item}))
      fi
      printf -v _spaces '%*s' "${_spaces_length}"

      local _list_item="${_counter_item}${_spaces}${_list_item_id}"
      local _list_item_color="${_counter_item_color}${_spaces}${_list_item_id}"

      if ((_no_index))
      then
        printf "%s\n" "${_list_item_id}"
      else
        if ((_no_color))
        then
          printf "%s\n" "${_list_item}"
        else
          printf "%s\n" "${_list_item_color}"
        fi
      fi

      if ((_print_excerpt)) && [[ "${_excerpt_length}" =~ ^[1-9] ]]
      then # excerpt is specified with a non-zero digit, as required by `head`.
        _print_line "${_list_item}"
        head -"${_excerpt_length}" "${NOTES_DATA_DIR}/${_basename}"
        printf "\n"
      fi
    done
  fi
}

# ls ##########################################################################

desc "ls" <<HEREDOC
Usage:
  $_ME ls [<list options>]

Description:
  Shortcut for \`list --titles\`. Any options are passed through to \`list\`.
HEREDOC
_ls() {
  _debug printf "_ls() \$@: '%s'\n" "${@:-}"

  _list --titles "${@}"
}

# notebook ####################################################################

desc "notebook" <<HEREDOC
Usage:
  $_ME notebook
  $_ME notebook add <name> [<remote-url>]
  $_ME notebook list [<name>] [--names]
  $_ME notebook rename <old-name> <new-name>
  $_ME notebook use <name>
HEREDOC
# TODO: Add description.
_notebook() {
  # _notebook_add()
  #
  # Usage:
  #   _notebook_add <name> [<remote_url>]
  _notebook_add() {
    local _name="${1:-}"
    if [[ -z "${_name}" ]]
    then
      _die "${_ME}" help notebook
    fi

    if [[ -e "${NOTES_DIR}/${_name}" ]]
    then
      _die printf "Already exists: ${_name}\n"
    fi

    local _repo_url="${2:-}"
    if [[ -n "${_repo_url}" ]]
    then
      git clone "${_repo_url}" "${NOTES_DIR}/${_name}"
      printf "%s\n" "${_name}" > "${NOTES_DIR}/.current"
    else
      mkdir -p "${NOTES_DIR}/${_name}"
      cd "${NOTES_DIR}/${_name}" && git init
    fi
    printf "Added: %s\n" "${_name}"
  }
  # _notebook_list()
  #
  # Usage:
  #   _notebook_list [<name>] [--names]
  _notebook_list() {
    local _files=()
    local _only_names=0

    _debug printf "_notebook_list() \$@: '%s'\n" "${@:-}"
    _debug printf "_notebook_list() \${@:1}: '%s'\n" "${@:1}"

    for _arg in "${@:1}"
    do
      case "${_arg}" in
        --names)
          _only_names=1
          ;;
        *)
          _files+=("${_arg}")
          ;;
      esac
    done

    if [[ -z "${_files[*]:-}" ]]
    then
      _files=($(ls -1 "${NOTES_DIR}"))
    fi

    _debug printf "_notebook_list() \$_only_names: '%s'\n" "${_only_names:-}"
    _debug printf "_notebook_list() \${_files[*]}: '%s'\n" "${_files[*]:-}"

    for _item in "${_files[@]}"
    do
      if [[ -e "${NOTES_DIR}/${_item}/.git" ]]
      then # it's a git repository.
        if ((_only_names))
        then
          printf "%s\n" "${_item}"
        else
          local _current
          _current="$(cat "${NOTES_DIR}/.current")"
          local _formatted_name
          local _origin_url

          if [[ -n "${_current}" ]] &&
             [[ "${_current}" == "${_item}" ]]
          then # it's the current repository.
            _formatted_name="$(_highlight "${_item}")"
          else
            _formatted_name="${_item}"
          fi

          cd "${NOTES_DIR}/${_item}" || \
            _die printf "_notebook() \`cd\` failed."
          _origin_url="$(git config --get remote.origin.url || echo '')"

          if [[ -n "${_origin_url}" ]]
          then
            printf "%s\n" "${_formatted_name}	(${_origin_url})"
          else
            printf "%s\n" "${_formatted_name}"
          fi
        fi
      fi
    done
  }
  # _notebook_rename()
  #
  # Usage:
  #   _notebook_rename <old> <new>
  _notebook_rename() {
    local _old="${1:-}"
    local _new="${2:-}"

    if [[ -z "${_old}" ]] || [[ -z "${_old}" ]]
    then
      _die "${_ME}" help notebook
    elif [[ ! -d "${NOTES_DIR}/${_old}" ]]
    then
      _die printf "'${_old}' is not a valid notebook name.\n"
    elif [[ -e "${NOTES_DIR}/${_new}" ]]
    then
      _die printf "A notebook named '${_new}' already exists.\n"
    fi

    mv "${NOTES_DIR}/${_old}" "${NOTES_DIR}/${_new}"

    if [[ "$(cat "${NOTES_DIR}/.current")" == "${_old}" ]]
    then
      printf "%s\n" "${_new}" > "${NOTES_DIR}/.current"
    fi

    printf "'%s' is now named '%s'\n" "${_old}" "${_new}"
  }

  local _subcommand="${1:-}"
  local _name="${2:-}"

  case "${_subcommand}" in
    add)
      _notebook_add "${_name:-}" "${3:-}"
      ;;
    list)
      _notebook_list "${@:2}"
      ;;
    rename)
      _notebook_rename "${_name:-}" "${3:-}"
      ;;
    use)
      if [[ -z "${_name}" ]]
      then
        _die "${_ME}" help notebook
      fi

      if [[ -d "${NOTES_DIR}/${_name}/.git" ]]
      then
        printf "%s\n" "${_name}" > "${NOTES_DIR}/.current"
        printf "Now using %s.\n" "$( _highlight "${_name}")"
      else
        _die printf "Not found: ${_name}\n"
      fi
      ;;
    *)
      basename "${NOTES_DATA_DIR}"
      ;;
  esac
}
_nb()   { _notebook "${@}"; }
_book() { _notebook "${@}"; }

# notebooks ###################################################################

desc "notebooks" <<HEREDOC
Usage:
  $_ME notebooks [--names]
HEREDOC
# TODO: Add description.
_notebooks() {
  _notebook list "${@}"
}
_nbs()    { _notebooks "${@}"; }
_books()  { _notebooks "${@}"; }

# search ######################################################################

desc "search" <<HEREDOC
Usage:
  $_ME search <query> [-a | --all] [--path]

Options:
  -a --all  Search all notebooks.
  --path    Print the full path for each file with query matches.

Description:
  Search notes using \`ack\` [1] (if available) or \`grep\`.

  1. http://beyondgrep.com/
HEREDOC
_search() {
  local _all=0
  local _arguments=("${@:1}")
  local _query=
  local _print_paths=0
  local _last_path=

  for _arg in "${_arguments[@]:-}"
  do
    case "${_arg}" in
      -a|--all)
        _all=1
        ;;
      --path)
        _print_paths=1
        ;;
      *)
        if [[ -z "${_query}" ]]
        then
          _query="${_arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_query:-}" ]]
  then
    $_ME help "search"
    return 1
  else
    local _target_notebooks=()

    if ((_all))
    then
      _target_notebooks=($($_ME notebooks --names))
    else
      _target_notebooks=($(_notebook))
    fi

    _debug printf \
      "_search() \$_target_notebooks: '%s'\n" \
      "${_target_notebooks[*]}"

    for _scope in "${_target_notebooks[@]:-}"
    do
      local _files=
      _files=($($_ME "${_scope}:list" --noindex || printf ''))

      _debug printf "_search() \$_scope: '%s'\n" "${_scope}"
      # _debug printf "_search() \$_files: '%s'\n" "${_files[*]}"

      if _command_exists "ack"
      then # ack is available.
        ack "${_query}" "${NOTES_DIR}/${_scope}" \
          --ignore-case \
          --noheading \
          --color-lineno='bold green' \
          --color-match='black on_blue' \
            || return 0 # Don't fail out within a single scope.
      else # fall back to POSIX grep.
        # Add /dev/null so file path is printed even if there is only one
        # matching file. Reference: http://stackoverflow.com/a/15432718
        grep \
          --ignore-case \
          -n "${_query}" "${NOTES_DIR}/${_scope}"/* /dev/null \
            || return 0 # Don't fail out within a single scope.
      fi | while read -r _line
      do
        local _path=
        local _filename=
        local _index=
        # Define `_indexed_filename` with and without color to have a version
        # without the additional length from `tput` calls.
        local _indexed_filename=
        local _indexed_filename_color=
        local _hit=

        # Use `sed` to remove color from output.
        # http://unix.stackexchange.com/a/140255
        _path="$(
          printf "%s\n" "${_line}" \
            | cut -d: -f 1 \
            | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g"
        )"

        if ((_print_paths))
        then
          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf "%s\n" "${_path}"
          fi
        else
          _filename="$(basename "${_path}")"
          _index="$(_get_index "${_filename}" "${_files[@]}")"

          if ((_all))
          then
            _indexed_filename_color="[$(_highlight "${_scope}:${_index}")] ${_filename}"
            _indexed_filename="[${_scope}:${_index}] ${_filename}"
          else
            _indexed_filename_color="[$(_highlight "${_index}")] ${_filename}"
            _indexed_filename="[${_index}] ${_filename}"
          fi

          # printf "_search() \$_index: '%s'\n" "${_index}"
          # printf "_search() \$_last_path: '%s'\n" "${_last_path}"
          # printf "_search() \$_path: '%s'\n" "${_path}"

          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf "%s\n" "${_indexed_filename_color}"
            _print_line "${_indexed_filename}"
          fi

          _hit="$(printf "%s\n" "${_line}" | cut -d: -f 2-)"
          printf "%s\n\n" "${_hit}"
        fi

        _last_path="${_path}"
      done
    done | if read -r _line
    then # output is present
      # Print the test line then `cat` the rest.
      printf "%s\n" "${_line}"
      cat
      return 0
    else
      return 1
    fi
  fi
}

# show ########################################################################

desc "show" <<HEREDOC
Usage:
  $_ME show (<index> | <filename> | <path> | <title>)
  $_ME show <selection> ([--index] | [--path] | [---render]) [--dump [--raw]]

Options:
  --dump    Print to standard output.
  --index   Print the index number of the note file.
  --path    Print the full path of the note file.
  --raw     When used with \`--dump\`, the note is printed without highlighting.
  --render  Use \`pandoc\` [1] to render the file to HTML and display with
            \`lynx\` [2] (if available) or \`w3m\` [3]. If \`pandoc\` is not
            available, \`--render\` is ignored.

            1. http://pandoc.org/
            2. https://en.wikipedia.org/wiki/Lynx_(web_browser)
            3. https://en.wikipedia.org/wiki/W3m

Description:
  Show a note.

  If Pygments [1] and the Markdown lexer [2] are installed, the note file is
  displayed with syntax highlighting.

  1. http://pygments.org/
  2. https://github.com/jhermann/pygments-markdown-lexer
HEREDOC
_show() {
  _debug printf "_show() \$0: '%s'\n" "${0:-}"
  _debug printf "_show() \$1: '%s'\n" "${1:-}"
  _debug printf "_show() \$2: '%s'\n" "${2:-}"

  local -a _arguments=("${@:1}")
  local _selection=
  local _basename=
  local _render=0
  local _dump=0
  local _print_path=0
  local _print_index=0
  local _print_raw=0

  _debug printf "_show() \$_arguments[*]: '%s'\n" "${_arguments[*]:-}"

  for _arg in "${_arguments[@]:-}"
  do
    case "${_arg}" in
      --dump)
        _dump=1
        ;;
      --path)
        _print_path=1
        ;;
      --index)
        _print_index=1
        ;;
      --raw)
        _print_raw=1
        ;;
      --render)
        _render=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${_arg}"
        fi
        ;;
    esac
  done

  _debug printf "_show() \$_render: '%s'\n" "${_render}"
  _debug printf "_show() \$_selection: '%s'\n" "${_selection}"

  _basename="$(_get_selection_basename "${_selection}")"
  NOTES_DATA_DIR="$(_get_selection_notebook "${_selection}")"
  if [[ -z "${_basename}" ]]
  then
    $_ME help "show"
    return 1
  fi
  _debug printf "_show() \$_basename: '%s'\n" "${_basename}"

  # Display file.
  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # _basename is assigned and a note exists with that name.
    if ((_print_path))
    then # `notes show --path`
      printf "%s/%s\n" "${NOTES_DATA_DIR}" "${_basename}"
    elif ((_print_index))
    then
      local _index
      _index="$(_get_index "${_basename}" "$(notes list --noindex)")"
      printf "%s\n" "${_index}"
    elif ((_render)) &&
         ((_dump))   &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render --dump` with `pandoc` and `w3m` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" \
        | w3m -dump -T text/html
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "lynx"
    then # `notes show --render` with `pandoc` and `lynx` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" | lynx -stdin
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render` with `pandoc` and `w3m` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" \
        | w3m -dump -T text/html \
        | "${PAGER}"
    else # default
      if ((_dump))
      then # `notes show --dump [--raw]`
        if ((_print_raw))
        then # `notes show --dump --raw`
          cat "${NOTES_DATA_DIR}/${_basename}"
        else # `notes show --dump`
          _highlight_syntax_if_available "${NOTES_DATA_DIR}/${_basename}"
        fi
      else # `notes show`
        _highlight_syntax_if_available "${NOTES_DATA_DIR}/${_basename}" \
          | "$PAGER"
      fi
    fi
  else # _basename is not assigned or no note exists with that name.
    _die printf "Selection not found.\n"
  fi
}

# status ######################################################################

desc "status" <<HEREDOC
Usage:
  $_ME status

Description:
  Run \`git status\` in \`\$NOTES_DATA_DIR\`.
HEREDOC
_status() {
  cd "${NOTES_DATA_DIR}" || _die printf "_status() \`cd\` failed.\n"
  git status
}

# sync ########################################################################

desc "sync" <<HEREDOC
Usage:
  $_ME sync [-a|--all]

Options:
  -a --all  Sync all notebooks.

Description:
  Sync the current local notebook with the remote repository.
HEREDOC
_sync() {
  local _notebooks

  _debug printf "_sync() \$*: '%s'\n" "${*}"

  if [[ -n "${1:-}" ]] && [[ "${1}" =~ ^-a|--all$ ]]
  then
    _debug printf "_sync() -a|--all\n"
    _notebooks=($($_ME notebooks --names))
  else
    _notebooks=($(_notebook))
  fi

  _debug printf "_sync() \${_notebooks[*]}: '%s'\n" "${_notebooks[*]:-}"

  printf "Syncing: "
  for __notebook in "${_notebooks[@]:-}"
  do
    printf "%s..." "${__notebook}"
    NOTES_DATA_DIR="${NOTES_DIR}/${__notebook}"
    (NOTES_AUTO_SYNC=1 _git_checkpoint "[NOTES] Sync" --spinner)
  done &&
    printf "Done!\n" ||
    printf "Syncing failed!\n"
}

# use #########################################################################

desc "use" <<HEREDOC
Usage:
  $_ME use <name>
HEREDOC
# TODO: Add description.
_use() {
  local _name="${1:-}"
  if [[ -z "${_name}" ]]
  then
    _die "${_ME}" help use
  fi
  _notebook use "${_name}"
}

# version ####################################################################

desc "version" <<HEREDOC
Usage:
  $_ME version

Description:
  Display version information.
HEREDOC
_version() {
  printf "%s\n" "$_VERSION"
}

###############################################################################
# _notes()
###############################################################################

# _notes()
#
# Description:
#   Call the appropriate subcommand.
_notes() {
  _debug printf "_notes() >> start\n"
  _debug printf "_notes() \${_ARGUMENTS[@]:1}: '%s'\n" "${_ARGUMENTS[@]:1}"
  _debug printf "_notes() \${_SUBCOMMAND}: '%s'\n" "${_SUBCOMMAND}"

  # Set `$_SUBCOMMAND` if it's still blank.
  if [[ -z "${_SUBCOMMAND:-}" ]]
  then
    _SUBCOMMAND="ls"
  fi

  if [[ -n "${_SCOPE}" ]]
  then
    NOTES_DATA_DIR="${NOTES_DIR}/${_SCOPE}"
  fi

  case "$_SUBCOMMAND" in
    init|sync)
      _git_required
      "_${_SUBCOMMAND}" "${_ARGUMENTS[@]:1}"
      ;;
    env|help|version)
      "_${_SUBCOMMAND}" "${_ARGUMENTS[@]:1}"
      ;;
    *)
      _git_required

      # Call `_init()` if configuration hasn't been initialized.
      if [[ ! -e "${NOTES_DIR}" ]] && [[ ! -e "${NOTESRC_PATH}" ]]
      then
        _git_required
        _init '' &>/dev/null
      fi

      if [[ ! -e "${NOTES_DATA_DIR}" ]]
      then # `$NOTES_DATA_DIR` doesn't exist.
        _die cat <<HEREDOC
$NOTES_DATA_DIR doesn't exist. Use \`$_ME init\` to get started.
Usage: $_ME init [<remote url>]
HEREDOC
      fi

      local _core_subcommands=(
        add
        book
        books
        count
        delete
        edit
        list
        ls
        nb
        nbs
        notebook
        notebooks
        show
        search
        use
      )
      local _core_subcommand_pattern
      _core_subcommand_pattern="@($(_join '|' "${_core_subcommands[@]}"))"

      if [[ "${_SUBCOMMAND}" =~ ${_core_subcommand_pattern} ]]
      then
        if _git_index_is_dirty
        then
          if _git_should_autosync
          then
            _debug \
              printf "_notes(): _git_index_is_dirty && ((NOTES_AUTO_SYNC))\n"
            $_ME sync
          else
            _debug \
              printf "_notes(): _git_index_is_dirty && ! ((NOTES_AUTO_SYNC))\n"
            _git_checkpoint "[NOTES] Commit" --spinner
          fi
        elif _git_should_autosync
        then
          _debug \
            printf "_notes(): ! _git_index_is_dirty\n"
          ($_ME sync &>/dev/null) &
        fi
      fi

      "_${_SUBCOMMAND}" "${_ARGUMENTS[@]:1}"
      ;;
  esac
}

###############################################################################
# Program Option Parsing
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring='h'

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while (($#))
do
  case "${1}" in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c="${1:i:1}"
        # add current char to options
        options+=("-${c}")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ "${optstring}" = *"${c}:"* && "${1:i+1}" ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_SCOPE=
_ARGUMENTS=("${0}")

# $_SUBCOMMANDS
#
# All available subcommands.
_SUBCOMMANDS=(
  add
  book
  books
  count
  delete
  edit
  env
  git
  help
  history
  init
  list
  ls
  nb
  nbs
  notebook
  notebooks
  search
  show
  status
  sync
  use
  version
)

# $_SUBCOMMANDS_PATTERN
#
# The contents of the `$_SUBCOMMANDS` array, joined with '|', with the
# `@(<pattern list>)` pattern matching operator, which matches one of the
# given patterns. This operator is enabled using `shopt -s extglob`.
#
# More information:
# http://stackoverflow.com/a/13254908
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
_SUBCOMMANDS_PATTERN="@($(_join '|' "${_SUBCOMMANDS[@]}"))"

_debug printf "\$_SUBCOMMANDS_PATTERN: %s\n" "${_SUBCOMMANDS_PATTERN}"

# _is_valid_subcommand()
#
# Usage:
#   _is_valid_subcommand <name>
#
# Returns:
#   0  If the given <name> is a valid subcommand name.
#   1  If not.
_is_valid_subcommand() {
  case "${1:-}" in
    ${_SUBCOMMANDS_PATTERN})
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# _require_argument()
#
# Usage:
#   _require_argument <option> <argument>
#
# If <argument> is blank or another option, print an error message and  exit
# with status 1.
_require_argument() {
  local _option="${1:-}"
  local _value="${2:-}"

  if [[ -z "${_value}" ]] || [[ "${_value}" =~ ^- ]]
  then
    _die printf "Option requires an argument: %s\n" "${_option}"
  fi
}

# getopts and getopts have inconsistent behavior, so using a simple home-brewed
# while loop. This isn't perfectly compliant with POSIX, but it's close enough
# and this appears to be a widely used approach.
#
# More info:
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
while (($#))
do
  __opt="${1}"
  shift
  case "${__opt}" in
    -h|--help)
      _PRINT_HELP=1
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      _PRINT_VERSION=1
      ;;
    *:*)
      __parts=($(printf "%s\n" "${__opt}" | tr ":" "\n"))
      if [[ -z "${_SCOPE:-}"       ]] &&
         [[ -z "${_SUBCOMMAND:-}"  ]] &&
         [[ "${#__parts[@]}" -gt 0  ]]
      then
        if [[ -d "${NOTES_DIR}/${__parts[0]}" ]]
        then
          _SCOPE="${__parts[0]}"
          if _is_valid_subcommand "${__parts[1]:-}"
          then
            _SUBCOMMAND="${__parts[1]:-}"
          fi
        else
          _die printf "Notebook not found: %s\n" "${__parts[0]}"
        fi
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
    --endopts)
      # Terminate option parsing.
      break
      ;;
    *)
      if [[ -z "${_SUBCOMMAND:-}" ]] && _is_valid_subcommand "${__opt}"
      then
        _SUBCOMMAND="${__opt}"
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
  esac
done

_debug printf "\$_SUBCOMMANDS[*]: '%s'\n" "${_SUBCOMMANDS[*]}"
_debug printf "\$_SUBCOMMANDS_PATTERN: '%s'\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\$_SUBCOMMAND: '%s'\n" "${_SUBCOMMAND}"
_debug printf "\$_SCOPE: '%s'\n" "${_SCOPE}"
_debug printf "\$_ARGUMENTS: '%s'\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# _main()
###############################################################################

# _main()
#
# Usage:
#   _main "$@"
#
# Describe:
#   Primary entry point for the program logic. Call this function at the end
#   of the script after everything has been defined.
_main() {
  if (("$_PRINT_HELP"))
  then
    _help "${_SUBCOMMAND:-}"
  elif (("$_PRINT_VERSION"))
  then
    _version
  else
    _notes "${_ARGUMENTS[@]:-}"
  fi
}

_main "$@"
