#!/usr/bin/env bash
###############################################################################
# __          _
# \ \   _ __ | |__
#  \ \ | '_ \| '_ \
#  / / | | | | |_) |
# /_/  |_| |_|_.__/
#
# `nb` Â·Â `notes` && `bookmark`
#
# Command line note-taking, bookmarking, and archiving with encryption, search,
# Git-backed versioning and syncing, Pandoc-backed format conversion, and more
# in a single portable script.
#
# https://github.com/xwmx/nb
#
# Based on Bash Boilerplate: https://github.com/xwmx/bash-boilerplate
#
# Copyright (c) 2015-present William Melody â€¢ hi@williammelody.com
# AGPLv3 â€¢ See LICENSE for details.
###############################################################################

###############################################################################
# Strict Mode
#
# More Information:
#   https://github.com/xwmx/bash-boilerplate#bash-strict-mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
set -o noglob
IFS=$'\n\t'

###############################################################################
# Environment
###############################################################################

# $_VERSION
#
# The most recent program version.
_VERSION="4.1.3"

# $_ME
#
# This program's basename.
_ME="$(basename "${0}")"

# $_MY_DIR
#
# The directory containing $_ME
_MY_DIR=$(cd "$(dirname "$0")"; pwd)

# $_MY_PATH
#
# This program's full path.
_MY_PATH="${_MY_DIR}/${_ME}"

# $_CURRENT_WORKING_DIR
#
# The current working directory in which the program was invoked.
_CURRENT_WORKING_DIR="${PWD}"

# extglob
#
# Enable extended pattern matching operators.
#
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
shopt -s extglob

# $_SED_I_COMMAND
#
# `sed -i` takes an extension on macOS, but that extension can cause errors in
# GNU `sed`.
#
# NOTE: To use this command, call it with `"${_SED_I_COMMAND[@]}"`
#
# https://stackoverflow.com/q/43171648
# http://stackoverflow.com/a/16746032
if sed --help >/dev/null 2>&1
then # GNU
  export _SED_I_COMMAND=(sed -i)
else # macOS
  export _SED_I_COMMAND=(sed -i '')
fi

# $_REPO
#
# The <user>/<repo> identifier for the git repository.
_REPO="xwmx/nb"

# $_REPO_RAW_URL
#
# The base URL for raw files.
_REPO_RAW_URL="https://raw.githubusercontent.com/${_REPO}/master"

###############################################################################
# Configuration File
###############################################################################

# .nbrc
#
# If a `.nbrc` file exists in `$HOME`, source it.
if [[ -n "${NBRC_PATH:-}" ]]
then
  export NBRC_PATH="${NBRC_PATH}"
elif [[ -n "${NOTESRC_PATH:-}" ]]
then # Use legacy NOTESRC_PATH environment variable.
  export NBRC_PATH="${NOTESRC_PATH}"
elif [[ -e "${HOME}/.notesrc" ]] &&
     grep -q -e "xwmx" -e "alphabetum" "${HOME}/.notesrc"
then # Migrate legacy .notesrc TODO: remove.
  mv "${HOME}/.notesrc" "${HOME}/.nbrc"
  "${_SED_I_COMMAND[@]}"                              \
    -e "s/NOTES_/NB_/g"                               \
    -e "s/notesrc/nbrc/g"                             \
    -e "s/alphabetum/xwmx/g"                          \
    -e "s/\/notes/\/nb/g"                             \
    -e "s/\.notes/\.nb/g"                             \
    -e "s/by \`notes\`/by \`notes\` (now \`nb\`)/g"   \
    -e "s/file for notes/file for \`nb\`/g"           \
    "${HOME}/.nbrc"
  export NBRC_PATH="${HOME}/.nbrc"
else
  export NBRC_PATH="${HOME}/.nbrc"
fi

# Handle symlinked NBRC_PATH
if [[ -L "${NBRC_PATH}" ]]
then
  NBRC_PATH="$(realpath "${NBRC_PATH}")"
fi

# Source rc file.
if [[ -e "${NBRC_PATH}" ]]
then
  source "${NBRC_PATH}"
fi

###############################################################################
# $EDITOR
###############################################################################

# Set default $EDITOR if one has not been set.
export EDITOR="${EDITOR:-}"
__set_editor() {
  local _editors=(
    code
    subl
    micro
    mate
    macdown
    nano
    pico
    vim
    vi
    emacs
  )

  if [[ -z "${EDITOR:-}" ]]
  then
    if [[ -n "${VISUAL:-}" ]]
    then
      EDITOR="${VISUAL}"
    else
      for __editor in "${_editors[@]}"
      do
        if hash "${__editor}" 2>/dev/null
        then
          EDITOR="${__editor}"
          break
        fi
      done
    fi

    if [[ -z "${EDITOR:-}" ]]
    then
      cat <<HEREDOC
Command line text editor not found. Set the \$EDITOR variable in your
environment or in the \`${_ME}\` configuration file located at:
  ${NBRC_PATH}

More information about setting \$EDITOR:
  https://askubuntu.com/q/432524

\`${_ME}\` uses text editors with command line support, such as:

- Visual Studio Code
    https://code.visualstudio.com
- Sublime Text
    https://www.sublimetext.com
- Atom
    https://atom.io
- MacDown
    https://macdown.uranusjr.com
- Vim
    https://en.wikipedia.org/wiki/Vim_(text_editor)
- Emacs
    https://en.wikipedia.org/wiki/Emacs
- TextMate
    https://macromates.com
- nano
    https://en.wikipedia.org/wiki/GNU_nano
- or many of these:
    https://en.wikipedia.org/wiki/List_of_text_editors
HEREDOC
      exit 1
    fi
  fi
} && __set_editor

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  %s " "${__DEBUG_COUNTER}"
    "${@}"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\\n"
  fi
}

###############################################################################
# Error Messaging
###############################################################################

# _exit_1()
#
# Usage:
#   _exit_1 <command>
#
# Description:
#   Exit with status 1 after executing the specified with output redirected
#   to standard error. The command is expected to print a message and should
#   typically be either `echo`, `printf`, or `cat`.
_exit_1() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
  exit 1
}

# _return_1()
#
# Usage:
#   _return_1 <command>
#
# Description:
#   Return with status 1 after executing the specified with output redirected
#   to standard error. The command is expected to print a message and should
#   typically be either `echo`, `printf`, or `cat`.
_return_1() {
  {
    printf "%s " "$(tput setaf 1)!$(tput sgr0)"
    "${@}"
  } 1>&2
  return 1
}

###############################################################################
# Configuration
###############################################################################

# $NB_DIR
#
# Default: `$HOME/.nb`
#
# The location of the directory that contains the notebooks.
if [[ -n "${NB_DIR:-}" ]]
then
  export NB_DIR="${NB_DIR}"
elif [[ -n "${NOTES_DIR:-}" ]]
then # Use legacy NOTES_DIR environment variable.
  export NB_DIR="${NOTES_DIR}"
else
  export NB_DIR="${HOME}/.nb"
fi

# TODO: Remove legacy migrations.
if [[ -d "${HOME}/.notes/home/.git"   ]] &&
   [[ -f "${HOME}/.notes/home/.index" ]] &&
   [[ ! -e "${HOME}/.nb"              ]] &&
   [[ "${NB_DIR}" != "${HOME}/.notes" ]] &&
   {
     [[ -z "${NOTES_DIR:-}"                ]] ||
     [[ "${NOTES_DIR}" != "${HOME}/.notes" ]]
   }
then # Migrate legacy ~/.notes directory.
  mv "${HOME}/.notes" "${HOME}/.nb"
  printf "%s migrated to %s\\n" "${HOME}/.notes" "${HOME}/.nb"
elif [[ -d "${HOME}/Notebooks/home/.git"   ]] &&
     [[ -f "${HOME}/Notebooks/home/.index" ]] &&
     [[ ! -e "${HOME}/.nb"                 ]] &&
     [[ "${NB_DIR}" != "${HOME}/Notebooks" ]] &&
     {
       [[ -z "${NOTES_DIR:-}"                   ]] ||
       [[ "${NOTES_DIR}" != "${HOME}/Notebooks" ]]
     }
then # Migrate legacy ~/Notebooks directory.
  mv "${HOME}/Notebooks" "${HOME}/.nb"
  printf "%s migrated to %s\\n" "${HOME}/.notes" "${HOME}/.nb"
fi

if [[ -L "${NB_DIR:-}" ]]
then
  NB_DIR="$(realpath "${NB_DIR}")"
fi

if [[ -z "${NB_DIR:?}"   ]] ||
   [[ "${NB_DIR}" == "/" ]] ||
   {
     [[ -e "${NB_DIR}"   ]] &&
     [[ ! -w "${NB_DIR}" ]]
   }
then
  _exit_1 cat <<HEREDOC
NB_DIR is not valid:
  ${NB_DIR}

Running the following command might resolve the issue:
  ${_ME} settings unset nb_dir

Alternatively, set NB_DIR to a new location where you'd like to store your
notes and bookmarks. For example:
  ${_ME} settings set nb_dir ~/Notebooks
HEREDOC
fi

# $NB_AUTO_SYNC
#
# Default: 1
#
# When set to '1', each `_git_checkpoint()` call will automativally run
# `$_ME sync`. To disable this behavior, set the value to '0'.
[[ -n "${NOTES_AUTO_SYNC:-}" ]] &&
  NB_AUTO_SYNC="${NOTES_AUTO_SYNC}"
export NB_AUTO_SYNC="${NB_AUTO_SYNC:-1}"

# `$NB_DEFAULT_EXTENSION`
#
# Default: 'md'
#
# Example Values: 'md' 'org'
[[ -n "${NOTES_DEFAULT_EXTENSION:-}" ]] &&
  NB_DEFAULT_EXTENSION="${NOTES_DEFAULT_EXTENSION}"
export NB_DEFAULT_EXTENSION="${NB_DEFAULT_EXTENSION:-md}"

# $NB_ENCRYPTION_TOOL
#
# Default: 'openssl'
#
# Supported Values: 'gpg' 'openssl'
[[ -n "${NOTES_ENCRYPTION_TOOL:-}" ]] &&
  NB_ENCRYPTION_TOOL="${NOTES_ENCRYPTION_TOOL}"
export NB_ENCRYPTION_TOOL="${NB_ENCRYPTION_TOOL:-openssl}"

# $NB_FOOTER
#
# Default: '1'
#
# Supported Values: '0' '1'
export NB_FOOTER="${NB_FOOTER:-1}"

###############################################################################
# Colors
###############################################################################

# $NB_COLOR_THEME
#
# Default: nb
#
# The color theme.
export NB_COLOR_THEME="${NB_COLOR_THEME:-nb}"

if [[ "${NB_COLOR_THEME}" == "blacklight" ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-39}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-56}"
fi

if [[ "${NB_COLOR_THEME}" == "console"    ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-40}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-28}"
fi

if [[ "${NB_COLOR_THEME}" == "desert"     ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-179}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-95}"
fi

if [[ "${NB_COLOR_THEME}" == "electro"    ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-129}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-26}"
fi

if [[ "${NB_COLOR_THEME}" == "forest"     ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-29}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-94}"
fi

if [[ "${NB_COLOR_THEME}" == "monochrome" ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-248}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-241}"
fi

if [[ "${NB_COLOR_THEME}" == "nb"         ]]
then
  # See default values below.
  :
fi

if [[ "${NB_COLOR_THEME}" == "ocean"      ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-75}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-26}"
fi

if [[ "${NB_COLOR_THEME}" == "raspberry"  ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-162}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-90}"
fi

if [[ "${NB_COLOR_THEME}" == "unicorn"    ]]
then
  export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-183}"
  export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-153}"
fi

export _NB_COLOR_THEMES=(
  blacklight
  console
  desert
  electro
  forest
  monochrome
  nb
  ocean
  raspberry
  unicorn
)

# User defined themes can be installed in the $NB_DIR/.themes directory.
# Themes have an .nb-theme or .nb-theme.sh extension and contain a single
# if statment assigning the color environment variables to tput ANSI color
# numbers. Example:
#
#     # filename: ~/.nb/.themes/example.nb-theme.sh
#     if [[ "${NB_COLOR_THEME}" == "example" ]]
#     then
#       export NB_COLOR_PRIMARY=68
#       export NB_COLOR_SECONDARY=8
#     fi
#
#  To view a list of available color numbers, run `nb settings colors`
__load_themes() {
  if [[ -d "${NB_DIR}/.themes" ]]
  then
    set +f
    for __file in "${NB_DIR}/.themes"/*.nb-theme*
    do
      local _name=
      _name="$(basename "${__file}")"
      _name="${_name%%.*}"

      _NB_COLOR_THEMES=("${_NB_COLOR_THEMES[@]}" "${_name}")
      source "${__file}"
    done
    set -f
  fi
} && __load_themes

# $NB_COLOR_SECONDARY
#
# Default: 8
#
# Color for lines and other accents. This should be set to an xterm color
# number, usually a value between 1 and 256. For a table of common colors and
# their numbers, run:
#   nb settings colors
#
# Supported Values: [0..255+]
export NB_COLOR_SECONDARY="${NB_COLOR_SECONDARY:-8}"

# $NB_COLOR_PRIMARY
#
# Default: Value depends on terminal capabilities.
#
# Set highlighting color. This should be set to an xterm color number, usually
# a value between 1 and 256. For a table of common colors and their numbers
# run:
#   nb settings colors
#
# Supported Values: [0..255+]
[[ -n "${NOTES_HIGHLIGHT_COLOR:-}" ]] &&
  NB_COLOR_PRIMARY="${NOTES_HIGHLIGHT_COLOR}"
[[ -n "${NB_HIGHLIGHT_COLOR:-}" ]] &&
  NB_COLOR_PRIMARY="${NB_HIGHLIGHT_COLOR}"
__set_nb_color_primary() {
  local _colors=
  _colors="$(tput colors)"
  if [[ -n "${_colors}" ]] && [[ "${_colors}" -gt 8 ]]
  then
    export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-68}"
  else
    export NB_COLOR_PRIMARY="${NB_COLOR_PRIMARY:-4}"
  fi
} && __set_nb_color_primary

# _highlight()
#
# Usage:
#   _highlight <string> [--underline]
#
# Description:
#   Use `tput` to highlight the given string.
export _TPUT_SGR0=    && _TPUT_SGR0="$(tput sgr0)"
export _TPUT_SMUL=    && _TPUT_SMUL="$(tput smul)"
export _TPUT_SETAF_8= && _TPUT_SETAF_8="$(tput setaf 8)"

export _TPUT_COLOR_PRIMARY=
_TPUT_COLOR_PRIMARY="$(tput setaf "${NB_COLOR_PRIMARY}")"
_highlight() {
  local _input="${1:-}"

  if [[ "${2:-}" == "--underline" ]]
  then
    printf "%s%s%s%s%s\\n"      \
      "${_TPUT_SGR0}"           \
      "${_TPUT_SMUL}"           \
      "${_TPUT_COLOR_PRIMARY}"  \
      "${_input}"               \
      "${_TPUT_SGR0}"
  else
    printf "%s%s%s%s\\n"        \
      "${_TPUT_SGR0}"           \
      "${_TPUT_COLOR_PRIMARY}"  \
      "${_input}"               \
      "${_TPUT_SGR0}"
  fi
}

# _highlight_secondary()
#
# Usage:
#   _highlight_secondary <string>
#
# Description:
#   Highlight the given string using the accent color.
export _TPUT_COLOR_SECONDARY=
_TPUT_COLOR_SECONDARY="$(tput setaf "${NB_COLOR_SECONDARY}")"
_highlight_secondary() {
  local _input="${1:-}"

  printf "%s%s%s\\n" "${_TPUT_COLOR_SECONDARY}" "${_input}" "${_TPUT_SGR0}"
}

# _id_brackets_color()
#
# Usage:
#   _id_brackets_color <id>
#
# Description:
#   Print <id> with surrounding color brackets.
_id_brackets_color() {
  printf \
    "%s%s[%s%s%s]%s"          \
    "${_TPUT_SGR0}"           \
    "${_TPUT_SETAF_8}"        \
    "${_TPUT_COLOR_PRIMARY}"  \
    "${1:-}"                  \
    "${_TPUT_SETAF_8}"        \
    "${_TPUT_SGR0}"
}

###############################################################################
# Cache & Temp Directories
###############################################################################

# $_NB_CACHE_PATH
#
# The full path to the cache directory.
export _NB_CACHE_PATH="${NB_DIR}/.cache"
if [[ -d "${NB_DIR}" ]] && [[ ! -e "${_NB_CACHE_PATH}" ]]
then
  mkdir -p "${_NB_CACHE_PATH}"
fi

# _clear_cache()
#
# Usage:
#   _clear_cache
#
# Description:
#   Clear the cache.
_clear_cache() {
  if [[ -e "${_NB_CACHE_PATH}" ]] &&
     [[ -d "${_NB_CACHE_PATH}" ]]
  then
    rm -r "${_NB_CACHE_PATH:?}"
    mkdir -p "${_NB_CACHE_PATH}"
  fi
}

# $_NB_TEMP_DIRECTORY
#
# The full path to the temp directory.
export _NB_TEMP_DIRECTORY
_NB_TEMP_DIRECTORY="$(mktemp -d)"

# _tempfile_path()
#
# Usage:
#   _tempfile_path <basename>
#
# Description:
#   Print the full path for <basename> within the temp directory.
_tempfile_path() {
  [[ -z "${1:-}" ]] && return 1
  printf "%s/%s" "${_NB_TEMP_DIRECTORY}" "${1:-}"
}

# Usage: _nb_cleanup_on_exit
_nb_cleanup_on_exit() {
  if [[ -n "${_NB_TEMP_DIRECTORY:-}" ]] &&
     [[ -e "${_NB_TEMP_DIRECTORY}"   ]]
  then
    rm -rf "${_NB_TEMP_DIRECTORY}"
  fi
}

trap _nb_cleanup_on_exit EXIT

###############################################################################
# Utilities
###############################################################################

# _command_exists()
#
# Usage:
#   _command_exists <name>
#
# Takes a potential command <name> as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "${1}" 2>/dev/null
}

# _contains()
#
# Usage:
#   _contains "${item}" "${list[@]}"
#
# Returns:
#   0  If the item is included in the list.
#   1  If not.
_contains() {
  local _query="${1:-}"
  shift

  if [[ -z "${_query}"  ]] ||
     [[ -z "${*:-}"     ]]
  then
    return 1
  fi

  for __element in "${@}"
  do
    [[ "${__element}" == "${_query}" ]] && return 0
  done

  return 1
}

# _get_hash()
#
# Usage:
#   _get_hash <path>
#
# Description:
#   Generate a hash for the file or directory at <path>.
_get_hash() {
  # Usage: _get_hash_with_command <path> <command>
  _get_hash_with_command() {
    local _command=
    IFS=' ' read -ra _command <<< "${2:-}"

    local _path="${1:-}"

    [[ -n "${_command[*]:-}" ]] && [[ -n "${_path}" ]] || return 1

    if [[ -d "${_path}" ]]
    then
      tar -P -cf - "${_path}"     \
        | "${_command[@]}"        \
        | awk '{ print $1 }'
    else
      "${_command[@]}" "${_path}" \
        | awk '{print $1}'
    fi
  }

  local _path="${1:-}"
  [[ -n "${_path:-}" ]] || return 1

  if _command_exists "shasum"
  then
    _get_hash_with_command "${_path}" "shasum -a 256"
  elif _command_exists "md5sum"
  then
    _get_hash_with_command "${_path}" "md5sum"
  elif _command_exists "md5"
  then
    _get_hash_with_command "${_path}" "md5 -q"
  else
    _exit_1 printf "No hashing tool found.\\n"
  fi
}

# __option_get_value()
#
# Usage:
#   __option_get_value <option> <value>
#
# Description:
#  Given a flag (e.g., -e | --example) return the value or exit 1 if value
#  is blank or appears to be another option.
__option_get_value() {
  local __arg="${1:-}"
  local __val="${2:-}"

  if [[ -n "${__val:-}" ]] && [[ ! "${__val:-}" =~ ^- ]]
  then
    printf "%s\\n" "${__val}"
  else
    _exit_1 printf "%s requires a valid argument.\\n" "$(_highlight "${__arg}")"
  fi
}

# __option_value_is_present()
#
# Usage:
#   __option_value_is_present "${variable}"
#
# Returns:
#   0  The argument is present and does not match an option flag.
#   1  The argument is blank or matches as an option flag.
__option_value_is_present() {
  [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
}

###############################################################################
# Current Notebook
###############################################################################

# $_NOTEBOOK_PATH
#
# Default: `$NB_DIR/home`
export _NOTEBOOK_PATH="${_NOTEBOOK_PATH:-${NB_DIR}/home}"

# $_GLOBAL_NOTEBOOK_PATH
#
# The path of the current global notebook.
export _GLOBAL_NOTEBOOK_PATH="${_NOTEBOOK_PATH}"

# $_GLOBAL_NOTEBOOK_NAME
#
# The name of the current global notebook.
export _GLOBAL_NOTEBOOK_NAME=
_GLOBAL_NOTEBOOK_NAME="$(basename "${_GLOBAL_NOTEBOOK_PATH}")"

# $_LOCAL_NOTEBOOK_PATH
#
# The path of the local notebook, if one is found. The current working
# directory and all parents are searched.
export _LOCAL_NOTEBOOK_PATH=
__set_notebook_path() {
  __set_local_notebook_path() {
    if [[ "${PWD}" == "/" ]]
    then
      cd "${_CURRENT_WORKING_DIR}"
      return 0
    elif [[ -d "${PWD}/.git"    ]] &&
         [[ -f "${PWD}/.index"  ]]
    then
      _LOCAL_NOTEBOOK_PATH="${PWD}"
      cd "${_CURRENT_WORKING_DIR}"
      return 0
    else
      cd ..
      __set_local_notebook_path
    fi
  } && __set_local_notebook_path

  __set_global_notebook() {
    if [[ -e "${NB_DIR}/.current" ]]
    then
      _GLOBAL_NOTEBOOK_NAME="$(cat "${NB_DIR}/.current")"

      if [[ -d "${NB_DIR}/${_GLOBAL_NOTEBOOK_NAME}" ]]
      then
        _GLOBAL_NOTEBOOK_PATH="${NB_DIR}/${_GLOBAL_NOTEBOOK_NAME}"
      fi
    fi
  } && __set_global_notebook

  if [[ -n "${_LOCAL_NOTEBOOK_PATH:-}" ]]
  then
    _NOTEBOOK_PATH="${_LOCAL_NOTEBOOK_PATH}"
  else
    _NOTEBOOK_PATH="${_GLOBAL_NOTEBOOK_PATH}"
  fi
} && __set_notebook_path

###############################################################################
# Helpers
###############################################################################

# $_NEWLINE
#
# Assign newline with ANSI-C quoting for string building.
_NEWLINE=$'\n'

# _alias_subcommand()
#
# Usage:
#   _alias_subcommand <subcommand> <alias>
#
# Description:
#   Create an <alias> of <subcommand>. NOTE: aliases also have to be added to
#   the $_SUBCOMMANDS variable.
_alias_subcommand() {
  local _subcommand="${1:-}"
  local _alias="${2:-}"

  if [[ -z "${_subcommand}" ]] || [[ -z "${_alias}" ]]
  then
    return 1
  fi

  eval "desc \"${_alias}\" \"\$___desc_${_subcommand}\""
  eval "_${_alias}() { _${_subcommand} \"\${@}\"; }"
}

# _decrypt_file()
#
# Usage:
#   _decrypt_file <path> <password>
_decrypt_file() {
  local _encrypted_path="${1:-}"
  local _password="${2:-}"

  if [[ -z "${_password}" ]]
  then
    _return_1 printf "Password required.\\n"
  fi

  if [[ -z "${_encrypted_path}" ]]
  then
    return 1
  fi

  local _basename
  _basename="$(basename "${_encrypted_path}")"

  local _unencrypted_basename
  _unencrypted_basename="$(printf "%s" "${_basename}" | sed 's/.enc$//')"

  local _unencrypted_path
  _unencrypted_path="$(_tempfile_path "${_unencrypted_basename}")"

  local _file_command_response
  _file_command_response="$(file "${_encrypted_path}")"

  if [[ "${_file_command_response}" =~ GPG ]]
  then
    if _command_exists "gpg"
    then
      printf "%s\\n" "${_password}"       \
        | gpg                             \
          --quiet                         \
          --batch                         \
          --passphrase-fd 0               \
          --output "${_unencrypted_path}" \
          --decrypt "${_encrypted_path}"
    else
      _return_1 printf "\
This note was encrypted with GPG, but the GPG command was not found.\\n"
    fi
  elif [[ "${_file_command_response}" =~ openssl ]]
  then
    openssl enc                   \
      -d                          \
      -aes-256-cbc                \
      -in "${_encrypted_path}"    \
      -out "${_unencrypted_path}" \
      -pass file:<(printf "%s\\n" "${_password}") 2> /dev/null ||
        rm "${_unencrypted_path}"
  else
    _return_1 printf "Unable to decrypt file.\\n"
  fi

  if [[ ! -e "${_unencrypted_path}" ]]
  then
    _return_1 printf "Decryption error.\\n" 1>&2
  fi

  printf "%s\\n" "${_unencrypted_path}"
}

# _download_from()
#
# Usage:
#   _download_from <url> [<outfile>]
#
# Description:
#   Download the file at <url> and print to standard output or <outfile>, if
#   present.
_download_from() {
  local _downloaded=0
  local _url="${1:-}"
  if [[ -z "${_url}" ]] ||
     [[ ! "${_url}" =~ ^ftp|^http|^file|^mailto|^news|^telnet|^gopher ]]
  then
    return 1
  fi

  local _target_path="${2:-}"

  if [[ -n "${_target_path}" ]]
  then
    if _command_exists "curl"
    then
      curl -s -L "${_url}" -o "${_target_path}" &&
        _downloaded=1
    elif _command_exists "wget"
    then
      wget --quiet -O "${_target_path}" "${_url}" 2>/dev/null &&
        _downloaded=1
    fi
  else
    if _command_exists "curl"
    then
      curl -s -L "${_url}" &&
        _downloaded=1
    elif _command_exists "wget"
    then
      wget --quiet -O - "${_url}" 2>/dev/null &&
        _downloaded=1
    fi
  fi

  if ! ((_downloaded))
  then
    return 1
  fi
}

# _edit_file()
#
# Usage:
#   _edit_file <path> [--no-wait]
#
# Description:
#   Open the file in $EDITOR. Use the `-f` option in vim and `--wait` option in
#   other GUI editors to wait until the file is closed in the editor before
#   continuing, unless `--no-wait`.
_edit_file() {
  local _file_path="${1:-}"
  local _wait=1

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --no-wait)
        _wait=0
        ;;
      *)
        if [[ -z "${_file_path}" ]]
        then
          _file_path="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_file_path}" ]]
  then
    return 1
  fi

  cd "${_NOTEBOOK_PATH}" || return 1

  if _file_is_encrypted "${_file_path}"
  then
    _exit_1 printf "\
File must be decrypted before editing.\\n"
  fi

  if _file_is_archive "${_file_path}" &&
     [[ ! "${_file_path}" =~ docx$ ]]
  then
    _exit_1 printf "\
Can't edit archives. Export archive and expand to edit.\\n"
  fi

  if ! _file_is_text "${_file_path}"
  then
    if _command_exists "xdg-open"
    then
      xdg-open "${_file_path}" && return 0
    elif [[ "${OSTYPE}" =~ ^darwin ]]
    then
      open "${_file_path}" && return 0
    fi
  fi

  if ((_wait)) &&
     [[ "${EDITOR}" =~ mvim ]] ||
     [[ "${EDITOR}" =~ gvim ]]
  then
    eval "${EDITOR} -f \"${_file_path}\""
  elif ((_wait)) &&
       [[ "${EDITOR}" =~ code ]] ||
       [[ "${EDITOR}" =~ mate ]] ||
       [[ "${EDITOR}" =~ subl ]]
  then
    eval "${EDITOR} --wait \"${_file_path}\""
  else
    eval "${EDITOR} \"${_file_path}\""
  fi
}

# _encrypt_file()
#
# Usage:
#   _encrypt_file <decrypted path> <encrypted path> <password>
_encrypt_file() {
  local _decrypted_path="${1:-}"
  local _encrypted_path="${2:-}"
  local _password="${3:-}"

  if [[ -z "${_password}" ]]
  then
    _return_1 printf "Password required.\\n"
  fi

  if [[ -z "${_decrypted_path}" ]] ||
     [[ -z "${_encrypted_path}" ]]
  then
    _return_1 printf "Encrypted and decripted paths required.\\n"
  fi

  if [[ "${NB_ENCRYPTION_TOOL}" == "gpg" ]]
  then
    printf "%s\\n" "${_password}"     \
      | gpg                           \
        --quiet                       \
        --batch                       \
        --passphrase-fd 0             \
        --symmetric                   \
        --cipher-algo AES256          \
        --output "${_encrypted_path}" \
        "${_decrypted_path}"
  elif [[ "${NB_ENCRYPTION_TOOL}" == "openssl" ]]
  then
    openssl enc                 \
      -aes-256-cbc              \
      -in "${_decrypted_path}"  \
      -out "${_encrypted_path}" \
      -pass file:<(printf "%s\\n" "${_password}") 2> /dev/null
  else
    _return_1 \
      printf "\$NB_ENCRYPTION_TOOL must be set to 'gpg' or 'openssl'.\\n"
  fi

  if [[ ! -e "${_encrypted_path}" ]]
  then
    _return_1 printf "Encryption error.\\n"
  fi
}

# _file_is_archive()
#
# Usage:
#   _file_is_archive <path>
#
# Returns:
#   0  If file is an archive.
#   1  if not.
export _ARCHIVE_FILE_EXTENSIONS=(
  7z
  apk
  bz2
  dmg
  gz
  rar
  s7z
  sit
  sitx
  tar
  tar.gz
  tgz
  tar.Z
  tar.bz2
  tbz2
  tar.lz
  tlz.
  tar.xz
  txz
  zip
  zipx
)
_file_is_archive() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  _contains "${_file_type}" "${_ARCHIVE_FILE_EXTENSIONS[@]}" ||
    [[ "$(file "${_file_path:-}" | cut -d: -f2)" =~ archive|compressed ]]
}

# _file_is_audio()
#
# Usage:
#   _file_is_audio (<path> | <filename>)
#
# Returns:
#   0  If file is an audio file.
#   1  if not.
export _AUDIO_FILE_EXTENSIONS=(
  aac
  aiff
  flac
  m4a
  mp3
  ogg
  wav
)
_file_is_audio() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  _contains "${_file_type}" "${_AUDIO_FILE_EXTENSIONS[@]}"
}

# _file_is_bookmark()
#
# Usage:
#   _file_is_bookmark (<path> | <filename>)
#
# Returns:
#   0 If file is a bookmark.
#   1 if not.
export _BOOKMARK_FILE_EXTENSIONS=(
  bookmark.md
  bookmark.md.enc
)
_file_is_bookmark() {
  # Use explicit matching for legacy bookmark name support.
  [[ "${1:-}" =~ .bookmark.md$      ]] ||
  [[ "${1:-}" =~ .bookmark.md.enc$  ]] ||
  [[ "${1:-}" =~ -bookmark.md$      ]] ||
  [[ "${1:-}" =~ -bookmark.md.enc$  ]]
}

# _file_is_document()
#
# Usage:
#   _file_is_document (<path> | <filename>)
#
# Returns:
#   0  If file is a Word, Open Office, PDF, or other document.
#   1  if not.
export _DOCUMENT_FILE_EXTENSIONS=(
  doc
  docx
  odt
  pdf
  rtf
)
_file_is_document() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  _contains "${_file_type}" "${_DOCUMENT_FILE_EXTENSIONS[@]}"
}

# _file_is_encrypted()
#
# Usage:
#   _file_is_encrypted <path>
#
# Returns:
#   0  If file is encrypted.
#   1  if not.
export _ENCRYPTED_FILE_EXTENSIONS=(
  enc
)
_file_is_encrypted() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # `file` with 'soft' test is slow, so avoid calling it.
  _contains "${_file_type}" "${_ENCRYPTED_FILE_EXTENSIONS[@]}" ||
    {
      ! _file_is_text "${1:-}"      &&
      [[ "$(file "${_file_path:-}"  \
              --exclude=apptype     \
              --exclude=encoding    \
              --exclude=tokens      \
              --exclude=cdf         \
              --exclude=compress    \
              --exclude=elf         \
              --exclude=tar)" =~ encrypted|openssl ]]
    }
}

# _file_is_image()
#
# Usage:
#   _file_is_image (<path> | <filename>)
#
# Returns:
#   0  If file is an image.
#   1  if not.
export _IMAGE_FILE_EXTENSIONS=(
  ai
  bmp
  gif
  ind
  indd
  jpg
  jpeg
  png
  psd
  raw
  svg
  svgz
  tif
  tiff
  webp
)
_file_is_image() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  _contains "${_file_type}" "${_IMAGE_FILE_EXTENSIONS[@]}"
}

# _file_is_text()
#
# Usage:
#   _file_is_text <path>
#
# Returns:
#   0  If file is text.
#   1  if not.
export _TEXT_FILE_EXTENSIONS=(
  bib
  html
  latex
  md
  markdown
  org
  rst
  tex
  textile
  txt
  xml
)
_file_is_text() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  # Avoid calling `file` for better performance.
  _contains "${_file_type}" "${_TEXT_FILE_EXTENSIONS[@]}" ||
    [[ "$(file -b --mime-type "${1:-}")" =~ ^text ]]
}

# _file_is_video()
#
# Usage:
#   _file_is_video (<path> | <filename>)
#
# Returns:
#   0  If file is a video file.
#   1  if not.
export _VIDEO_FILE_EXTENSIONS=(
  avi
  flv
  m4p
  m4v
  mp2
  mp4
  mov
  mpeg
  mpg
  qt
  webm
  wmv
)
_file_is_video() {
  local _file_path="${1:-}"
  local _file_type="${_file_path##*.}"

  _contains "${_file_type}" "${_VIDEO_FILE_EXTENSIONS[@]}"
}

# _get_first_line()
#
# Usage:
#   _get_first_line <path>
#
# Description:
#   Print the first line of the file at <path>, skipping any front matter.
_get_first_line() {
  local _first_line=
  local _in_front_matter=0
  local _path="${1:-}"

  if [[ -z "${_path}" ]]
  then
    return 1
  elif [[ -e "${_path}" ]]
  then
    if _file_is_text "${_path}"
    then

      # Avoid single line being ignored.
      # https://stackoverflow.com/a/10929511
      while IFS= read -r __line || [[ -n "${__line}" ]]
      do
        if [[ "${__line}" =~ ^---$ ]]
        then
          if ((_in_front_matter))
          then
            _in_front_matter=0
          else
            _in_front_matter=1
          fi
        elif ! ((_in_front_matter))
        then
          if [[ -z "${_first_line}" ]] && [[ -n "${__line}" ]]
          then
            _first_line="${__line}"
            break
          fi
        fi
      done < "${_path}"

      printf "%s\\n" "${_first_line}"
    fi
  fi
}

# _get_http_status()
#
# Usage:
#   _get_http_status <url>
#
# Description:
#   Print the http status response code for <url>.
_get_http_status() {
  local _url="${1:-}"
  [[ -n "${_url:-}" ]] || return 1

  if _command_exists "curl"
  then
    curl -I -s -o /dev/null -w "%{http_code}\\n" "${_url}"
  elif _command_exists "wget"
  then
    wget -S "${_url}" 2>&1 | grep "HTTP/" | awk '{print $2}' || return 0
  fi
}

# _get_notebook_identifier()
#
# Usage:
#   _get_notebook_identifier (<path> | <name>)
#
# Description:
#   Print a copy / pastable notebooks name, with spaces escaped.
_get_notebook_identifier() {
  local _notebook_identifier="${1:-}"

  if [[ -n "${_notebook_identifier:-}" ]]
  then
    if [[ "${_notebook_identifier}" =~ / ]]
    then
      if [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"                          ]] &&
         [[ "${_notebook_identifier}" == "${_LOCAL_NOTEBOOK_PATH}"  ]]
      then
        _notebook_identifier="local"
      else
        _notebook_identifier="$(basename "${_notebook_identifier}")"
      fi
    fi

    if [[ "${_notebook_identifier}" =~ \  ]]
    then
      _notebook_identifier="$(
        printf "%s\\n" "${_notebook_identifier}" | sed -e "s/ /\\\ /g"
      )"
    fi
  fi

  printf "%s\\n" "${_notebook_identifier:-}"
}

# _get_selection_basename()
#
# Usage:
#   _get_selection_basename <id>
#   _get_selection_basename <filename>
#   _get_selection_basename <path>
#   _get_selection_basename <title>
#
# Description:
#   Determine the basename of the file in `$_NOTEBOOK_PATH` that is identified
#   by the given <id>, <filename>, <path>, or <title>.
_get_selection_basename() {
  local _basename=
  local _identifier=
  local _selection="${1:-}"

  if [[ -z "${_selection}" ]]
  then
    _basename=
  else
    _set_selection_notebook "${_selection}"
    _identifier="$(_get_selection_identifier "${_selection}")"

    if [[ -e "${_identifier}"                   ]] &&
       [[ "${_identifier}" =~ ${_NOTEBOOK_PATH} ]]
    then # <selection> is a full path.
      _basename="$(basename "${_identifier}")"
    elif [[ -e "${_NOTEBOOK_PATH}/${_identifier}" ]]
    then # <selection> is a filename.
      _basename="${_identifier}"
    elif [[ "${_identifier}" =~ ^[0-9]+$ ]]
    then # <selection> is an id.
      _basename="$(_index get_basename "${_identifier}")"
    else # <selection> might be a title.
      local _title=
      local _filenames=
      _filenames=($(_list_nb_files))

      for __file in "${_filenames[@]:-}"
      do
        _title="$(_get_title "${_NOTEBOOK_PATH}/${__file}")"

        if [[ -n "${_title}"                  ]] &&
           [[ "${_title}" == "${_identifier}" ]]
        then
          _basename="${__file}"
          break
        fi
      done
    fi
  fi

  printf "%s\\n" "${_basename}"
}

# _get_selection_identifier()
#
# Usage:
#   _get_selection_identifier <selection>
#
# Description:
#   Given <selection>, print the identifier portion.
_get_selection_identifier() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))

  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    printf "%s\\n" "${_parts[1]:-}"
  else
    printf "%s\\n" "${_parts[0]:-}"
  fi
}

# _get_selection_parts()
#
# Usage:
#   _get_selection_parts <selection>
#
# Description:
#   Given <selection>, split on first colon.
_get_selection_parts() {
  local _identifier=
  local _maybe_notebook_name=
  local _selection="${1:-}"

  if [[ -n "${_selection:-}" ]]
  then
    _maybe_notebook_name=$(printf "%s\\n" "${_selection}" | cut -f 1 -d ":")

    if [[ "${_selection}" =~ ':' ]] &&
       {
         [[ -e "${NB_DIR}/${_maybe_notebook_name}/.git" ]] ||
         {
           [[ "${_maybe_notebook_name}" == "local" ]] &&
           [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"       ]]
         }
       }
    then
      _identifier=$(printf "%s\\n" "${_selection}" | cut -f 2- -d ":")
      printf "%s\\n%s\\n" "${_maybe_notebook_name}" "${_identifier}"
    else
      printf "%s\\n" "${_selection}"
    fi
  fi
}

# _get_title()
#
# Usage:
#   _get_title <path>
#
# Description:
#   Print the title, if present, of the note at the path. Supports both
#   Markdown h1 styles and YAML front matter.
_get_title() {
  local _in_code_block=0
  local _in_front_matter=0
  local _maybe_title=
  local _path="${1:-}"
  local _title=

  if [[ -z "${_path}" ]]
  then
    return 1
  elif [[ -e "${_path}" ]]
  then
    if _file_is_text "${_path}"
    then

      while IFS= read -r __line || [[ -n "${__line}" ]]
      do
        if [[ "${__line}" =~ ^[[:space:]]*#\  ]] &&
           ! ((_in_code_block))
        then # line starts with an atx-style H1
          _title="$(
            printf "%s\\n" "${__line}"    \
              | sed 's/^[[:space:]]*# //' \
              | sed 's/ #$//'
            )"
          break
        elif [[ "${__line}" =~ ^---$ ]]
        then # start or end of front matter block
          if ((_in_front_matter))
          then
            _in_front_matter=0
          else
            _in_front_matter=1
          fi
        elif [[ "${__line}" =~ ^\`\`\` ]]
        then # start or end of code block
          if ((_in_code_block))
          then
            _in_code_block=0
          else
            _in_code_block=1
          fi
        elif ((_in_front_matter)) && [[ "${__line}" =~ ^title\: ]]
        then # front matter title
          _title="$(printf "%s\\n" "${__line}" | sed 's/^title: //')"
          break
        elif ! ((_in_front_matter)) && ! ((_in_code_block))
        then
          if [[ -z "${_maybe_title}" ]] && [[ -n "${__line}" ]]
          then  # potential setext-style H1
            _maybe_title="${__line}"
          elif [[ -n "${_maybe_title}"             ]] &&
               [[ "${__line}" =~ ^[[:space:]]*\=+$ ]]
          then # underline for setext-style H1 on previous line
            _title="$(
              printf "%s\\n" "${_maybe_title}" | sed 's/^[[:space:]]*//'
            )"
            break
          elif [[ -n "${_maybe_title}"       ]] &&
               [[ ! "${_maybe_title}" =~ ^\[ ]]
          then # in normal content, title not found
            break
          else
            continue
          fi
        fi
      done < "${_path}"

      printf "%s\\n" "${_title}"
    fi
  fi
}

# _get_unique_basename()
#
# Usage:
#   _get_unique_basename [<file name> | <file extension>]
#
# Description:
#   Get a unique basename that doesn't conflict with any existing file.
_get_unique_basename() {
  local _file_basename="${1:-}"
  local _file_name="${_file_basename%%.*}"

  if [[ -z "${_file_name}" ]]
  then
    _file_name="$(date -u "+%Y%m%d%H%M%S")"
  fi

  local _file_type="${_file_basename#*.}"
  if [[ -z "${_file_type}" ]]
  then
    _file_type="md"
  fi

  if [[ -n "${_file_type:-}"                ]] &&
     [[ "${_file_basename}" =~ \.           ]] &&
     [[ "${_file_name}" != "${_file_type}"  ]]
  then
    _file_type="${_file_type}"
  else
    _file_type="md"
  fi

  basename "$(
    _get_unique_path "${_NOTEBOOK_PATH}/${_file_name}.${_file_type}"
  )"
}

# _get_unique_path()
#
# Usage:
#   _get_unique_path <path>
#
# Description:
#   Get a unique full path that doesn't conflict with any existing file.
_get_unique_path() {
  local _path="${1:-}"

  local _dir_path=
  _dir_path="$(dirname "${_path}")"

  local _basename=
  _basename="$(basename "${_path}")"

  local _file_name="${_basename%%.*}"
  local _file_extension="${_basename#*.}"

  if [[ -n "${_file_extension:-}"               ]] &&
     [[ "${_basename}" =~ \.                    ]] &&
     [[ "${_file_name}" != "${_file_extension}" ]]
  then
    _file_extension=".${_file_extension}"
  else
    _file_extension=
  fi

  local _unique_file_name="${_file_name}"

  local _uniqueness_counter=0

  while [[ -e "${_dir_path}/${_unique_file_name}${_file_extension}" ]]
  do
    _uniqueness_counter="$((_uniqueness_counter+1))"

    printf -v _unique_file_name -- "%s-%01d"  \
      "${_file_name}"                         \
      "${_uniqueness_counter}"
  done

  printf "%s\\n" "${_dir_path}/${_unique_file_name}${_file_extension}"
}

# _git_checkpoint()
#
# Usage:
#   _git_checkpoint <commit message> [<target-directory>]
#
# Description:
#   Commit all files in the repository with the provided commit message.
_git_checkpoint() {
  # Usage: _git_checkpoint_commit <message>
  _git_checkpoint_commit() {
    [[ -z "${1:-}" ]] &&
      _exit_1 printf "Usage: _git_checkpoint_commit <message>"
    _debug printf \
      "_git_checkpoint() \$(ls -la): '%s'\\n" \
      "$(ls -la)"

    git add --all && git commit -a -m "${1}"
  }

  # Usage: _git_checkpoint_sync
  _git_checkpoint_sync() {
    if git show-branch remotes/origin/master > /dev/null 2>&1
    then
      git fetch && git rebase origin/master && git push
    else
      git push
    fi
  }

  local _message=
  local _show_spinner=0
  local _target_directory=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --spinner)
        _show_spinner=1
        ;;
      *)
        if [[ -z "${_message}" ]]
        then
          _message="${__arg}"
        elif [[ -z "${_target_directory}" ]]
        then
          _target_directory="${__arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_target_directory}" ]]
  then
    _target_directory="${_NOTEBOOK_PATH}"
  fi

  _debug printf "_git_checkpoint() \${_target_directory}: '%s'\\n" \
    "${_target_directory}"

  if [[ -z "${_message}" ]]
  then
    _exit_1 printf "Usage: _git_checkpoint <message>\\n"
  fi

  if [[ -n "${2:-}" ]] && [[ "${2}" == "--spinner" ]]
  then
    _show_spinner=1
  fi

  cd "${_target_directory}" ||
    _exit_1 printf "_git_checkpoint() \`cd\` failed.\\n"

  _debug printf "_git_checkpoint() \$(ls -la): '%s'\\n" "$(ls -la)"

  if ((NB_AUTO_SYNC))
  then
    (
      # Only sync when the index is dirty to avoid fetching from and pushing
      # to origin.
      if _git_index_is_dirty "${_target_directory}"
      then
        _git_checkpoint_commit "${_message}" &>/dev/null
      fi && _git_checkpoint_sync &>/dev/null
    ) &
  else
    (
      _git_checkpoint_commit "${_message}" &>/dev/null
    ) &
  fi

  if ((_show_spinner))
  then
    _spinner ${!}
  fi
}

# _git_index_is_dirty()
#
# Usage:
#   _git_index_is_dirty [<target-directory>]
#
# Returns:
#   0  If there are uncommitted changes in `_NOTEBOOK_PATH` or
#      <target-directory>.
#   1  If the `$_NOTEBOOK_PATH` repository is clean.
_git_index_is_dirty() {
  local _target_directory="${1:-}"

  if [[ -z "${_target_directory}" ]]
  then
    _target_directory="${_NOTEBOOK_PATH}"
  fi

  cd "${_target_directory}" ||
    _exit_1 printf "_git_index_is_dirty() \`cd\` failed.\\n"
  [[ -n "$(git status --porcelain)" ]]
}

# _git_required()
#
# Usage:
#   _git_required
#
# Description:
#   Exit with `_exit_1` if `git` isn't found.
_git_required() {
  if ! _command_exists "git"
  then
    _exit_1 cat <<HEREDOC
Welcome to $(_highlight "${_ME}")!

Git is required, but wasn't found. Install Git, then run \`${_ME}\` again.

About Git: https://git-scm.com/
HEREDOC
  fi

  local _git_name=
  _git_name="$(git config user.name || printf '')"

  local _git_email=
  _git_email="$(git config user.email || printf '')"

  if [[ -z "${_git_name}"   ]] ||
     [[ -z "${_git_email}"  ]]
  then
    cat <<HEREDOC
Welcome to $(_highlight "${_ME}")!

Git requires some additional setup before using $(_highlight "${_ME}").
Enter the name and email address you'd like to use with Git.
Edits you make will be attributed to this name and email address.
HEREDOC
    if [[ -z "${_git_name}" ]]
    then
      while true
      do
        read -r -p "$(_highlight "Name"): " __name
        if [[ -n "${__name}" ]]
        then
          git config --global user.name "${__name}"
          break
        fi
      done
    fi

    if [[ -z "${_git_email}" ]]
    then
      while true
      do
        read -r -p "$(_highlight "Email"): " __email
        if [[ -n "${__email}" ]]
        then
          git config --global user.email "${__email}"
          break
        fi
      done
    fi
  fi
}

# _git_should_autosync()
#
# Usage:
#   _git_should_autosync
#
# Returns:
#   0  If an autosync should be triggered.
#   1  If not.
_git_should_autosync() {
  local _current_timestamp=
  local _last_fetch_timestamp=
  local _maybe_fetch_timestamp=

  if ! ((NB_AUTO_SYNC))
  then # autosync not enabled.
    return 1
  fi

  cd "${_NOTEBOOK_PATH}" || _exit_1 printf "\`cd\` failed.\\n"
  if ! git config --get remote.origin.url &>/dev/null
  then # there is no remote configured.
    return 1
  fi

  if [[ ! -e "${_NOTEBOOK_PATH}/.git/FETCH_HEAD" ]]
  then # no previous fetches, but has an origin and autosync is enabled.
    return 0
  fi

  if _maybe_fetch_timestamp="$(stat -c %Y .git/FETCH_HEAD 2>/dev/null)"
  then # GNU
    _last_fetch_timestamp="${_maybe_fetch_timestamp}"
  elif _maybe_fetch_timestamp="$(gstat -c %Y .git/FETCH_HEAD 2>/dev/null)"
  then # GNU prefixed
    _last_fetch_timestamp="${_maybe_fetch_timestamp}"
  else
    _last_fetch_timestamp="$(stat -f '%m' .git/FETCH_HEAD)"
  fi
  _current_timestamp="$(date +%s)"

  _diff=$((_current_timestamp-_last_fetch_timestamp))
  _debug printf \
    "_git_should_sync() \${_last_fetch_timestamp}: %s\\n" \
    "${_last_fetch_timestamp}"
  _debug printf \
    "_git_should_sync() \${_current_timestamp}: %s\\n" \
    "${_current_timestamp}"
  _debug printf \
    "_git_should_sync() \${_diff}: %s\\n" \
    "${_diff}"

  [[ "${_diff}" -gt 300 ]]
}

# _highlight_syntax_if_available()
#
# Usage:
#   _highlight_syntax_if_available [<path>] [<lexer>]
#
# Description:
#   If Pygments is available, use it to highlight syntax. When it is not
#   available, just pipe through `cat`.
#
# References:
#   http://pygments.org/
_highlight_syntax_if_available() {
  if hash "pygmentize" 2>/dev/null
  then # pygments is installed.
    if _interactive_input
    then
      local _path="${1:-}"
      local _basename=
      _basename="$(basename "${_path}")"
      local _extension="${_basename##*.}"

      local _lexer="${2:-}"

      # Markdown highlighting is better with explicit 'md' lexer.
      if [[ ! "${_extension}" == "md" ]] &&
         [[ -z "${_lexer:-}"          ]]
      then
        pygmentize -O style=friendly "${@}"
      elif [[ -n "${_lexer:-}" ]]
      then
        pygmentize -l "${_lexer }" -O style=friendly "${@}"
      else
        pygmentize -l md -O style=friendly "${@}"
      fi
    else
      local _lexer="${1:-}"

      if [[ -n "${_lexer:-}" ]]
      then
        pygmentize -l "${_lexer:-}" -O style=friendly
      else
        pygmentize -l md -O style=friendly
      fi
    fi 2>/dev/null
  else
    cat "${@}"
  fi
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _join()
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
#
# Returns:
#   The list or array of items joined into a string with elements divided by
#   the optional separator if one is provided.
#
# More information:
#   https://stackoverflow.com/a/17841619
_join() {
  local _delimiter="${1}"
  shift
  printf "%s" "${1}"
  shift
  printf "%s" "${@/#/${_delimiter}}" | tr -d '[:space:]'
}

# _less_prompt
#
# Usage:
#   _less_prompt
#
# The prompt to display in `less`.
_less_prompt() {
  _prompt="\
> scroll for more, h for help, or q to quit"

  printf "%s\\n" "${_prompt}"
}

# _list_nb_files()
#
# Usage:
#   _list_nb_files [--sort] [--reverse] [--type <type>]
#
# Description:
#   List note files with default sorting.
_list_nb_files() {
  # Relevant `ls` options:
  # --  Default sort order.
  # -t  Sort by time modified (most recently modified first) before sorting
  #     the operands by lexicographical order
  # -r  Reverse the order of the sort to get reverse order or the oldest
  #     entries first (or largest files last, combined with sort by size

  local _reverse=0
  local _sort=0
  local _type=

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      --reverse)
        _reverse=1
        ;;
      --sort)
        _sort=1
        ;;
      --type)
        if __option_value_is_present "${__val:-}"
        then
          _type="${__val}"
          shift
        fi
        ;;
    esac

    shift
  done

  if ((_sort))
  then
    cat "${_NOTEBOOK_PATH}/.index"
  else
    ls -t -1 "${_NOTEBOOK_PATH}"
  fi | {
    if ((_reverse))
    then
      # https://stackoverflow.com/a/744093
      sed '1!G;h;$!d'
    else
      cat
    fi
  } | {
    if [[ -n "${_type:-}" ]]
    then
      local _grep_patterns=()

      if [[ "${_type}" =~ ^bookmark$|^bookmarks$ ]]
      then
        grep --color=never    \
          -e '\.bookmark\.'   \
          -e '\-bookmark\.'
      elif [[ "${_type}" =~ ^note$|^notes$|^text$ ]]
      then
        for __extension in "${_TEXT_FILE_EXTENSIONS[@]}"
        do
          _grep_patterns+=("-e" "${__extension}")
        done
        grep --color=never "${_grep_patterns[@]}" \
          | grep --color=never -v \
              -e '\.bookmark\.'   \
              -e '\-bookmark\.'
      elif [[ "${_type}" =~ ^folder$|^folders$|^directory$|^directories$ ]]
      then
        while read -r __line
        do
          if [[ -d "${_NOTEBOOK_PATH}/${__line}" ]]
          then
            printf "%s\\n" "${__line}"
          fi
        done
      elif [[ "${_type}" =~ ^archive$ ]]
      then
        for __extension in "${_ARCHIVE_FILE_EXTENSIONS[@]}"
        do
          _grep_patterns+=("-e" "${__extension}$" "-e" "${__extension}.enc$")
        done
        grep --color=never "${_grep_patterns[@]}"
      elif [[ "${_type}" =~ ^audio$|^music$ ]]
      then
        for __extension in "${_AUDIO_FILE_EXTENSIONS[@]}"
        do
          _grep_patterns+=("-e" "${__extension}$" "-e" "${__extension}.enc$")
        done
        grep --color=never "${_grep_patterns[@]}"
      elif [[ "${_type}" =~ ^document$|^documents$|^doc$|^docs$ ]]
      then
        for __extension in "${_DOCUMENT_FILE_EXTENSIONS[@]}"
        do
          _grep_patterns+=("-e" "${__extension}$" "-e" "${__extension}.enc$")
        done
        grep --color=never "${_grep_patterns[@]}"
      elif [[ "${_type}" =~ ^encrypted$ ]]
      then
        for __extension in "${_ENCRYPTED_FILE_EXTENSIONS[@]}"
        do
          _grep_patterns+=("-e" "${__extension}$")
        done
        grep --color=never "${_grep_patterns[@]}"
      elif [[ "${_type}" =~ ^image$|^images$|^picture$|^pictures$ ]]
      then
        for __extension in "${_IMAGE_FILE_EXTENSIONS[@]}"
        do
          _grep_patterns+=("-e" "${__extension}$" "-e" "${__extension}.enc$")
        done
        grep --color=never "${_grep_patterns[@]}"
      elif [[ "${_type}" =~ ^video$|^videos$ ]]
      then
        for __extension in "${_VIDEO_FILE_EXTENSIONS[@]}"
        do
          _grep_patterns+=("-e" "${__extension}$" "-e" "${__extension}.enc$")
        done
        grep --color=never "${_grep_patterns[@]}"
      else
        grep --color=never -e "${_type}$"
      fi
    else
      cat
    fi
  }
}

# _print_line()
#
# Usage:
#   _print_line <text>
#
# Description:
#   Print a line of dashes the length of <text>.
#
# More information:
#   http://wiki.bash-hackers.org/commands/builtin/printf
_print_line() {
  local _text="${1:-}"
  local _text_length="${#_text}"
  local _line=
  printf -v _line "%*s" "${_text_length}"
  _highlight_secondary "${_line// /-}"
}

# _print_welcome()
#
# Usage:
#   _print_welcome
#
# Description:
#   Print the welcome message.
_print_welcome() {
    cat <<HEREDOC
$(_highlight_secondary "Â·----------------Â·")
$(_highlight "Welcome") to
__          _
\ \   _ __ | |__
 \ \ | '_ \| '_ \\
 / / | | | | |_) |
/_/  |_| |_|_.__/
$(_highlight_secondary "Â·----------------Â·")
HEREDOC
}

# _set_selection_notebook()
#
# Usage:
#   _set_selection_notebook <selection>
#
# Description:
#   Given <selection>, set `$_SCOPE` and `$_NOTEBOOK_PATH` with the notebook
#   name, if present.
_set_selection_notebook() {
  local _parts=()
  _parts=($(_get_selection_parts "${1:-}"))

  if [[ "${#_parts[@]}" -gt 1 ]]
  then
    _SCOPED=1
    if [[ "${_parts[0]}" == "local"       ]] &&
       [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"  ]]
    then
      _NOTEBOOK_PATH="${_LOCAL_NOTEBOOK_PATH}"
      _SCOPE="local"
    else
      _NOTEBOOK_PATH="${NB_DIR}/${_parts[0]}"
      _SCOPE="$(basename "${_NOTEBOOK_PATH}")"
    fi
  fi
}

# _spinner()
#
# Usage:
#   _spinner <pid>
#
# Description:
#   Display an ascii spinner while <pid> is running.
#
# Example Usage:
#   ```
#   _spinner_example() {
#     printf "Working..."
#     (sleep 1) &
#     _spinner $!
#     printf "Done!\\n"
#   }
#   (_spinner_example)
#   ```
#
# More Information:
#   http://fitnr.com/showing-a-bash-spinner.html
_spinner() {
  local _delay=0.75
  local _pid="${1:-}"
  local _spin_string="|/-\\"

  if [[ -z "${_pid}" ]]
  then
    _exit_1 printf "Usage: _spinner <pid>\\n"
  fi

  while ps a | awk '{print $1}' | grep -q "${_pid}"
  do
    local _temp="${_spin_string#?}"
    printf " [%c]  " "${_spin_string}"
    _spin_string="${_temp}${_spin_string%${_temp}}"
    sleep ${_delay}
    printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

# _string_is_url()
#
# Usage:
#   _string_is_url <string>
#
# Returns:
#   0  If file is a Word, Open Office, PDF, or other document.
#   1  if not.
_string_is_url() {
  [[ "${1:-}" =~ ^ftp|^http|^file|^mailto|^news|^telnet|^gopher ]]
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
#
# Examples:
# ```
#   desc "list" <<HEREDOC
# Usage:
#   ${_ME} list
#
# Description:
#   List items.
# HEREDOC
#
# desc --get "list"
# ```
#
# Set or print a description for a specified command or function <name>. The
# <description> text can be passed as the second argument or as standard input.
#
# To make the <description> text available to other functions, `desc()` assigns
# the text to a variable with the format `$___desc_<name>`.
#
# When the `--get` option is used, the description for <name> is printed, if
# one has been set.
desc() {
  set +e
  [[ -z "${1:-}" ]] && _exit_1 printf "desc(): No command name specified.\\n"

  if [[ "${1}" == "--get" ]]
  then # get ------------------------------------------------------------------
    [[ -z "${2:-}" ]] && _exit_1 printf "desc(): No command name specified.\\n"

    local _name="${2:-}"
    local _desc_var="___desc_${_name}"

    if [[ ! "${_name}" =~ ^\- ]] && [[ -n "${!_desc_var:-}" ]]
    then
      printf "%s\\n" "${!_desc_var}"
    else
      printf "No additional information for \`%s\`\\n" "${_name}"
    fi
  else # set ------------------------------------------------------------------
    if [[ -n "${2:-}" ]]
    then # argument is present
      read -r -d '' "___desc_${1}" <<HEREDOC
${2}
HEREDOC

      _debug printf "desc() set with argument: \${___desc_%s}\\n" "${1}"
    else # no argument is present, so assume piped input
      read -r -d '' "___desc_${1}"

      _debug printf "desc() set with pipe: \${___desc_%s}\\n" "${1}"
    fi
  fi
  set -e
}

###############################################################################
# help
###############################################################################

desc "help" <<HEREDOC
Usage:
  ${_ME} help [<subcommand> | --readme]

Options:
  --readme   Download and view the \`${_ME}\` README file.

Description:
  Print the program help information. When a subcommand name is passed, print
  the help information for the subcommand.

Shortcut Alias: \`h\`
HEREDOC
_help() {
  if [[ -n "${1:-}" ]] && [[ "${1:-}" =~ ^readme$|^README$|^\-\-readme$ ]]
  then
    _download_from \
      "${_REPO_RAW_URL}/README.md" \
      | if _command_exists "pandoc" && _command_exists "w3m"
        then
          pandoc --from markdown --to html \
            | w3m -T text/html
            return 0
        else
          cat
        fi |  if [[ -n "${PAGER:-}" ]] && [[ ! "${PAGER:-}" =~ less ]]
              then
                "${PAGER}"
              elif _command_exists "less"
              then
                less --CLEAR-SCREEN --prompt="$(_less_prompt)"
              else
                cat
              fi
  elif [[ -z "${1:-}" ]] || [[ "${1:-}" =~ ^\-s$|^\-\-short$ ]]
  then
    {
      cat <<HEREDOC
__          _
\ \   _ __ | |__
 \ \ | '_ \| '_ \\
 / / | | | | |_) |
/_/  |_| |_|_.__/

\`nb\` Â·Â \`notes\` && \`bookmark\`

Command line note-taking, bookmarking, and archiving with encryption, search,
Git-backed versioning and syncing, Pandoc-backed format conversion, and more
in a single portable script.

Usage:
  ${_ME} [<id> | <filename> | <path> | <title>] [<list options>...]
  ${_ME} add [<filename> | <content>] [-c <content> | --content <content>]
         [-e | --encrypt] [-f <filename> | --filename <filename>]
         [-t <title> | --title <title>] [--type <type>]
  ${_ME} bookmark [<list options>...]
  ${_ME} bookmark <url> [-c <comment> | --comment <comment>] [--edit]
              [-e | --encrypt] [-f <filename> | --filename <filename>]
              [--raw-content] [--related <url>]... [--skip-content]
              [--tags <tag1>,<tag2>...] [--title <title>]
  ${_ME} bookmark [list [<list options>...]]
  ${_ME} bookmark (open | peek | url) (<id> | <filename> | <path> | <title>)
  ${_ME} bookmark (edit | delete) (<id> | <filename> | <path> | <title>)
  ${_ME} bookmark search <query>
  ${_ME} completions (check | install [-d | --download] | uninstall)
  ${_ME} count
  ${_ME} delete (<id> | <filename> | <path> | <title>) [-f | --force]
  ${_ME} edit (<id> | <filename> | <path> | <title>)
          [-e <editor> | --editor <editor>]
  ${_ME} export (<id> | <filename> | <path> | <title>) <path> [-f | --force]
            [<pandoc options>...]
  ${_ME} export notebook <name> [<path>]
  ${_ME} git <git options>...
  ${_ME} help [<subcommand> | --readme]
  ${_ME} history [<id> | <filename> | <path> | <title>]
  ${_ME} import [copy | download | move] (<path> | <url>) [--convert]
  ${_ME} import notebook <path> [<name>]
  ${_ME} init [<remote-url>]
  ${_ME} list [-e [<length>] | --excerpt [<length>]] [--filenames] [--no-id]
          [-n <limit> | --<limit>] [-s | --sort] [-r | --reverse]
          [-t <type> | --type <type> | --<type>]
          [<id> | <filename> | <path> | <title> | <query>]
  ${_ME} ls [<list options>...]
  ${_ME} move (<id> | <filename> | <path> | <title>) [-f | --force] <notebook>
  ${_ME} notebooks [<name>] [--archived] [--global] [--local] [--names]
               [--no-color] [--paths] [--unarchived]
  ${_ME} notebooks add <name> [<remote-url>]
  ${_ME} notebooks (archive | open | peek | status | unarchive) [<name>]
  ${_ME} notebooks current [--path]
  ${_ME} notebooks delete <name> [-f | --force]
  ${_ME} notebooks (export <name> [<path>] | import <path>)
  ${_ME} notebooks init [<path> [<remote-url>]]
  ${_ME} notebooks rename <old-name> <new-name>
  ${_ME} notebooks use <name>
  ${_ME} open (<id> | <filename> | <path> | <title>)
  ${_ME} peek (<id> | <filename> | <path> | <title>)
  ${_ME} remote [remove | set <url> [-f | --force]]
  ${_ME} rename (<id> | <filename> | <path> | <title>) [-f | --force]
            (<name> | --reset | --to-bookmark | --to-note)
  ${_ME} search <query> [-a | --all] [-t <type> | --type <type> | --<type>]
                    [-l | --list] [--path]
  ${_ME} settings [<number> | <name>] [colors [<number>] | edit | list [--long]]
  ${_ME} settings (get | show | unset) (<number> | <name>)
  ${_ME} settings set (<number> | <name>) <value>
  ${_ME} shell [<subcommand> [<options>...] | --clear-history]
  ${_ME} show (<id> | <filename> | <path> | <title>) [--dump [--no-color]]
          [--filename | --id | --path | --render | --title]
  ${_ME} sync [-a | --all]
  ${_ME} use <notebook>
  ${_ME} -i | --interactive [<subcommand> [<options>...]]
  ${_ME} -h | --help | help [<subcommand> | --readme]
  ${_ME} --version | version

Help:
  ${_ME} help <subcommand>  View help information for <subcommand>
  ${_ME} help --readme      Download and view the \`${_ME}\` README file.

More Information:
  https://github.com/${_REPO}
HEREDOC

    if [[ ! "${1:-}" =~ ^\-s$|^\-\-short$ ]]
    then
      cat <<HEREDOC

Subcommands:
  (default)    List notes and notebooks. This is an alias for \`${_ME} ls\`.
  add          Add a new note.
  bookmark     Add, open, list, and search bookmarks.
  completions  Install and uninstall completion scripts.
  count        Print the number of notes.
  delete       Delete a note.
  edit         Edit a note.
  export       Export a note to a variety of different formats.
  git          Alias for \`git\` within the current notebook.
  help         Display this help information.
  history      Display git history for the current notebook or a note.
  import       Import a file into the current notebook.
  init         Initialize the first notebook.
  list         List notes in the current notebook.
  ls           List notebooks and notes in the current notebook.
  move         Move a note to a different notebook.
  notebooks    Manage notebooks.
  open         Open a bookmark in the primary web browser or edit a note.
  peek         View a bookmark in the terminal web browser or show a note.
  remote       Get, set, and remove the remote URL for the notebook.
  rename       Rename a note.
  search       Search notes.
  settings     Edit configuration settings.
  shell        Start the \`${_ME}\` interactive shell.
  show         Show a note.
  status       Run \`git status\` in the current notebook.
  sync         Sync local notebook with the remote repository.
  use          Switch to a notebook.
  version      Display version information.

Program Options:
  -i, --interactive   Start the \`${_ME}\` interactive shell.
  -h, --help          Display this help information.
  --version           Display version information.
HEREDOC
      fi
    } | if [[ -n "${PAGER:-}" ]] && [[ ! "${PAGER:-}" =~ less ]]
        then
          "${PAGER}"
        elif _command_exists "less"
        then
          less --CLEAR-SCREEN --prompt="$(_less_prompt)"
        else
          cat
        fi
  else
    local _help_text=
    _help_text="$(desc --get "${@}")"

    local _help_text_lines=
    _help_text_lines="$(printf "%s\\n" "${_help_text}" | wc -l)"

    local _lines=
    _lines="$(tput lines)"

    printf "%s\\n" "${_help_text}" \
      | if [[ "${_help_text_lines}" -gt "$((_lines-2))" ]] &&
           [[ -n "${PAGER:-}"                           ]] &&
           [[ ! "${PAGER:-}" =~ less                    ]]
        then
          "${PAGER}"
        elif [[ "${_help_text_lines}" -gt "$((_lines-2))" ]] &&
             _command_exists "less"
        then
          less --CLEAR-SCREEN --prompt="$(_less_prompt)"
        else
          cat
        fi
  fi
}
_alias_subcommand "help" "h"

###############################################################################
# Subcommands
###############################################################################

# add ##################################################################### add

desc "add" <<HEREDOC
Usage:
  ${_ME} add [<filename> | <content>] [-c <content> | --content <content>]
         [-e | --encrypt] [-f <filename> | --filename <filename>]
         [-t <title> | --title <title>] [--type <type>]

Options:
  -c, --content <content>     The content for the new note.
  -e, --encrypt               Encrypt the note with a password.
  -f, --filename <filename>   The filename for the new note.
  -t, --title <title>         The title for a new note. If \`--title\` is
                              present, the filename will be derived from the
                              title, unless \`--filename\` is specified.
  --type <type>               The file type for the new note, as a file
                              extension.

Description:
  Create a new note.

  If no arguments are passed, a new blank note file is opened with
  \`\$EDITOR\`, currently set to '${EDITOR}'. If a non-option argument is
  passed, \`${_ME}\` will treat it as a <filenameâ‰¥ if a file extension is found.
  If no file extension is found, \`${_ME}\` will treat the string as
  <content> and will create a new note without opening the editor.
  \`${_ME} add\` can also create a new note with piped content.

  \`${_ME}\` creates Markdown files by default. To create a note with a
  different file type, use the extension in the filename or use the \`--type\`
  option. To change the default file type, use \`${_ME} settings\`.

  When the \`-e\` / \`--encrypt\` option is used, \`${_ME}\` will encrypt the
  note with AES-256 using OpenSSL by default, or GPG, if configured in
  \`${_ME} settings\`.

Examples:
  ${_ME} add
  ${_ME} add example.md
  ${_ME} add "Note content."
  ${_ME} add example.md --title "Example Title" --content "Example content."
  echo "Note content." | ${_ME} add
  ${_ME} add -t "Secret Document" --encrypt

Aliases: \`create\`, \`new\`
Shortcut Alias: \`a\`
HEREDOC
_add() {
  local _arguments=()
  local _basename=
  local _content=
  local _edit_before_save=0
  local _encrypt=0
  local _filename=
  local _file_type="${NB_DEFAULT_EXTENSION}"
  local _maybe_filename_or_content=
  local _password=
  local _title=

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      -c|--content)
        _content="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --edit)
        _edit_before_save=1
        ;;
      -e|--encrypt|--encrypted)
        _encrypt=1
        ;;
      -f|--filename)
        _filename="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --password)
        _password="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      -t|--title)
        _title="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --type)
        _file_type="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      *)
        if [[ -z "${_maybe_filename_or_title:-}" ]]
        then
          _maybe_filename_or_content="${__arg:-}"
        else
          _arguments+=("${__arg:-}")
        fi
        ;;
    esac

    shift
  done

  local _maybe_filename_or_content_extension="${_maybe_filename_or_content##*\.}"
  if [[ -n "${_maybe_filename_or_content:-}" ]]
  then
    if [[ "${_maybe_filename_or_content:-}" =~ \.[A-Za-z0-9]+$  ]] &&
       [[ -n "${_maybe_filename_or_content_extension:-}"        ]] &&
       [[ -z "${_filename}"                                     ]]
    then
      _filename="${_maybe_filename_or_content}"
    else
      _content="${_maybe_filename_or_content}"
    fi
  fi

  if [[ -n "${_filename:-}" ]]
  then
    _basename="$(_get_unique_basename "${_filename:-}")"
  elif [[ -n "${_title:-}" ]]
  then
    _filename="$(printf "%s" "${_title}" | tr '[:space:]' '_')"
    _basename="$(_get_unique_basename "${_filename}.${_file_type}")"
  else
    _basename="$(_get_unique_basename ".${_file_type}")" # !! note the '.'
  fi

  _target_path="${_NOTEBOOK_PATH}/${_basename}"

  if ((_encrypt))
  then
    if [[ -z "${_password}" ]]
    then
      printf "Password: "
      read -r -s _password </dev/tty
      printf "\\n" # print newline to stop `read`.

      if [[ -z "${_password:-}" ]]
      then
        _exit_1 printf "Password required.\\n"
      fi
    fi

    _target_path="$(_tempfile_path "${_basename}")"
  fi

  if [[ -n "${_title}" ]]
  then
    printf "%s\\n\\n" "# ${_title}" >> "${_target_path}"
  fi

  if [[ -n "${_content}" ]]
  then
    printf "%s\\n" "${_content}" >> "${_target_path}"
  fi

  if ! _interactive_input
  then # piped input
    cat >> "${_target_path}"
  fi

  if ((_edit_before_save)) || _interactive_input && [[ -z "${_content:-}" ]]
  then
    _edit_file "${_target_path}"
  fi

  if ((_encrypt)) && [[ -e "${_target_path}" ]]
  then
    local _decrypted_path="${_target_path}"
    local _encrypted_path="${_NOTEBOOK_PATH}/${_basename}.enc"

    _encrypt_file "${_decrypted_path}" "${_encrypted_path}" "${_password}"

    if [[ -n "${_decrypted_path}" ]] && [[ -e "${_decrypted_path}" ]]
    then
      rm "${_decrypted_path}"
    fi

    _basename="${_basename}.enc"
    _target_path="${_encrypted_path}"
  fi

  _debug printf \
    "_add() \`\${_target_path}\`: '%s'\\n" \
    "${_target_path:-}"

  if [[ -e "${_target_path}" ]]
  then
    _index add "${_basename}"

    local _id
    _id="$(_index get_id "${_basename}")"

    local _scoped_basename="${_basename}"

    if ((_SCOPED))
    then
      local _notebook_identifier
      _notebook_identifier="$(_get_notebook_identifier "${_SCOPE}")"
      _id="${_notebook_identifier}:${_id}"
      _scoped_basename="${_notebook_identifier}:${_basename}"
    fi

    local _title
    _title="$(_get_title "${_NOTEBOOK_PATH}/${_basename}")"
    if [[ -n "${_title}" ]]
    then
      printf "Added %s %s '%s'\\n"            \
        "$(_id_brackets_color "${_id}")"      \
        "$(_highlight "${_scoped_basename}")" \
        "${_title}"
    else
      printf "Added %s %s\\n"                 \
        "$(_id_brackets_color "${_id}")"      \
        "$(_highlight "${_scoped_basename}")"
    fi
  fi &&
    _git_checkpoint "[nb] Add: ${_basename}"
}
_alias_subcommand "add" "a"
_alias_subcommand "add" "create"
_alias_subcommand "add" "new"

# bookmark ########################################################### bookmark

desc "bookmark" <<HEREDOC
Usage:
  ${_ME} bookmark [<list options>...]
  ${_ME} bookmark <url> [-c <comment> | --comment <comment>] [--edit]
              [-e | --encrypt] [-f <filename> | --filename <filename>]
              [--raw-content] [--related <url>]... [--skip-content]
              [--tags <tag1>,<tag2>...] [--title <title>]
  ${_ME} bookmark list [<list options>...]
  ${_ME} bookmark (open | peek | url) (<id> | <filename> | <path> | <title>)
  ${_ME} bookmark (edit | delete) (<id> | <filename> | <path> | <title>)
  ${_ME} bookmark search <query>

Options:
  -c, --comment <comment>    A comment or description for this bookmark.
  --edit                     Open the bookmark in your editor before saving.
  -e, --encrypt              Encrypt the bookmark with a password.
  -f, --filename <filename>  The filename for the new note.
  --raw-content              Save the page content as HTML.
  --related <url>            A URL for a page related to the bookmarked page.
                             Multiple \`--related\` flags can be used in a
                             command to save multiple related URLs.
  --skip-content             Omit page content from the note.
  --tags <tag1>,<tag2>...    A comma-separated list of tags.
  --title <title>            The bookmark title. When not specified,
                             \`${_ME}\` will use the html <title> tag.

Subcommands:
  (default)  Add a new bookmark for <url>, or list bookmarks.
  delete     Delete a bookmark.
  edit       Edit a bookmark.
  list       List bookmarks in the current notebook.
             Shortcut Alias: \`ls\`
  open       Open the bookmarked page in your system's primary web browser.
             Shortcut Alias: \`o\`
  peek       Open the bookmarked page in your terminal web browser.
             Alias: \`preview\`
             Shortcut Alias: \`p\`
  search     Search bookmarks for <query>.
             Shortcut Alias: \`q\`
  url        Print the URL for the specified bookmark.

Description:
  Create, view, search, edit, and delete bookmarks.

  By default, the html page content is saved within the bookmark, making the
  bookmarked page available for full-text search. When \`pandoc\` is
  installed, the HTML content will be converted to Markdown before saving.

  Bookmarks are identified by the \`.bookmark.md\` file extension. The
  bookmark URL is the first URL in the file within '<' and '>' characters:

    <https://www.example.com>

Examples:
  ${_ME} bookmark https://example.com
  ${_ME} bookmark https://example.com --tags example,sample,demo
  ${_ME} bookmark https://example.com/about -c 'Example comment.'
  ${_ME} bookmark list
  ${_ME} bookmark search 'example query'
  ${_ME} bookmark open 5

Shortcut Alias: \`b\`
HEREDOC
_bookmark() {
  # Usage: _bookmark_view_in_terminal_browser (<url>)
  _bookmark_view_in_terminal_browser() {
    _target_url="${1:-}"
    if _command_exists 'w3m'
    then
      w3m "${_target_url}"
      return 0
    elif _command_exists 'lynx'
    then
      lynx "${_target_url}"
      return 0
    elif _command_exists "curl" || _command_exists "wget"
    then
      _download_from "${_target_url}" \
        | if [[ -n "${PAGER:-}" ]] && [[ ! "${PAGER:-}" =~ less ]]
            then
              "${PAGER}"
            elif _command_exists "less"
            then
              less --CLEAR-SCREEN --prompt="$(_less_prompt)"
            else
              cat
            fi

      return 0
    else
      _exit_1 printf "Terminal web browser not detected.\\n"
    fi
  }

  local _arguments=()
  local _bookmark_content=
  local _comment=
  local _edit_before_save=0
  local _encrypt=0
  local _filename=
  local _password=
  local _raw_content=0
  local _selection=
  local _skip_content=0
  local _subcommand=
  local _tag_list=
  local _title=
  local _url=
  local _related_urls=()

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      -c|--comment)
        _comment="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --edit)
        _edit_before_save=1
        ;;
      -e|--encrypt|--encrypted)
        _encrypt=1
        ;;
      -f|--filename)
        _filename="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --password)
        _password="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --raw-content)
        _raw_content=1
        ;;
      --skip-content)
        _skip_content=1
        ;;
      --tags)
        _tag_list="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --title)
        _title="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --via|--also|--related)
        _related_urls+=("$(__option_get_value "${__arg}" "${__val:-}")")
        shift
        ;;
      delete)
        _delete "${__val:-}" "${3:-}"
        return 0
        ;;
      edit)
        _edit "${__val:-}"
        return 0
        ;;
      help)
        _help "bookmark"
        return 0
        ;;
      ls|list)
        _subcommand="list"
        ;;
      search|q)
        _subcommand="search"
        ;;
      open|o|peek|p|preview|url)
        if __option_value_is_present "${__val:-}"
        then
          if [[ "${__arg}" =~ ^open$|^o$ ]]
          then
            _subcommand="open"
          elif [[ "${__arg}" =~ ^peek$|^p$|^preview$ ]]
          then
            _subcommand="peek"
          elif [[ "${__arg}" == "url" ]]
          then
            _subcommand="url"
          fi

          _selection="${__val:-}"

          shift
        else
          _exit_1 \
            printf "%s requires a valid argument.\\n"  \
            "$(_highlight "bookmark ${__arg}")"
        fi
        ;;
      *)
        if [[ ! "${_subcommand:-}" =~ ^list$|^search$ ]] &&
           [[ -z "${_url:-}" ]]
        then
          _url="${__arg:-}"
        elif [[ "${_subcommand:-}" =~ ^list$|^search$ ]]
        then
          _arguments+=("${__arg}")
        fi
        ;;
    esac

    shift
  done

  # `bookmark list`
  if [[ "${_subcommand}" == "list" ]]
  then
    if [[ -n "${_arguments[*]:-}" ]]
    then
      _list --bookmarks "${_arguments[@]}"
      return 0
    else
      _list --bookmarks
      return 0
    fi
  fi

  # `bookmark search`
  if [[ "${_subcommand}" == "search" ]]
  then
    _search --bookmarks "${_arguments[@]}"
    return 0
  fi

  # `bookmark open`, `bookmark peek`, `bookmark url`
  if [[ "${_subcommand}" =~ ^open$|^peek$|^url$ ]]
  then
    local _basename=
    _basename="$(_get_selection_basename "${_selection}")"
    if [[ -z "${_basename}" ]]
    then
      _exit_1 printf "Note not found: %s\\n" "$(_highlight "${_selection}")"
    fi
    _set_selection_notebook "${_selection}"

    local _target_path="${_NOTEBOOK_PATH}/${_basename}"

    # handle non-bookmarks
    if [[ "${_subcommand}" =~ ^open$|^peek$ ]]
    then
      if [[ "${_basename}" =~ \.html$ ]]
      then
        if [[ "${_subcommand}" == "open"  ]]
        then
          if _command_exists "xdg-open"
          then
            xdg-open "${_target_path}" && return 0
          elif [[ "${OSTYPE}" =~ ^darwin ]]
          then
            open "${_target_path}" && return 0
          fi
        elif [[ "${_subcommand}" == "peek" ]]
        then
          _bookmark_view_in_terminal_browser "file://${_target_path}"
          return 0
        fi
      elif [[ ! "${_basename}" =~ .bookmark\.md$      ]] &&
           [[ ! "${_basename}" =~ .bookmark\.md\.enc$ ]]
      then
        if [[ "${_subcommand}" == "open" ]]
        then
          if [[ -n "${_password}" ]]
          then
            _edit "${_selection}" --password "${_password}"
          else
            _edit "${_selection}"
          fi
        elif [[ "${_subcommand}" == "peek" ]]
        then
          if [[ -n "${_password}" ]]
          then
            _show "${_selection}" --password "${_password}"
          else
            _show "${_selection}"
          fi
        fi

        return 0
      fi
    fi

    if _file_is_encrypted "${_target_path}"
    then
      local _encrypted_path=
      _encrypted_path="${_target_path}"

      if [[ -z "${_password}" ]]
      then
        # Request password without displaying it
        printf "Password: "
        read -r -s _password </dev/tty
        printf "\\n" # print newline to stop `read`.
      fi

      if [[ -z "${_password}" ]]
      then
        _exit_1 printf "Password required.\\n"
      fi

      _target_path="$(_decrypt_file "${_target_path}" "${_password}")"
    fi

    local _target_url=
    _target_url="$(
      awk 'match($0, /<((ftp|http|file|mailto|news|telnet|gopher).*)>/) {
        print substr($0, RSTART+1, RLENGTH-2); exit
      }' "${_target_path}"
    )"

    if [[ "${_subcommand}" =~ ^open$|^peek$ ]]
    then
      local _check_wayback=0
      local _http_error_codes=(
        404 408 410 451 500 502 503 504 509 520 521 523 524 525 526
      )
      local _http_status=
      _http_status="$(_get_http_status "${_target_url}")"

      if _contains "${_http_status}" "${_http_error_codes[@]}"
      then
        printf "Page no longer available: %s\\n" \
          "$(_highlight "${_target_url}")"
        while true
        do
          read -r -p "\
Check the Wayback Machine for an archived version? [y/N] " __yn
          case ${__yn} in
            [Yy]*)
              _check_wayback=1
              break
              ;;
            *)
              printf "Exiting...\\n"
              exit 0
              ;;
          esac
        done
      fi

      if ((_check_wayback))
      then
        local _wayback_response
        _wayback_response="$(
          _download_from \
            "https://archive.org/wayback/available?url=${_target_url}"  \
            | grep --color=never 'closest'                              \
            | sed -E 's/.*"closest": {([^}]+)}.*/\1/g'                  \
            | sed -E 's/.*"url": "([^"]+)".*/\1/g' || printf ""

        )"
        if [[ -n "${_wayback_response:-}" ]]
        then
          _target_url="${_wayback_response}"
        else
          _exit_1 \
            printf "No archived version available from the Wayback Machine.\\n"
        fi
      fi
    fi

    # `bookmark peek`
    if [[ "${_subcommand}" == "peek" ]]
    then
      _bookmark_view_in_terminal_browser "${_target_url}"
      return 0
    # `bookmark open`
    elif [[ "${_subcommand}" == "open" ]]
    then
      if _command_exists "xdg-open"
      then
        xdg-open "${_target_url}"
        return 0
      elif _command_exists "open"
      then
        open "${_target_url}"
        return 0
      else
        _exit_1 printf \
          "%s doesn't know how to open URLs on your system.\\n" \
          "$(_highlight "${_ME}")"
      fi
    # `bookmark url`
    elif [[ "${_subcommand}" == "url" ]]
    then
      printf "%s\\n" "${_target_url}"
      return 0
    fi
  fi

  # `bookmark`
  if [[ -z "${_url:-}" ]]
  then
    local _header=
    _header="Add: $(_highlight "${_ME} bookmark <url>")"
    _header="${_header} Help: $(_highlight "${_ME} help bookmark")"
cat <<HEREDOC
${_header}
$(_highlight_secondary "---------------------------------------------")
HEREDOC
    _bookmark list
    return 0
  elif [[ ! "${_url}" =~ ^ftp|^http|^file|^mailto|^news|^telnet|^gopher ]]
  then
    if [[ -n "${_arguments[*]:-}" ]]
    then
      _arguments=("${_url}" "${_arguments[@]:-}")
    else
      _arguments=("${_url}")
    fi
    _bookmark list "${_arguments[@]}"
    return 0
  fi

  # `bookmark <url>`
  local _temp_file=
  _temp_file="$(mktemp)"

  if ! _download_from "${_url}" "${_temp_file}" ||
     [[ ! -e "${_temp_file}"                 ]] ||
     [[ "$(wc -c <"${_temp_file}")" == 0     ]]
  then
    _exit_1 \
      printf "Unable to download page at %s\\n" "$(_highlight "${_url}")"
  fi

  if [[ -z "${_title}" ]] && _file_is_text "${_temp_file}"
  then
    _title="$(
      cat "${_temp_file}"                               \
        | grep -o -E -i '.*<title[^>]*>[^<]*</title>'   \
        | head -1                                       \
        | sed 's/.*<title[^>]*>//'                      \
        | sed 's/.*<TITLE[^>]*>//'                      \
        | sed 's/<\/title>.*//'                         \
        | sed 's/<\/TITLE>.*//'
    )" || : # TODO: pipeline returns error status but still returns title
    local _domain
    _domain="$(printf "%s\\n" "${_url}" | awk -F[/:] '{print $4}')"
    if [[ -n "${_domain}" ]]
    then
      _title+=" (${_domain})"
    fi
  fi

  if [[ -n "${_title:-}" ]]
  then
    if _command_exists "w3m"
    then # convert html entities
      _title="$(
        printf "%s\\n" "${_title}" | w3m -dump -T text/html -cols 1000
      )"
    fi

    _bookmark_content="# ${_title}${_NEWLINE}${_NEWLINE}"
  fi

  _bookmark_content+="<${_url}>${_NEWLINE}"

  if _file_is_text "${_temp_file}"
  then
    local _description=
    _description="$(
       cat "${_temp_file}"  \
        | sed -E -n         \
          's/.*<meta .*name=.description.[^>]*content="([^"]+)".*/\1/p'
    )"

    if [[ -z "${_description:-}" ]]
    then
      _description="$(
       cat "${_temp_file}"  \
          | sed -E -n       \
            's/.*<meta .*property=.og:description[^>]*content="([^"]+)".*/\1/p'
      )"
    fi

    if [[ -n "${_description}" ]]
    then
      if _command_exists "w3m"
      then # convert html entities
        _description="$(
          printf "%s\\n" "${_description}" | w3m -dump -T text/html -cols 1000
        )"
      fi

      _bookmark_content+="${_NEWLINE}## Description${_NEWLINE}"
      _bookmark_content+="${_NEWLINE}${_description}${_NEWLINE}"
    fi
  fi

  if [[ -n "${_related_urls[*]:-}" ]]
  then
    _bookmark_content+="${_NEWLINE}## Related${_NEWLINE}${_NEWLINE}"

    for __related_url in "${_related_urls[@]:-}"
    do
      _bookmark_content+="- <${__related_url}>${_NEWLINE}"
    done
  fi

  if [[ -n "${_comment}" ]]
  then
    _bookmark_content+="${_NEWLINE}## Comment${_NEWLINE}"
    _bookmark_content+="${_NEWLINE}${_comment}${_NEWLINE}"
  fi

  if [[ -n "${_tag_list}" ]]
  then
    local _tags=()
    local _tag_string=

    IFS=',' read -ra _tags <<< "${_tag_list}"
    for __tag in "${_tags[@]:-}"
    do
      local _normalized_tag
      _normalized_tag="$(printf "%s\\n" "${__tag}" | tr -d '#')"

      if [[ -z "${_tag_string}" ]]
      then
        _tag_string+="#${_normalized_tag}"
      else
        _tag_string+=" #${_normalized_tag}"
      fi
    done

    _bookmark_content+="${_NEWLINE}## Tags${_NEWLINE}"
    _bookmark_content+="${_NEWLINE}${_tag_string}${_NEWLINE}"
  fi

  if ! ((_skip_content)) && _file_is_text "${_temp_file}"
  then
    if ! ((_raw_content)) &&
       _command_exists "pandoc"
    then
      _bookmark_content+="${_NEWLINE}## Page Content${_NEWLINE}"

      local _processed_content
      _processed_content="$(
        cat "${_temp_file}"                       \
          | pandoc                                \
            --from html-native_divs-native_spans  \
            --to markdown-grid_tables --wrap=none \
            2>/dev/null || cat "${_temp_file}"
        )"
      _bookmark_content+="${_NEWLINE}${_processed_content}${_NEWLINE}"
    else
      _bookmark_content+="${_NEWLINE}## Page Content (HTML)${_NEWLINE}"
      _bookmark_content+="${_NEWLINE}$(cat "${_temp_file}")${_NEWLINE}"
    fi
  fi

  if [[ -n "${_bookmark_content}" ]]
  then
    local _basename=

    if [[ -z "${_filename:-}" ]]
    then
      _basename="$(_get_unique_basename "$(date -u '+%Y%m%d%H%M%S').bookmark.md")"
    else
      if [[ "${_filename}" =~ \. ]]
      then
        _basename="$(_get_unique_basename "${_filename}")"
      else
        _basename="$(_get_unique_basename "${_filename}.bookmark.md")"
      fi
    fi

    local _add_options=("--filename" "${_basename}")

    ((_encrypt))              && _add_options+=("--encrypt")
    ((_edit_before_save))     && _add_options+=("--edit")
    [[ -n "${_password:-}" ]] && _add_options+=("--password" "${_password}")

    printf "%s" "${_bookmark_content}" | _add "${_add_options[@]}"

    [[ -f "${_temp_file:-}" ]] && rm "${_temp_file}"
  fi
}
_alias_subcommand "bookmark" "b"
_alias_subcommand "bookmark" "bookmarks"

# commands ########################################################### commands

desc "commands" <<HEREDOC
Usage:
  ${_ME} commands

Description:
  List available commands.
HEREDOC
_commands() {
  printf "%s\\n" "${_DOCUMENTED_SUBCOMMANDS[*]}"
}
_alias_subcommand "commands" "subcommands"

# completions ##################################################### completions

desc "completions" <<HEREDOC
Usage:
  ${_ME} completions (check | install [-d | --download] | uninstall)

Options:
  -d, --download  Download the completion scripts and install.

Description:
  Manage completion scripts. For more information, visit:
  https://github.com/${_REPO}/blob/master/etc/README.md
HEREDOC
_completions() {
  local _BASH_COMP_NAME="nb"
  local _ZSH_COMP_NAME="_nb"

  # Usage: _completions_check
  _completions_check() {
    local _bash_completion_path=
    _bash_completion_path="$(_get_bash_completion_path)"

    local _exists=0

    if [[ -n "${_bash_completion_path:-}" ]] &&
       [[ -d "${_bash_completion_path}"   ]]
    then
      if [[ -w "${_bash_completion_path}"   ]]
      then
        if [[ -e "${_bash_completion_path}/${_BASH_COMP_NAME}" ]]
        then
          _exists=1
          printf "Exists: %s\\n" "${_bash_completion_path}/${_BASH_COMP_NAME}"
        fi
      else
        printf "Permission denied: %s\\n" "${_bash_completion_path}"
      fi
    fi

    local _zsh_completion_path="/usr/local/share/zsh/site-functions"

    if [[ -d "${_zsh_completion_path}" ]]
    then
      if [[ -w "${_zsh_completion_path}" ]]
      then
        if [[ -e "${_zsh_completion_path}/${_ZSH_COMP_NAME}" ]]
        then
          _exists=1
          printf "Exists: %s\\n" "${_zsh_completion_path}/${_ZSH_COMP_NAME}"
        fi
      else
        printf "Permission denied: %s\\n" "${_zsh_completion_path}"
      fi
    fi

    if ! ((_exists))
    then
      _exit_1 printf "Completion scripts not found.\\n"
    fi
  }

  # Usage: _get_bash_completion_path
  _get_bash_completion_path() {
    local _bash_completion_path=

    if [[ -n "${BASH_COMPLETION_COMPAT_DIR:-}" ]]
    then
      _bash_completion_path="${BASH_COMPLETION_COMPAT_DIR}"
    fi

    if [[ -z "${_bash_completion_path:-}" ]]
    then
      local _maybe_path
      _maybe_path="$(
        pkg-config \
          --variable=completionsdir bash-completion 2>/dev/null || true
      )"

      if [[ -n "${_maybe_path:-}" ]]
      then
        _bash_completion_path="${_maybe_path}"
      fi
    fi

    if [[ -z "${_bash_completion_path:-}"       ]] &&
       [[ -d "/usr/local/etc/bash_completion.d" ]]
    then
      _bash_completion_path="/usr/local/etc/bash_completion.d"
    fi

    if [[ -z "${_bash_completion_path:-}" ]] &&
       [[ -d "/etc/bash_completion.d"     ]]
    then
      _bash_completion_path="/etc/bash_completion.d"
    fi

    printf "%s\\n" "${_bash_completion_path:-}"
  }

  # Usage: _completions_install [--download]
  _completions_install() {
    local _download=0
    if [[ "${1:-}" == "--download" ]]
    then
      _download=1
    fi

    local _my_dir=
    _my_dir="$(cd "$(dirname "$(realpath "$0")")"; pwd)"
    if [[ -z "${_my_dir}" ]] || [[ ! -d "${_my_dir}" ]]
    then
      exit 1
    fi

    if [[ -z "${_REPO:-}" ]] || [[ -z "${_REPO_RAW_URL:-}" ]]
    then
      _exit_1 printf "Source Git repository not configured.\\n"
    fi

    for _shell in bash zsh
    do
      local _completion_source="${_my_dir}/etc/${_ME}-completion.${_shell}"

      if ((_download))
      then
        if [[ ! -f "${_completion_source}" ]]
        then
          _completion_source="$(mktemp)"
          local _completion_url="${_REPO_RAW_URL}/etc/${_ME}-completion.${_shell}"

          if ! _download_from "${_completion_url}" "${_completion_source}"
          then
            _exit_1 printf "Unable to download Completion script from %s\\n" \
              "${_completion_source}"
          fi
        fi
      fi

      if [[ ! -f "${_completion_source}" ]]
      then
        cat <<HEREDOC
Unable to find source ${_shell} completion script. You can try downloading
and installing the latest version with the following command (\`sudo\` might
be necessary):
  ${_ME} completions install --download

More information: ${_shell}
  https://github.com/${_REPO}/blob/master/etc/README.md
HEREDOC
      else
        local _completion_path=
        local _completion_target=
        if [[ "${_shell}" == "bash" ]]
        then
          _completion_path="$(_get_bash_completion_path)"
          _completion_target="${_completion_path}/${_BASH_COMP_NAME}"
        elif [[ "${_shell}" == "zsh" ]]
        then
          _completion_path="/usr/local/share/zsh/site-functions"
          _completion_target="${_completion_path}/${_ZSH_COMP_NAME}"
        fi

        if [[ -n "${_completion_path:-}" ]] &&
           [[ -d "${_completion_path}"   ]]
        then
          if [[ -w "${_completion_path}" ]]
          then
            if [[ ! -e "${_completion_target}" ]]
            then
              cp \
                "${_completion_source}" \
                "${_completion_target}"
              chmod +r "${_completion_target}"
              printf "Completion script installed: %s\\n" \
                "${_completion_target}"
            else
              printf "Exists: %s\\n" "${_completion_target}"
            fi
          else
            printf "Permission denied: %s\\n" "${_completion_path}"
          fi
        fi
      fi
    done
  }

  # Usage: _completions_uninstall
  _completions_uninstall() {
    local _completion_path=
    local _completion_target=

    for _shell in bash zsh
    do
      if [[ "${_shell}" == "bash" ]]
      then
        _completion_path="$(_get_bash_completion_path)"
        _completion_target="${_completion_path}/${_BASH_COMP_NAME}"
      elif [[ "${_shell}" == "zsh" ]]
      then
        _completion_path="/usr/local/share/zsh/site-functions"
        _completion_target="${_completion_path}/${_ZSH_COMP_NAME}"
      fi

      if [[ -n "${_completion_path:-}" ]] &&
         [[ -d "${_completion_path}"   ]]
      then
        if [[ -w "${_completion_path}"   ]] &&
           [[ -w "${_completion_target}" ]]
        then
          if [[ -f "${_completion_target}" ]]
          then
            rm "${_completion_target}"
            printf "Completion script removed: %s\\n" \
              "${_completion_target}"
          fi
        else
          printf "Permission denied: %s\\n" "${_completion_path}"
        fi
      fi
    done
  }

  local _subcommand="${1:-}"

  case "${_subcommand}" in
    check)
      _completions_check
      ;;
    install)
      if [[ "${2:-}" =~ ^-d|--download$ ]]
      then
        _completions_install --download
      else
        _completions_install
      fi
      ;;
    uninstall)
      _completions_uninstall
      ;;
    *)
      _help "completions"
      return 0
      ;;
  esac
}

# count ################################################################# count

desc "count" <<HEREDOC
Usage:
  ${_ME} count

Description:
  Print the number of items in the current notebook.
HEREDOC
_count() {
  _list_nb_files | wc -l
}

# delete ############################################################### delete

desc "delete" <<HEREDOC
Usage:
  ${_ME} delete (<id> | <filename> | <path> | <title>) [-f | --force]

Options:
  -f, --force   Skip the confirmation prompt.

Description:
  Delete a note.

Examples:
  ${_ME} delete 3
  ${_ME} delete example.md
  ${_ME} delete 'A Document Title'

Shortcut Alias: \`d\`
HEREDOC
_delete() {
  local _basename=
  local _force=0
  local _note_info_line=
  local _selection=
  local _title=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_delete() \${_selection}: '%s'\\n" "${_selection}"
  if [[ -z "${_selection:-}" ]]
  then
    _exit_1 _help "delete"
  fi

  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_delete() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    _exit_1 printf "Note not found: %s\\n" "$(_highlight "${_selection}")"
  fi

  _set_selection_notebook "${_selection}"

  local _id
  _id="$(_index get_id "${_basename}")"

  local _scoped_basename="${_basename}"

  if ((_SCOPED))
  then
    local _notebook_identifier
    _notebook_identifier="$(_get_notebook_identifier "${_SCOPE}")"
    _id="${_notebook_identifier}:${_id}"
    _scoped_basename="${_notebook_identifier}:${_basename}"
  fi

  local _note_info_hi
  _note_info_hi="$(_id_brackets_color "${_id}") $(_highlight "${_scoped_basename}")"

  _title="$(_get_title "${_NOTEBOOK_PATH}/${_basename}")"
  if [[ -n "${_title}" ]]
  then
    _note_info_line="${_note_info_hi} '${_title}'"
  else
    _note_info_line="${_note_info_hi}"
  fi

  if ! ((_force))
  then
    printf "Deleting %s\\n" "${_note_info_line}"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  if [[ -n "${_basename}" ]] && [[ -e "${_NOTEBOOK_PATH}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    cd "${_NOTEBOOK_PATH}" || _exit_1 printf "_delete() \`cd\` failed.\\n"

    if [[ -d "${_NOTEBOOK_PATH}/${_basename}" ]] &&
       [[ -z "$(ls -A "${_NOTEBOOK_PATH}/${_basename}")" ]]
    then
      rm -r "${_NOTEBOOK_PATH:?}/${_basename}"
    else
      git rm -r "${_basename}" 1>/dev/null
    fi

    if [[ ! -e "${_NOTEBOOK_PATH}/${_basename}" ]]
    then
      _index delete "${_basename}"
      _git_checkpoint "[nb] Delete: ${_basename}"
      printf "Deleted %s\\n" "${_note_info_line}"
    fi
  else
    _exit_1 printf "Selection not found.\\n"
  fi
}
_alias_subcommand "delete" "d"

# edit ################################################################### edit

desc "edit" <<HEREDOC
Usage:
  ${_ME} edit (<id> | <filename> | <path> | <title>)
          [-e <editor> | --editor <editor>]

Options:
  -e, --editor <editor>  Edit the note with <editor>, overriding the editor
                         specified in the \`\$EDITOR\` environment variable.

Description:
  Open the specified note in \`\$EDITOR\`, currently set to '${EDITOR}', or
  <editor> if specified. Any data piped to \`${_ME} edit\` will be appended to
  the file.

  Non-text files will be opened in your system's preferred app or program for
  that file type.

Examples:
  ${_ME} edit 3
  ${_ME} edit example.md
  ${_ME} edit 'A Document Title'
  echo "Content to append." | ${_ME} edit 1

Shortcut Alias: \`e\`
HEREDOC
_edit() {
  local _basename=
  local _local_editor=
  local _password=

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      -e|--editor)
        _local_editor="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --password)
        _password="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${__arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "_edit() \${_selection}: %s\\n" "${_selection}"
  if [[ -z "${_selection:-}" ]]
  then
    _exit_1 _help "edit"
  fi

  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_edit() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    _exit_1 printf "Note not found: %s\\n" "$(_highlight "${_selection}")"
  fi

  _set_selection_notebook "${_selection}"

  if [[ -n "${_basename}" ]] || [[ -e "${_NOTEBOOK_PATH}/${_basename}" ]]
  then # _basename is assigned and a note exists with that name.
    local _before
    _before="$(_get_hash "${_NOTEBOOK_PATH}/${_basename}")"
    local _decrypted_path=
    local _encrypted_path=
    local _target_file="${_NOTEBOOK_PATH}/${_basename}"

    if _file_is_encrypted "${_target_file}"
    then
      _encrypted_path="${_target_file}"

      if [[ -z "${_password}" ]]
      then
        # Request password without displaying it
        printf "Password: "
        read -r -s _password </dev/tty
        printf "\\n" # print newline to stop `read`.
      fi

      _decrypted_path="$(_decrypt_file "${_target_file}" "${_password}")"

      _target_file="${_decrypted_path}"

      _before="$(_get_hash "${_decrypted_path}")"
    fi

    if _interactive_input
    then # terminal input.
      if [[ -z "${_content:-}" ]]
      then
        if [[ -n "${_local_editor}" ]]
        then
          EDITOR="${_local_editor}" _edit_file "${_target_file}"
        else
          _edit_file "${_target_file}"
        fi
      fi
    else # piped input.
      cat >> "${_target_file}"
    fi

    _after="$(_get_hash "${_NOTEBOOK_PATH}/${_basename}")"
    _debug printf "_edit() \${_before}: %s\\n" "${_before}"
    _debug printf "_edit() \${_after}: %s\\n" "${_after}"

    if [[ -n "${_encrypted_path:-}" ]] && [[ -e "${_decrypted_path:-}" ]]
    then
      _after="$(_get_hash "${_decrypted_path}")"

      if [[ "${_before}" != "${_after}" ]]
      then
        local _temp_encrypted_path=
        _temp_encrypted_path="$(_tempfile_path "${_basename}").tmp"

        mv "${_encrypted_path}" "${_temp_encrypted_path}"
        _encrypt_file "${_decrypted_path}" "${_encrypted_path}" "${_password}"

        if [[ -e "${_encrypted_path}" ]]
        then
          rm "${_temp_encrypted_path}"
        else
          mv "${_temp_encrypted_path}" "${_encrypted_path}"
        fi
      fi

      rm "${_decrypted_path}"
    fi

    _git_checkpoint "[nb] Edit: ${_basename}"

    if [[ "${_before}" != "${_after}" ]]
    then
      local _id
      _id="$(_index get_id "${_basename}")"

      local _scoped_basename="${_basename}"

      if ((_SCOPED))
      then
        local _notebook_identifier
        _notebook_identifier="$(_get_notebook_identifier "${_SCOPE}")"
        _id="${_notebook_identifier}:${_id}"
        _scoped_basename="${_notebook_identifier}:${_basename}"
      fi

      local _title
      _title="$(_get_title "${_NOTEBOOK_PATH}/${_basename}")"
      if [[ -n "${_title}" ]]
      then
        printf "Updated %s %s '%s'\\n"          \
          "$(_id_brackets_color "${_id}")"      \
          "$(_highlight "${_scoped_basename}")" \
          "${_title}"
      else
        printf "Updated %s %s\\n"               \
          "$(_id_brackets_color "${_id}")"      \
          "$(_highlight "${_scoped_basename}")"
      fi
    fi
  else
    _exit_1 printf "Selection not found.\\n"
  fi
}
_alias_subcommand "edit" "e"

# env ##################################################################### env

desc "env" <<HEREDOC
Usage:
  ${_ME} env

Description:
  Print program environment and configuration information.
HEREDOC
_env() {
  local _subcommand="${1:-}"
  if [[ -n "${_subcommand}" ]] && [[ "${_subcommand}" == "install" ]]
  then
    # packages: curl pandoc pygments w3m ripgrep tig
    if [[ -x "$(command -v apk)" ]]
    then
      apk add --no-cache curl pandoc ripgrep tig w3m
    fi
    if [[ -x "$(command -v apt-get)" ]]
    then
      apt-get install curl python-pygments tig w3m

      https://github.com/jgm/pandoc/releases/download/2.9.2.1/pandoc-2.9.2.1-1-amd64.deb
      sudo dpkg -i pandoc-2.9.2.1-1-amd64.deb

      curl -LO https://github.com/BurntSushi/ripgrep/releases/download/11.0.2/ripgrep_11.0.2_amd64.deb
      sudo dpkg -i ripgrep_11.0.2_amd64.deb
    fi
    if [[ -x "$(command -v dnf)" ]]
    then
      : # TODO: dnf install
    fi
    if [[ -x "$(command -v zypper)" ]]
    then
      : # TODO: zypper install curl jq
    fi
  else
    printf "_ME=%s\\n" "${_ME:-}"
    printf "_MY_PATH=%s\\n" "${_MY_PATH:-}"
    printf "_NOTEBOOK_PATH=%s\\n" "${_NOTEBOOK_PATH:-}"
    printf "EDITOR=%s\\n" "${EDITOR:-}"
    printf "PAGER=%s\\n" "${PAGER:-}"
    printf "NB_AUTO_SYNC=%s\\n" "${NB_AUTO_SYNC:-}"
    printf "NB_DIR=%s\\n" "${NB_DIR:-}"
    printf "NB_DEFAULT_EXTENSION=%s\\n" "${NB_DEFAULT_EXTENSION:-}"
    printf "NB_ENCRYPTION_TOOL=%s\\n" "${NB_ENCRYPTION_TOOL:-}"
    printf "NB_COLOR_PRIMARY=%s\\n" "${NB_COLOR_PRIMARY:-}"
    printf "NB_COLOR_SECONDARY=%s\\n" "${NB_COLOR_SECONDARY:-}"
    printf "NB_COLOR_THEME=%s\\n" "${NB_COLOR_THEME:-}"
    printf "NB_FOOTER=%s\\n" "${NB_FOOTER:-}"
    printf "NBRC_PATH=%s\\n" "${NBRC_PATH:-}"
    printf "ack:      %s\\n" "$(command -v ack)"
    printf "ag:       %s\\n" "$(command -v ag)"
    printf "code:     %s\\n" "$(command -v code)"
    printf "curl:     %s\\n" "$(command -v curl)"
    printf "emacs:    %s\\n" "$(command -v emacs)"
    printf "git:      %s\\n" "$(command -v git)"
    printf "gvim:     %s\\n" "$(command -v gvim)"
    printf "gpg:      %s\\n" "$(command -v gpg)"
    printf "less:     %s\\n" "$(command -v less)"
    printf "lynx:     %s\\n" "$(command -v lynx)"
    printf "macdown:  %s\\n" "$(command -v macdown)"
    printf "mate:     %s\\n" "$(command -v mate)"
    printf "mvim:     %s\\n" "$(command -v mvim)"
    printf "nano:     %s\\n" "$(command -v nano)"
    printf "nvim:     %s\\n" "$(command -v nvim)"
    printf "openssl:  %s\\n" "$(command -v openssl)"
    printf "pandoc:   %s\\n" "$(command -v pandoc)"
    printf "pygments: %s\\n" "$(command -v pygmentize)"
    printf "rg:       %s\\n" "$(command -v rg)"
    printf "subl:     %s\\n" "$(command -v subl)"
    printf "tig:      %s\\n" "$(command -v tig)"
    printf "w3m:      %s\\n" "$(command -v w3m)"
    printf "vim:      %s\\n" "$(command -v vim)"
    printf "bash --version: %s\\n" "$(bash --version | head -1)"
    printf "uname -a: %s\\n" "$(uname -a)"
  fi
}

# export ############################################################### export

desc "export" <<HEREDOC
Usage:
  ${_ME} export (<id> | <filename> | <path> | <title>) <path> [-f | --force]
            [<pandoc options>...]
  ${_ME} export notebook <name> [<path>]
  ${_ME} export pandoc (<id> | <filename> | <path> | <title>)
            [<pandoc options>...]

Options:
  -f, --force   Skip the confirmation prompt when overwriting an existing file.

Subcommands:
  (default)     Export a file to <path>. If <path> has a different extension
                than the source note, convert the note using \`pandoc\`.
  notebook      Export the notebook <name> to the current directory or <path>.
                Alias for \`${_ME} notebooks export\`.
  pandoc        Export the file to standard output or a file using \`pandoc\`.
                \`export pandoc\` prints to standard output by default.

Description:
  Export a file or notebook.

  If Pandoc [1] is available, convert the note from its current format
  to the format of the output file as indicated by the file extension
  in <path>. Any additional arguments are passed directly to Pandoc.
  See the Pandoc help information for available options.

    1. http://pandoc.org/

Examples:
  # Export an Emacs Org mode note
  ${_ME} export example.org /path/to/example.org

  # Export a Markdown note to HTML and print to standard output
  ${_ME} export pandoc example.md --from=markdown_strict --to=html

  # Export a Markdown note to a .docx Microsoft Office Word document
  ${_ME} export example.md /path/to/example.docx
HEREDOC
_export() {
  local _args=()
  local _force=0
  local _notebook_export=0
  local _pandoc_only=0
  local _selection=
  local _target_path=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      notebook|notebooks)
        _notebook_export=1
        ;;
      pandoc)
        _pandoc_only=1
        ;;
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${__arg}"
        elif ! ((_pandoc_only)) && [[ -z "${_target_path:-}" ]]
        then
          _target_path="${__arg}"
        else
          _args+=("${__arg}")
        fi
        ;;
    esac
  done

  if [[ -z "${_selection:-}" ]]
  then
    _exit_1 _help "export"
  fi
  _debug printf "_export() \${_selection}: %s\\n" "${_selection}"

  if ((_notebook_export))
  then
    _notebooks export "${_selection:-}" "${_target_path:-}"
    return 0
  fi

  local _basename
  _basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"

  if [[ -z "${_basename:-}" ]] || [[ ! -e "${_NOTEBOOK_PATH}/${_basename:-}" ]]
  then
    _exit_1 printf "Note not found: %s\\n" "$(_highlight "${_selection}")"
  fi
  _debug printf "_export() \${_basename}: %s\\n" "${_basename}"

  if ((_pandoc_only))
  then
    if _command_exists 'pandoc'
    then
      if [[ -n "${_args[*]:-}" ]]
      then
        pandoc "${_NOTEBOOK_PATH}/${_basename}" "${_args[@]:-}"
      else
        pandoc "${_NOTEBOOK_PATH}/${_basename}"
      fi
    else
      _exit_1 printf "Pandoc required. http://pandoc.org/\\n"
    fi
  else
    if [[ -z "${_target_path:-}" ]]
    then
      _exit_1 _help "export"
    fi
    _debug printf "_export() \${target_path}: %s\\n" "${_target_path}"

    if [[ -e "${_target_path:-}" ]]
    then
      if ! ((_force))
      then
        printf "File exists at %s\\n" "$(_highlight "${_target_path}")"
        while true
        do
          read -r -p "Overwrite existing file? [y/N] " __yn
          case ${__yn} in
            [Yy]*)
              break
              ;;
            *)
              printf "Exiting...\\n"
              exit 0
              ;;
          esac
        done
      fi
    fi

    _source_file_type="${_basename##*.}"
    _target_file_type="${_target_path##*.}"

    if _command_exists 'pandoc' &&
       [[ "${_source_file_type}" != "${_target_file_type}" ]]
    then
      _debug printf "_export() \${_args}: %s\\n" "${_args[*]:-}"
      if [[ -n "${_args[*]:-}" ]]
      then
        pandoc                              \
          -o "${_target_path}"              \
          --standalone                      \
          "${_NOTEBOOK_PATH}/${_basename}"  \
          "${_args[@]:-}"
      else
        pandoc                  \
          -o "${_target_path}"  \
          --standalone          \
          "${_NOTEBOOK_PATH}/${_basename}"
      fi
    else
      cp "${_NOTEBOOK_PATH}/${_basename}" "${_target_path}"
    fi &&
      printf "Exported %s to %s\\n"         \
          "$(_highlight "${_selection}")"   \
          "$(_highlight "${_target_path}")"
  fi
}

# git ##################################################################### git

desc "git" <<HEREDOC
Usage:
  ${_ME} git <git options>...

Description:
  Alias for \`git\` within the current notebook.
HEREDOC
_git() {
  cd "${_NOTEBOOK_PATH}" || _exit_1 printf "_git() \`cd\` failed.\\n"
  git "${@}"
}

# history ############################################################# history

desc "history" <<HEREDOC
Usage:
  ${_ME} history [<id> | <filename> | <path> | <title>]

Description:
  Display notebook history using \`tig\` [1] (if available) or \`git log\`.
  When a note is specified, the history for that note is displayed.

    1. https://github.com/jonas/tig

Examples:
  ${_ME} history
  ${_ME} history example.md
HEREDOC
_history() {
  cd "${_NOTEBOOK_PATH}" || _exit_1 printf "_history() \`cd\` failed.\\n"

  local _log_command="git log"
  if _command_exists "tig"
  then # tig <https://github.com/jonas/tig> is present.
    _log_command="tig --all"
  fi

  local _selection="${1:-}"
  _debug printf "_history() \${_selection}: '%s'\\n" "${_selection}"

  local _basename=
  _basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"
  _debug printf "_history() \${_basename}: '%s'\\n" "${_basename}"
  _debug printf "_history() \${_NOTEBOOK_PATH}: '%s'\\n" "${_NOTEBOOK_PATH}"

  cd "${_NOTEBOOK_PATH}" || return 1

  if [[ -n "${_basename}" ]] && [[ -e "${_NOTEBOOK_PATH}/${_basename}" ]]
  then # `$_basename` is assigned and a note exists with that name.
    eval "${_log_command} -- \"${_basename}\""
  else
    eval "${_log_command}"
  fi
}

# import ############################################################### import

desc "import" <<HEREDOC
Usage:
  ${_ME} import (<path> | <url>)
  ${_ME} import copy <path>
  ${_ME} import download <url> [--convert]
  ${_ME} import move <path>
  ${_ME} import notebook <path> [<name>]

Options:
  --convert  Convert HTML content to Markdown.

Subcommands:
  (default) Copy or download the file in <path> or <url>.
  copy      Copy the file at <path> into the current notebook.
  download  Download the file at <url> into the current notebook.
  move      Copy the file at <path> into the current notebook.
  notebook  Import the local notebook at <path> to make it global.

Description:
  Copy, move, or download files into the current notebook or import
  a local notebook to make it global.

Examples:
  ${_ME} import ~/Pictures/example.png
  ${_ME} import ~/Documents/example.docx
  ${_ME} import https://example.com/example.pdf
HEREDOC
_import() {
  # _import_validate_path()
  #
  # Usage:
  #   _import_validate_path <path>
  _import_validate_path() {
    if [[ -z "${1:-}" ]]
    then
      _exit_1 _help "import"
    elif [[ ! -e "${1:-}" ]]
    then
      _exit_1 printf "File not found: %s\\n" "${1:-}"
    fi
  }

  # _import_get_valid_basename()
  #
  # Usage:
  #   _import_get_valid_basename <basename>
  _import_get_valid_basename() {
    local _target_basename="${1:-}"
    if [[ -e "${_NOTEBOOK_PATH}/${_target_basename}" ]]
    then
      _target_basename="$(_get_unique_basename "${_target_basename}")"
    fi
    printf "%s\\n" "${_target_basename}"
  }

  local _basename=
  local _convert=0
  local _notebook_name=
  local _path=
  local _subcommand=
  local _url=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      copy|download|move)
        _subcommand="${__arg}"
        ;;
      notebook|notebooks)
        _subcommand="notebook"
        ;;
      --convert)
        _convert=1
        ;;
      *)
        if [[ -n "${_subcommand:-}" ]]
        then
          if [[ "${_subcommand}" == "download" ]]
          then
            _url="${__arg:-}"
          elif [[ "${_subcommand}" == "notebook"  ]] &&
               [[ -n "${_path:-}"                 ]]
          then
            _notebook_name="${__arg:-}"
          else
            _path="${__arg:-}"
          fi
        else
          if [[ "${__arg:-}" =~ ^http|^file\: ]]
          then
            _subcommand="download"
            _url="${__arg:-}"
          else
            _subcommand="copy"
            _path="${__arg:-}"
          fi
        fi
        ;;
    esac
  done

  case "${_subcommand}" in
    copy)
      _import_validate_path "${_path:-}"

      _basename="$(basename -- "${_path}")"
      _basename="$(_import_get_valid_basename "${_basename}")"

      if [[ -d "${_path}" ]]
      then
        cp -R "${_path}" "${_NOTEBOOK_PATH}/${_basename}"
      else
        cp "${_path}" "${_NOTEBOOK_PATH}/${_basename}"
      fi &&
        _index add "${_basename}" &&
        _git_checkpoint "[nb] Import: ${_basename}"
      printf "Imported '%s' to '%s'\\n" \
        "$(_highlight "${_path}")"      \
        "$(_highlight "${_basename}")"
      ;;
    download)
      _basename="$(basename -- "${_url}" | tr -d '[:space:]')"
      if [[ "${_url}" =~ \/$ ]]
      then
        _basename="${_basename}.html"
      fi
      _basename="$(_import_get_valid_basename "${_basename}")"

      if ((_convert))
      then
        if ! _download_from "${_url}" \
            | pandoc                  \
              --from html             \
              --to markdown           \
              -o "${_NOTEBOOK_PATH}/${_basename}"
        then
          _exit_1 printf "Unable to download: %s\\n" "${_url}"
        fi
      else
        if ! _download_from "${_url}" "${_NOTEBOOK_PATH}/${_basename}"
        then
          _exit_1 printf "Unable to download: %s\\n" "${_url}"
        fi
      fi &&
        _index add "${_basename}" &&
        _git_checkpoint "\
[nb] Import: ${_basename}

Source:
${_url}
"
      printf "Imported %s to %s\\n"     \
        "$(_highlight "${_url}")"       \
        "$(_highlight "${_basename}")"
      ;;
    move)
      _import_validate_path "${_path:-}"
      _basename="$(basename -- "${_path}")"
      _basename="$(_import_get_valid_basename "${_basename}")"

      mv "${_path}" "${_NOTEBOOK_PATH}/${_basename}"    &&
        _index add "${_basename}"                       &&
        _git_checkpoint "[nb] Import: ${_basename}"
      printf "Imported %s to %s\\n"     \
        "$(_highlight "${_path}")"      \
        "$(_highlight "${_basename}")"
      ;;
    notebook)
      _notebooks import "${_path:-}" "${_notebook_name:-}"
      return 0
      ;;
    *)
      _exit_1 _help "import"
      ;;
  esac
}

# index ################################################################# index

desc "index" <<HEREDOC
Usage:
  ${_ME} index add <filename>
  ${_ME} index delete <filename>
  ${_ME} index get_basename <id>
  ${_ME} index get_id <filename>
  ${_ME} index get_max_id
  ${_ME} index rebuild
  ${_ME} index reconcile
  ${_ME} index show
  ${_ME} index update <existing-filename> <new-filename>
  ${_ME} index verfiy

Subcommands:
  add           Add <filename> to the index.
  delete        Delete <filename> from the index.
  get_basename  Print the filename / basename at the specified <id>.
  get_id        Get the id for <filename>.
  get_max_id    Get the maximum id for the notebook.
  rebuild       Rebuild the index. Some ids might change.
  reconcile     Remove duplicates and update index for added and deleted files.
  show          Print the index.
  update        Overwrite the <existing-filename> entry with <new-filename>.
  verify        Verify that the index matches the notebook contents.

Description:
  Manage the index for the current notebook. This subcommand is used
  internally by \`${_ME}\` and using it manually will probably corrupt
  the index. If something goes wrong with the index, fix it with
  \`${_ME} index reconcile\`.

  The index is a text file named '.index' in the notebook directory. .index
  contains a list of filenames and the line number of each filename
  represents the id. .index is included in the git repository so ids are
  preserved across systems.
HEREDOC
_index() {
  local _subcommand="${1:-}"
  local _index_path="${_NOTEBOOK_PATH}/.index"

  if [[ ! -e "${_index_path}"           ]] &&
     [[ ! "${_subcommand}" == "rebuild" ]]
  then
    _index rebuild
  fi

  case "${_subcommand}" in
    add)
      local _basename="${2:-}"
      if [[ -z "${_basename}" ]]
      then
        _exit_1 _help index
      fi

      if [[ ! -e "${_NOTEBOOK_PATH}/${_basename}" ]]
      then
        _exit_1 printf "File not found: %s\\n" "${_basename}"
      fi

      if ! grep -q "^${_basename}$" "${_index_path}"
      then
        _debug printf "_index() add \$_basename: %s\\n" "${_basename}"
        printf "%s\\n" "${_basename}" >> "${_index_path}"
      fi
      ;;
    delete)
      local _basename="${2:-}"
      _debug printf "_index() delete \${_basename}: '%s'\\n" "${_basename}"

      if [[ -z "${_basename}" ]]
      then
        _exit_1 _help index
      fi

      if grep -q "^${_basename}$" "${_index_path}"
      then
        "${_SED_I_COMMAND[@]}" -e "s/^${_basename}$//g" "${_index_path}"
      else
        return 1
      fi
      ;;
    get_basename)
      # Usage: _index_get_basename <id> <index path>
      _index_get_basename() {
        if [[ -z "${1:-}" ]] || [[ "${1:-}" == "0" ]]
        then
          return 1
        fi

        sed "${1:-}q;d" "${2:-}"
      }

      local _id_number="${2:-}"
      if [[ -z "${_id_number}" ]]
      then
        _exit_1 _help index
      fi

      local _basename
      _basename="$(_index_get_basename "${_id_number}" "${_index_path}")"

      if [[ -z "${_basename}" ]]
      then
        _index reconcile &&
          _basename="$(_index_get_basename "${_id_number}" "${_index_path}")"
      fi

      if [[ -z "${_basename}" ]]
      then
        return 1
      else
        printf "%s\\n" "${_basename}"
      fi
      ;;
    get_id)
      # Usage: _index_get_id <basename> <index path>
      _index_get_id() {
        grep -n "^${1:-}$" "${2:-}" | cut -f1 -d:
      }

      local _basename="${2:-}"
      if [[ -z "${_basename}" ]]
      then
        _help index
        return 1
      fi

      local _id
      _id="$(_index_get_id "${_basename}" "${_index_path}")"

      if [[ -z "${_id}" ]]
      then
        _index reconcile &&
          _id="$(_index_get_id "${_basename}" "${_index_path}")"
      fi

      if [[ -z "${_id}" ]]
      then
        return 1
      else
        printf "%s\\n" "${_id}"
      fi
      ;;
    get_max_id)
      wc -l < "${_index_path}" | tr -d '[:space:]'
      printf "\\n"
      ;;
    rebuild)
      _debug printf "_index() rebuild\\n"
      _debug printf \
        "_index() rebuild: \`ls \${_NOTEBOOK_PATH}\`: '%s'\\n" \
        "$(ls "${_NOTEBOOK_PATH}")"
      ls "${_NOTEBOOK_PATH}" > "${_index_path}" &&
        _git_checkpoint "[nb] Rebuild Index"
      ;;
    reconcile)
      _index_reconcile_remove_duplicates() {
        local _reconcle_index_path="${1:-}"
        [[ -z "${_reconcle_index_path:-}" ]] && return 1

        local _temp_file
        _temp_file="$(mktemp)"

        exec 3> "${_temp_file}"
        exec 4< "${_temp_file}"

        rm "${_temp_file}"

        # Remove duplicates and preserve newlines.
        awk '!NF || !seen[$0]++' "${_reconcle_index_path}" >&3
        cat <&4 > "${_reconcle_index_path}"

        exec 3>&-
        exec 4<&-
      }

      local -a _index_list=()
      _index_list=($(<"${_index_path}"))

      local -a _file_list=()
      _file_list=($(ls "${_NOTEBOOK_PATH}"))

      _index_reconcile_remove_duplicates "${_index_path}"

      _debug printf \
        "_index() reconcile: \`\${_index_list[*]}\`: '%s'\\n" \
        "${_index_list[*]:-}"
      _debug printf \
        "_index() reconcile: \`\${_file_list[*]}\`: '%s'\\n" \
        "${_file_list[*]:-}"

      local -a _index_file_list_diff=()
      _index_file_list_diff=($(
        printf "%s\\n"          \
          "${_index_list[@]:-}" \
          "${_file_list[@]:-}"  \
          | sort                \
          | uniq -u
      ))

      local -a _diff_in_index=()
      _diff_in_index=($(
        printf "%s\\n"                    \
          "${_index_list[@]:-}"           \
          "${_index_file_list_diff[@]:-}" \
          | sort                          \
          | uniq -d                       \
          | uniq
      ))

      for __item in "${_diff_in_index[@]:-}"
      do
        if [[ -n "${__item}" ]]
        then
          _contains "${__item}" "${_file_list[@]:-}" ||
            _index delete "${__item}"
        fi
      done

      local -a _diff_in_file_list=()
      _diff_in_file_list=($(
        printf "%s\\n"                    \
          "${_file_list[@]:-}"            \
          "${_index_file_list_diff[@]:-}" \
          | sort                          \
          | uniq -d                       \
          | uniq
      ))

      for __item in "${_diff_in_file_list[@]:-}"
      do
        if [[ -n "${__item}" ]]
        then
          _contains "${__item}" "${_index_list[@]:-}" ||
            _index add "${__item}"
        fi
      done
      ;;
    show)
      cat "${_index_path}"
      ;;
    update)
      local _old_basename="${2:-}"
      local _new_basename="${3:-}"
      if [[ -z "${_old_basename}" ]] || [[ -z "${_new_basename}" ]]
      then
        _exit_1 _help index
      fi

      if grep -q "^${_old_basename}$" "${_index_path}"
      then
        "${_SED_I_COMMAND[@]}" \
          -e "s/^${_old_basename}$/${_new_basename}/g" "${_index_path}"
      else
        return 1
      fi
      ;;
    verify)
      local _valid=1
      local -a _index_list=()
      _index_list=($(<"${_index_path}"))
      local -a _file_list=()
      _file_list=($(ls "${_NOTEBOOK_PATH}"))

      _debug printf \
        "_index() verify: \`\${_index_list[*]}\`: '%s'\\n" \
        "${_index_list[*]:-}"
      _debug printf \
        "_index() verify: \`\${_file_list[*]}\`: '%s'\\n" \
        "${_file_list[*]:-}"

      local -a _index_file_list_diff=()
      _index_file_list_diff=($(
        printf "%s\\n"          \
          "${_index_list[@]:-}" \
          "${_file_list[@]:-}"  \
          | sort                \
          | uniq -u
      ))

      if [[ -n "${_index_file_list_diff[*]:-}" ]]
      then
        _valid=0
      fi

      for __item in $(printf "%s\\n" "${_index_list[@]:-}" | uniq -c)
      do
        local _count
        _count="$(printf "%s\\n" "${__item}" | awk '{print $1}')"
        if [[ "${_count}" -gt 1 ]]
        then
          _valid=0
          break
        fi
      done

      if ! ((_valid))
      then
        _exit_1 \
          printf "Index corrupted. To fix, run:\\n  %s index reconcile\\n" \
          "${_ME}"
      fi
      ;;
    *)
      :
      ;;
  esac
}

# init ################################################################### init

desc "init" <<HEREDOC
Usage:
  ${_ME} init [<remote-url>]

Description:
  Initialize the local data directory and generate a \`${_ME}\`
  configuration file if it doesn't exist at ${NBRC_PATH}

Examples:
  ${_ME} init
  ${_ME} init https://github.com/example/example.git
HEREDOC
_init() {
  # Usage: _init_create_home_notebook [<url>]
  _init_create_home_notebook() {
    local _repo_url="${1:-}"
    if [[ -n "${_repo_url}" ]]
    then
      git clone "${_repo_url}" "${NB_DIR}/home"
    else
      mkdir -p "${NB_DIR}/home"            &&
        cd "${NB_DIR}/home"                &&
        git init 1>/dev/null               &&
        touch "${NB_DIR}/home/.index"      &&
        _git_checkpoint "[nb] Initialize"
    fi
    printf "home\\n" > "${NB_DIR}/.current"

    printf "Created %s notebook.\\n" "$(_highlight "home")"
  }

  # Usage: _init_create_nb_dir
  _init_create_nb_dir() {
    if [[ -d "${NB_DIR}" ]]
    then
      printf "%s data directory already exists: %s\\n" \
        "$(_highlight "${_ME}")" \
        "${NB_DIR}"
    elif [[ -e "${NB_DIR}" ]]
    then
      _exit_1 cat <<HEREDOC
Unable to set up the $(_highlight "${_ME}") data directory. File exists at:
${NB_DIR}
HEREDOC
    else
      mkdir -p "${NB_DIR}"
      printf "Created %s\\n" "${NB_DIR}"
    fi
  }

  # Usage: _init_create_rc_file
  _init_create_rc_file() {
    if [[ -e "${NBRC_PATH}" ]]
    then
      printf "Configuration file already exists: %s\\n" \
        "${NBRC_PATH}"
    else
      cat <<HEREDOC > "${NBRC_PATH}"
#!/usr/bin/env bash
###############################################################################
# .nbrc
#
# Configuration file for \`${_ME}\`, a command line note-taking and document
# management tool with encryption, search, Git-backed syncing, and more in a
# single portable script.
#
# Edit this file manually or manage settings using the \`${_ME} settings\`
# subcommand. Configuration options are set as environment variables, eg:
#   export NB_ENCRYPTION_TOOL=gpg
#
# https://github.com/${_REPO}
###############################################################################
HEREDOC
      printf "Created %s\\n" "${NBRC_PATH}"
    fi
  }

  # Usage: _init_print_header
  _init_print_header() {
    _print_welcome &&
      printf "Initializing...\\n"
  }

  if [[ -e "${NB_DIR}" ]] && [[ ! -d "${NB_DIR}" ]]
  then
    _exit_1 printf "NB_DIR exists and is not a directory: %s\\n" \
      "${NB_DIR}"
  fi

  if [[ -d "${_GLOBAL_NOTEBOOK_PATH}" ]]
  then
    _exit_1 cat <<HEREDOC
$(_highlight "${_ME}") already initialized. To initialize a local notebook, use:
  $(_highlight "${_ME} notebooks init")
More information:
  $(_highlight "${_ME} help notebooks")
HEREDOC
  fi

  _init_print_header        &&
    _init_create_nb_dir     &&
    _init_create_rc_file    &&
    _init_create_home_notebook "${1:-}"
}

# list ################################################################### list

desc "list" <<HEREDOC
Usage:
  ${_ME} list [-e [<length>] | --excerpt [<length>]] [--filenames] [--no-id]
          [-n <limit> | --<limit>] [-s | --sort] [-r | --reverse]
          [-t <type> | --type <type> | --<type>]
          [<id> | <filename> | <path> | <title> | <query>]

Options:
  -e, --excerpt [<length>]      Print an excerpt <length> lines long under
                                each note's filename [default: 3].
  --filenames                   Print the filename for each note.
  --no-id                       Don't include the id in list items.
  -n <limit>                    The maximum number of notes to list.
  --<limit>                     Shortcut for \`-n <limit>\`.
  -s, --sort                    Order notes by id.
  -r, --reverse                 Order notes by id descending.
  -t, --type <type>, --<type>   List items of <type>. <type> can be a file
                                extension or one of the following types:
                                note, bookmark, document, archive, image,
                                video, audio, folder

Description:
  List notes in the current notebook.

  When <id>, <filename>, <path>, or <title> are present, the listing for the
  matching note will be displayed. When no match is found, titles and
  filenames will be searched for any that match <query> as a case-insensitive
  regular expression.

Indicators:
  ðŸ”–  Bookmark
  ðŸ”’  Encrypted
  ðŸŒ„  Image
  ðŸ“„  PDF, Word, or Open Office document
  ðŸ“¹  Video
  ðŸ”‰  Audio
  ðŸ“‚  Folder

Examples:
  ${_ME} list
  ${_ME} list example.md -e 10
  ${_ME} list --excerpt --no-id
  ${_ME} list --filenames --reverse
  ${_ME} list '^Example.*'
  ${_ME} list --10
  ${_ME} list --type document
HEREDOC
_list() {
  _debug printf "_list() \${1:-}: '%s'\\n" "${1:-}"
  _debug printf "_list() \${2:-}: '%s'\\n" "${2:-}"
  _debug printf "_list() \${3:-}: '%s'\\n" "${3:-}"

  local _columns
  _columns="$(tput cols)"
  local _excerpt_length=3
  local _limit=
  local _list_filenames=0
  local _no_color=0
  local _no_id=0
  local _print_excerpt=0
  local _print_indicators=1
  local _reverse=0
  local _selection
  local _sort=0
  local _type=

  _debug printf "_list() \${@:-}: '%s'\\n" "${@:-}"

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      -e|--excerpt)
        _print_excerpt=1
        if __option_value_is_present "${__val:-}"
        then
          _excerpt_length="${__val:-}"
          shift
        fi
        ;;
      --filenames|--filename)
        _list_filenames=1
        ;;
      --no-id|--noid|--no-ids|--no-index|--noindex)
        _no_id=1
        ;;
      --no-color|--nocolor)
        _no_color=1
        ;;
      --no-indicators|--noindicators|--no-indicator|--noindicator)
        _print_indicators=0
        ;;
      -n|--limit)
        if __option_value_is_present "${__val:-}"
        then
          _limit="${__val:-}"
          shift
        fi
        ;;
      -s|--sort)
        _sort=1
        ;;
      -r|--reverse)
        _reverse=1
        ;;
      --titles)
        : # Do nothing. This is now the default behavior. TODO: Remove.
        ;;
      -t|--type)
        _type="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      *)
        _debug printf "_list() *: '%s'\\n" "${__arg:-}"
        if [[ "${__arg:-}" =~ ^--[0-9]+$ ]]
        then
          _limit="${__arg:-}"
        elif [[ "${__arg:-}" =~ ^-- ]]
        then
          _type="${__arg:2}"
        else
          _selection="${__arg:-}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "_list() \${_limit}: '%s'\\n" "${_limit:-}"
  _debug printf "_list() \${_print_excerpt}: '%s'\\n" "${_print_excerpt:-}"
  _debug printf "_list() \${_excerpt_length}: '%s'\\n" "${_excerpt_length:-}"
  _debug printf "_list() \${_selection}: '%s'\\n" "${_selection:-}"
  _debug printf "_list() \${_sort}: '%s'\\n" "${_sort:-}"
  _debug printf "_list() \${_type}: '%s'\\n" "${_type:-}"

  local _selection_basename=
  if [[ -n "${_selection:-}" ]]
  then
    _selection_basename="$(_get_selection_basename "${_selection}")"
    _set_selection_notebook "${_selection}"
  fi

  local _notebook_identifier=
  _notebook_identifier="$(_get_notebook_identifier "${_NOTEBOOK_PATH}")"

  _debug printf \
    "list() \${_selection_basename}: '%s'\\n" \
    "${_selection_basename}"

  local _list_file_options=()
  local _filenames=()

  [[ -n "${_type:-}" ]] && _list_file_options+=("--type" "${_type}")
  ((_reverse))          && _list_file_options+=("--reverse")
  ((_sort))             && _list_file_options+=("--sort")

  if [[ -n "${_list_file_options[*]:-}" ]]
  then
    _filenames=($(_list_nb_files "${_list_file_options[@]}")) || :
  else
    _filenames=($(_list_nb_files)) || :
  fi

  local _filenames_count="${#_filenames[@]}"

  _debug printf \
    "list() \${_filenames_count}: '%s'\\n" \
    "${_filenames_count[@]}"

  if [[ "${_filenames_count}" -eq 0           ]] &&
     [[ "${_type}" =~ ^bookmark$|^bookmarks$  ]]
  then
    cat <<HEREDOC
0 bookmarks.

Add a bookmark:
  $(_highlight "${_ME} bookmark <url>")
Help information:
  $(_highlight "${_ME} help bookmark")
HEREDOC
  elif [[ "${_filenames_count}" -eq 0 ]] &&
       [[ "${_type}" =~ ^archive$|^audio$|^document$|^image$|^video$ ]]
  then
    cat <<HEREDOC
0 ${_type} files.

Import a file:
  $(_highlight "${_ME} import (<path> | <url>)")
Help information:
  $(_highlight "${_ME} help import")
HEREDOC
  elif [[ "${_filenames_count}" -eq 0 ]]
  then # no files in `$_NOTEBOOK_PATH`
    cat <<HEREDOC
0 notes.

Add a note:
  $(_highlight "${_ME} add")
Add a bookmark:
  $(_highlight "${_ME} bookmark <url>")
Import a file:
  $(_highlight "${_ME} import (<path> | <url>)")
Help information:
  $(_highlight "${_ME} help")
HEREDOC
    return 0
  else
    local _counter=0
    local _max_id
    _max_id="$(_index get_max_id)"

    for __basename in "${_filenames[@]}"
    do
      _debug printf "list() \${__basename}: '%s'\\n" "${__basename}"

      local _maybe_title=

      if [[ -n "${_selection:-}" ]]
      then
        # If a valid <selection> has been specified, skip the rest of the loop
        # unless the <selection> basename matches the current one.
        if [[ -n "${_selection_basename}" ]]
        then
          if [[ "${__basename}" != "${_selection_basename}" ]]
          then
            continue
          fi
        else

          # Turn on a case-insensitive matching (-s set nocasematch)
          shopt -s nocasematch

          if [[ "${__basename:-}" =~ ${_selection} ]]
          then
            : # include the note in the list
          else
            _maybe_title="$(_get_title "${_NOTEBOOK_PATH}/${__basename}")"
            if [[ "${_maybe_title:-}" =~ ${_selection} ]]
            then
              : # include the note in the list
            else
              continue # don't include note in list
            fi
          fi

          # Turn off a case-insensitive matching (-u unset nocasematch)
          shopt -u nocasematch
        fi
      fi

      if [[ -n "${_limit:-}" ]] && [[ "${_counter}" -eq "${_limit}" ]]
      then # the limit has been reached.

        _debug printf "list() \${#_limit}: '%s'\\n" "${#_limit}"
        _debug printf "list() \${#_counter}: '%s'\\n" "${#_counter}"

        local _difference
        _difference=$((_filenames_count-_counter))
        printf "%s omitted. %s total.\\n" \
          "${_difference}" \
          "${_filenames_count}"
        break
      fi

      local _indicators=
      local _maybe_padded_indicators=

      if ((_print_indicators))
      then
        if _file_is_bookmark "${_NOTEBOOK_PATH}/${__basename}"
        then
          _indicators+="ðŸ”– "
        fi

        if _file_is_image "${_NOTEBOOK_PATH}/${__basename}"
        then
          _indicators+="ðŸŒ„ "
        fi

        if _file_is_document "${_NOTEBOOK_PATH}/${__basename}"
        then
          _indicators+="ðŸ“„ "
        fi

        if [[ -d "${_NOTEBOOK_PATH}/${__basename}" ]]
        then
          _indicators+="ðŸ“‚ "
        fi

        if _file_is_video "${_NOTEBOOK_PATH}/${__basename}"
        then
          _indicators+="ðŸ“¹ "
        fi

        if _file_is_audio "${_NOTEBOOK_PATH}/${__basename}"
        then
          _indicators+="ðŸ”‰ "
        fi

        if _file_is_encrypted "${_NOTEBOOK_PATH}/${__basename}"
        then
          _indicators+="ðŸ”’ "
        fi

        if [[ -n "${_indicators:-}" ]]
        then
          _maybe_padded_indicators="${_indicators}"
        fi
      fi

      local _title_or_basename="${__basename}"
      if ! ((_list_filenames))
      then
        if [[ -z "${_maybe_title}" ]]
        then
          _maybe_title="$(_get_title "${_NOTEBOOK_PATH}/${__basename}")"
        fi

        if [[ -n "${_maybe_title}" ]]
        then # note file has title.
          _title_or_basename="${_maybe_title}"
        fi
      fi

      local _list_item="${_maybe_padded_indicators}${_title_or_basename}"

      if ! ((_no_id))
      then
        # NOTE: Plain version serves as the reference version and can be used
        # for length calculations.
        local _item_identifier=
        local _max_identifier=
        _item_identifier="$(_index get_id "${__basename}")"
        if ((_SCOPED))
        then
          _item_identifier="${_notebook_identifier}:${_item_identifier}"
          _max_identifier="${_notebook_identifier}:${_max_id}"
        else
          _item_identifier="${_item_identifier}"
          _max_identifier="${_max_id}"
        fi

        local _id_item=
        _id_item="[${_item_identifier}]"

        local _id_item_color=
        _id_item_color="$(_id_brackets_color "${_item_identifier}")"

        # Use calculated number of spaces for nicer formatting.
        local _spaces=''
        local _spaces_length=1
        _spaces_length=$(( ${#_max_identifier} + 3 - ${#_id_item} ))
        printf -v _spaces '%*s' "${_spaces_length}"
      fi

      if ! ((_list_filenames)) &&
         ! ((_print_excerpt))  &&
         [[ "${_title_or_basename}" == "${__basename}" ]]
      then
        local _first_line=
        _first_line="$(_get_first_line "${_NOTEBOOK_PATH}/${__basename}")"

        if [[ -n "${_first_line:-}" ]]
        then
          _list_item="${_list_item} Â· \"${_first_line}\""
        fi
      fi

      local _print_item=
      local _print_item_color=

      if ((_no_id))
      then
        _print_item="${_list_item}"
        _print_item_color="${_list_item}"
      else
        local _list_item_id="${_id_item}${_spaces}${_list_item}"
        local _list_item_id_color="${_id_item_color}${_spaces}${_list_item}"

        _print_item="${_list_item_id}"
        _print_item_color="${_list_item_id_color}"
      fi

      if ! {
        ((_list_filenames)) ||
        ((_no_id))          ||
        ((_no_color))
      }
      then
        # Calculate apparent length of the list item string, with byte and
        # character calculations for handling unicode characters.
        local _item_line_length=
        _item_line_length="$(printf "%s" "${_print_item}" | wc -m)"

        local _item_line_length_bytes=
        _item_line_length_bytes="$(printf "%s" "${_print_item}" | wc -c)"

        local _item_line_length_diff=
        _item_line_length_diff=$(((_item_line_length_bytes-_item_line_length)/3))

        _item_line_length=$((_item_line_length+_item_line_length_diff))
      fi

      if ! {
        ((_print_excerpt))  ||
        ((_list_filenames)) ||
        ((_no_id))          ||
        ((_no_color))
      }
      then
        if [[ "${_item_line_length}" -gt "${_columns}" ]] &&
           {
             [[ -n "${_maybe_title:-}" ]] ||
             [[ -n "${_first_line:-}"  ]]
           }
        then
          # Turn off line-wrapping
          printf '\033[?7l'
        fi
      fi

      if ((_no_color))
      then
        printf "%s" "${_print_item}"
      else
        printf "%s" "${_print_item_color}"
      fi

      if ! {
        ((_print_excerpt))  ||
        ((_list_filenames)) ||
        ((_no_id))          ||
        ((_no_color))
      }
      then
        if [[ "${_item_line_length}" -gt "${_columns}" ]] &&
           {
             [[ -n "${_maybe_title:-}" ]] ||
             [[ -n "${_first_line:-}"  ]]
           }
        then
          # Turn on line-wrapping
          printf '\033[?7h'
        fi
      fi

      # End of line.
      printf "\\n"

      if ((_print_excerpt)) &&
         [[ "${_excerpt_length}" =~ ^[1-9] ]] &&
         _file_is_text "${_NOTEBOOK_PATH}/${__basename}"
      then # excerpt is specified with a non-zero digit, as required by `head`.
        if [[ -z "${_item_line_length:-}"               ]] ||
           [[ "${_item_line_length}" -gt "${_columns}"  ]]
        then
          _print_line "$(printf "%-${_columns}s" '.')" | tr -d '\n'
        else
          _print_line "$(printf "%-${_item_line_length}s" '.')"
        fi
        head -"${_excerpt_length}" "${_NOTEBOOK_PATH}/${__basename}"
        printf "\\n"
      fi

      _counter=$((_counter+1))
    done

    if ! ((_counter)) && [[ -n "${_selection:-}" ]]
    then
      _exit_1 printf "Note not found: %s\\n" "$(_highlight "${_selection}")"
    fi
  fi
}

# ls ####################################################################### ls

desc "ls" <<HEREDOC
Usage:
  ${_ME} ls [-e [<length>] | --excerpt [<length>]] [--filenames] [--no-id]
        [-n <limit> | --<limit>] [-s | --sort] [-r | --reverse]
        [-t <type> | --type <type> | --<type>]
        [<id> | <filename> | <path> | <title> | <query>]

Options:
  -e, --excerpt [<length>]      Print an excerpt <length> lines long under
                                each note's filename [default: 3].
  --filenames                   Print the filename for each note.
  --no-id                       Don't include the id in list items.
  -n <limit>                    The maximum number of notes to list.
  --<limit>                     Shortcut for \`-n <limit>\`.
  -s, --sort                    Order notes by id.
  -r, --reverse                 Order notes by id descending.
  -t, --type <type>, --<type>   List items of <type>. <type> can be a file
                                extension or one of the following types:
                                note, bookmark, document, archive, image,
                                video, audio, folder

Description:
  List notebooks and notes in the current notebook, displaying note titles
  when available. \`${_ME} ls\` is a combination of \`${_ME} notebooks\` and
  \`${_ME} list\` in one view.

  When <id>, <filename>, <path>, or <title> are present, the listing for the
  matching note will be displayed. When no match is found, titles and
  filenames will be searched for any that match <query> as a case-insensitive
  regular expression.

  On most systems, if the list of notes is longer than the terminal can
  display on one screen, the list will be opened in \`less\`. Use the
  following keys to navigate in \`less\` (see \`man less\` for more):

    Key               Function
    ---               --------
    mouse scroll      Scroll up / down
    arrow up / down   Scroll one line up / down
    f                 Move forward one page
    b                 Move back one page
    /<query>          Search for <query>
    n                 Jump to next <query> match
    q                 Quit

  Options are passed through to \`list\`. For more information, see
  \`${_ME} help list\`.

Indicators:
  ðŸ”–  Bookmark
  ðŸ”’  Encrypted
  ðŸŒ„  Image
  ðŸ“„  PDF, Word, or Open Office document
  ðŸ“¹  Video
  ðŸ”‰  Audio
  ðŸ“‚  Folder

Examples:
  ${_ME} ls
  ${_ME} ls example.md -e 10
  ${_ME} ls --excerpt --no-id
  ${_ME} ls --reverse
  ${_ME} ls '^Example.*'
  ${_ME} ls --10
  ${_ME} ls --type document
HEREDOC
_ls() {
  _debug printf "_ls() \${@:-}: '%s'\\n" "${@:-}"

  local _args=()
  local _auto_align=1 # auto-align by default.
  local _centered=0
  local _columns
  _columns="$(tput cols)"
  local _justified=0
  local _limit=30
  local _maybe_notebook_list=
  local _plain=0

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      --auto-align)
        _auto_align=1
        ;;
      --centered)
        _centered=1
        ;;
      --justified)
        _justified=1
        ;;
      --plain)
        _plain=1
        ;;
      -n|--limit)
        if __option_value_is_present "${__val:-}"
        then
          _limit="${__val:-}"
        fi

        shift
        ;;
      -l|-a)
        : # Ignore accidental ls -l and -a flags due to muscle memory.
        ;;
      *)
        if [[ "${__arg:-}" =~ ^--[0-9]+$ ]]
        then
          _limit="${__arg:-}"
        else
          _args+=("${__arg}")
        fi
        ;;
    esac

    shift
  done

  _debug printf "_ls() \${_args[*]}: '%s'\\n" "${_args[*]:-}"

  if [[ -z "${_args[*]:-}" ]]
  then
    # Build word-wrapping notebook line. `fold` doesn't account for
    # highlighting.
    #
    # Naive version:
    #
    # _notebooks --names \
    #   | tr '\n' ' ' \
    #   | fold -s "-w$(tput cols)" \
    #   && printf "\\n"

    # _print_paddding()
    #
    # Usage:
    #   _print_padding <line> <columns> <aligned>
    _print_padding() {
      local _padding_line="${1:-}"
      local _padding_line_length="${#_padding_line}"
      local _padding_columns="${2:-}"
      local _padding_centered="${3:-}"

      local _padding_amount=$(( (_padding_columns-_padding_line_length) / 2 ))
      if ((_padding_centered)) && ((_padding_amount))
      then
        printf "%-${_padding_amount}s" " "
      fi
    }

    local _separator=
    if ! ((_plain))
    then
      _separator=" Â·"
    fi

    local _notebook_names_raw
    _notebook_names_raw=($(
      _notebooks --names --no-color --unarchived --global
    ))

    local _notebook_names_hi
    _notebook_names_hi=($(_notebooks --names --unarchived --global))

    local _notebook_names_archived=
    _notebook_names_archived=($(
      _notebooks --names --no-color --archived
    ))
    local _archived_count="${#_notebook_names_archived[@]}"

    if ((_archived_count))
    then
      _notebook_names_hi=(
        "${_notebook_names_hi[@]}"
        "[${_archived_count} archived]"
      )
      _notebook_names_raw=(
        "${_notebook_names_raw[@]}"
        "[${_archived_count} archived]"
      )
    fi

    if [[ -n "${_LOCAL_NOTEBOOK_PATH:-}" ]]
    then
      if [[ "${_NOTEBOOK_PATH}" == "${_LOCAL_NOTEBOOK_PATH}" ]]
      then
        _notebook_names_hi=(
          "$(_highlight "local" --underline)"
          "${_notebook_names_hi[@]}"
        )
      else
        _notebook_names_hi=(
          "local"
          "${_notebook_names_hi[@]}"
        )
      fi
      _notebook_names_raw=(
        "local"
        "${_notebook_names_raw[@]}"
      )
    fi

    local _line_number=0
    local _padding=

    local _test_line=
    local _line_raw=
    local _line_hi=
    local _output_raw=
    local _output_hi=

    for ((i=0;i < "${#_notebook_names_raw[@]}"; i++))
    do
      if [[ -z "${_test_line}" ]]
      then # first item in line
        _test_line="${_notebook_names_raw[i]}"
      else
        _test_line="${_test_line}${_separator} ${_notebook_names_raw[i]}"
      fi

      if [[ "${#_test_line}" -gt "${_columns}" ]]
      then # wrap to next line
        # Use the existing value of $_line_[highlighted|raw] without the
        # current name.
        if ((_auto_align)) || ((_centered)) && ! ((_justified))
        then
          _centered=1
          _padding="$(
            _print_padding "${_line_raw}" "${_columns}" "${_centered}"
          )"
        fi

        _output_hi="${_output_hi}${_padding}${_line_hi}\\n"
        _output_raw="${_output_raw}${_padding}${_line_raw}\\n"
        _line_number=$((_line_number + 1))

        # Start the line for the next iteration using the current name.
        _test_line="${_notebook_names_raw[i]}"
        _line_hi="${_notebook_names_hi[i]:-}"
        _line_raw="${_notebook_names_raw[i]}"
      else # add to line
        if [[ -z "${_line_hi}" ]]
        then # first item in highlighted line
          _line_hi="${_notebook_names_hi[i]:-}"
          _line_raw="${_notebook_names_raw[i]}"
        else
          _line_hi="${_line_hi}${_separator} ${_notebook_names_hi[i]:-}"
          _line_raw="${_line_raw}${_separator} ${_notebook_names_raw[i]}"
        fi
      fi

      if [[ "${#_notebook_names_raw[@]}" == $((i+1)) ]]
      then # end of list
        if ((_line_number)) && ! ((_justified)) &&
           ((_auto_align))  ||   ((_centered))
        then
          _centered=1
        fi
        _padding="$(
          _print_padding "${_line_raw}" "${_columns}" "${_centered}"
        )"

        _output_hi="${_output_hi}${_padding}${_line_hi}\\n"
        _output_raw="${_output_raw}${_padding}${_line_raw}\\n"
        _line_number=$((_line_number + 1))
      fi
    done

    while read -r __line
    do
      _maybe_notebook_list="${_maybe_notebook_list}${__line}${_NEWLINE}"
    done < <({
      printf "%b" "${_output_hi}"

      # Use control characters to disable wrapping for long lines.
      # Source: http://superuser.com/a/189068
      printf '\033[?7l'
      if ((_centered))
      then # print full-width line.
        _print_line "$(printf "%-${_columns}s" '.')" | tr -d '\n'
      else # print line the length of the first line.
        _print_line "$(
          # $_output_raw generates a line 2 characters too long. TODO: Review
          printf "%s" "${_output_raw}" | sed 's/..$//'
        )" | tr -d '\n'
      fi
      printf "%s" "${_TPUT_SGR0}"
      printf '\033[?7h'
      printf '\n'
    })
  fi

  local _notes_count_local=0
  local _notes_count_total=0
  _notes_count_total="$(_count)"

  local _size=
  _size="$(stty size)"
  local _lines="${_size% *}"
  local _use_pager=0

  if [[ "${_notes_count_total}" -gt $((_lines-4)) ]]
  then
    _notes_count_local="$(
      _list \
        -n "${_lines}"  \
        "${_args[@]:-}" \
        --no-id         \
        --no-indicators \
        --filenames     \
        | wc -l
    )"
  fi

  if [[ "${_notes_count_local}" -gt $((_lines-4))           ]] &&
     [[ "${_limit}"             -gt "${_notes_count_local}" ]]
  then
    _use_pager=1
  fi

  {
    printf "%s" "${_maybe_notebook_list}"
    _list -n "${_limit}" "${_args[@]:-}"

    if ((NB_FOOTER))
    then
      local _scope=
      if ((_SCOPED)) && [[ -n "${_SCOPE}" ]]
      then
        _scope="${_SCOPE}:"
      fi

      _commands_raw=(
        "â¯ ${_ME} ${_scope}ls"
        "${_ME} ${_scope}add"
        "${_ME} ${_scope}b <url>"
        "${_ME} edit ${_scope}<id>"
        "${_ME} show ${_scope}<id>"
        "${_ME} open ${_scope}<id>"
        "${_ME} ${_scope}search <query>"
        "${_ME} notebooks add <name>"
        "${_ME} settings"
        "${_ME} help"
      )

      _commands_hi=(
        "â¯ $(_highlight_secondary "${_ME} ${_scope}ls")"
          "$(_highlight_secondary "${_commands_raw[1]}")"
          "$(_highlight_secondary "${_commands_raw[2]}")"
          "$(_highlight_secondary "${_commands_raw[3]}")"
          "$(_highlight_secondary "${_commands_raw[4]}")"
          "$(_highlight_secondary "${_commands_raw[5]}")"
          "$(_highlight_secondary "${_commands_raw[6]}")"
          "$(_highlight_secondary "${_commands_raw[7]}")"
          "$(_highlight_secondary "${_commands_raw[8]}")"
          "$(_highlight_secondary "${_commands_raw[9]}")"
      )

      local _line_hi=
      local _line_raw=
      local _output_raw=
      local _output_hi=
      local _separator_raw=" Â·"
      local _separator_hi=
      _separator_hi="$(_highlight "${_separator_raw}")"
      local _test_line=

      for ((i=0;i < "${#_commands_raw[@]}"; i++))
      do
        if [[ -z "${_test_line}" ]]
        then # first item in line
          _test_line="${_commands_raw[i]}"
        else
          _test_line="${_test_line}${_separator_raw} ${_commands_raw[i]}"
        fi

        if [[ "${#_test_line}" -gt "${_columns}" ]]
        then # wrap to next line
          _output_hi="${_output_hi}${_line_hi}${_NEWLINE}"
          _output_raw="${_output_raw}${_line_raw}${_NEWLINE}"

          # Start the line for the next iteration using the current name.
          _test_line="${_commands_raw[i]}"
          _line_hi="${_commands_hi[i]:-}"
          _line_raw="${_commands_raw[i]}"
        else # add to line
          if [[ -z "${_line_hi}" ]]
          then # first item in highlighted line
            _line_hi="${_commands_hi[i]:-}"
            _line_raw="${_commands_raw[i]}"
          else
            _line_hi="${_line_hi}${_separator_hi} ${_commands_hi[i]:-}"
            _line_raw="${_line_raw}${_separator_raw} ${_commands_raw[i]}"
          fi
        fi

        if [[ "${#_commands_raw[@]}" == $((i+1)) ]]
        then # end of list
          _output_hi="${_output_hi}${_line_hi}"
          _output_raw="${_output_raw}${_line_raw}"
        fi
      done

      printf '\033[?7l'
      _print_line "$(printf "%-${_columns}s" '.')" | tr -d '\n'
      printf "%s" "${_TPUT_SGR0}"
      printf '\033[?7h'
      printf '\n'
      cat <<HEREDOC
${_output_hi}
HEREDOC
    fi
  } | if ((_use_pager)) && [[ -n "${PAGER:-}" ]] && [[ ! "${PAGER}" =~ less ]]
      then
        "${PAGER}"
      elif ((_use_pager)) && _command_exists "less"
      then
        less -r --CLEAR-SCREEN --prompt="$(_less_prompt)"
      else
        cat
      fi
}

# move ################################################################### move

desc "move" <<HEREDOC
Usage:
  ${_ME} move (<id> | <filename> | <path> | <title>) [-f | --force] <notebook>

Options:
  -f, --force   Skip the confirmation prompt.

Description:
  Move the specified note to <notebook>.

Examples:
  ${_ME} move 1 example-notebook
  ${_ME} move example.md example-notebook

Shortcut Alias: \`mv\`
HEREDOC
_move() {
  local _basename=
  local _force=0
  local _selection=
  local _source_info_line=
  local _target_notebook=
  local _target_notebook_path=
  local _title=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        elif [[ -z "${_target_notebook}" ]]
        then
          _target_notebook="${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_move() \${_selection}: '%s'\\n" "${_selection}"
  _debug printf "_move() \${_target_notebook}: '%s'\\n" "${_target_notebook}"
  if [[ -z "${_selection:-}" ]] || [[ -z "${_target_notebook:-}" ]]
  then
    _exit_1 _help "move"
  fi

  if [[ "${_target_notebook}" =~ :$ ]]
  then
    _target_notebook="$(printf "%s\\n" "${_target_notebook}" | tr -d ':')"
  fi
  _debug printf "_move() \${_target_notebook}: '%s'\\n" "${_target_notebook}"

  _basename="$(_get_selection_basename "${_selection}")"

  _set_selection_notebook "${_selection}"

  if [[ "${_target_notebook}" == "local" ]] &&
     [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"   ]]
  then
    _target_notebook_path="${_LOCAL_NOTEBOOK_PATH}"
  else
    _target_notebook_path="${NB_DIR}/${_target_notebook}"
  fi

  if [[ -z "${_basename}"                     ]] ||
     [[ ! -e "${_target_notebook_path}/.git"  ]]
  then
    _exit_1 _help "move"
  elif [[ ! -e "${_NOTEBOOK_PATH}/${_basename}" ]]
  then
    _exit_1 printf "Not Found: %s\\n" "$(_highlight "${_SCOPE}:${_basename}")"
  elif [[ -e "${_target_notebook_path}/${_basename}" ]]
  then
    _exit_1 printf "Already exists: %s\\n" "$(_highlight "${_SCOPE}:${_basename}")"
  fi

  _debug printf "_move() \${_basename}: '%s'\\n" "${_basename}"

  _title="$(_get_title "${_NOTEBOOK_PATH}/${_basename}")"
  if [[ -n "${_title}" ]]
  then
    _source_info_line="${_SCOPE}:${_basename} '${_title}'"
  else
    _source_info_line="${_SCOPE}:${_basename}"
  fi

  if ! ((_force))
  then
    printf "Moving %s to notebook %s\\n"      \
      "$(_highlight "${_source_info_line}")"  \
      "$(_highlight "${_target_notebook}")"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  if [[ -d "${_NOTEBOOK_PATH}/${_basename}" ]]
  then
    "${_MY_PATH}" \
      "${_target_notebook}:import" \
      "${_NOTEBOOK_PATH}/${_basename}" 1> /dev/null
  else
    cat "${_NOTEBOOK_PATH}/${_basename}" \
      | "${_MY_PATH}" "${_target_notebook}:add" "${_basename}" 1> /dev/null
  fi

  "${_MY_PATH}" delete "${_SCOPE}:${_basename}" --force 1> /dev/null

  local _id
  _id="$(
    "${_MY_PATH}" "${_target_notebook}:index" get_id "${_basename}"
  )"

  if [[ ! -e "${_NOTEBOOK_PATH}/${_basename}"       ]] ||
     [[ -e "${_target_notebook_path}/${_basename}"  ]]
  then
    printf "Moved to %s %s\\n"                              \
      "$(_id_brackets_color "${_target_notebook}:${_id}")"  \
      "$(_highlight "${_target_notebook}:${_basename}")"
  fi
}
_alias_subcommand "move" "mv"

# notebooks ######################################################### notebooks

desc "notebooks" <<HEREDOC
Usage:
  ${_ME} notebooks [<name>] [--archived] [--global] [--local] [--names]
               [--no-color] [--paths] [--unarchived]
  ${_ME} notebooks add <name> [<remote-url>]
  ${_ME} notebooks (archive | open | peek | status | unarchive) [<name>]
  ${_ME} notebooks current [--path]
  ${_ME} notebooks delete <name> [-f | --force]
  ${_ME} notebooks (export <name> [<path>] | import <path>)
  ${_ME} notebooks init [<path> [<remote-url>]]
  ${_ME} notebooks rename <old-name> <new-name>
  ${_ME} notebooks use <name>

Options:
  --archived    Only list archived notebooks.
  --global      List global notebooks.
  --local       List local notebook.
  -f, --force   Skip the confirmation prompt.
  --names       Only print each notebook's name.
  --no-color    Print names without highlighting the current notebook.
  --path        Print the path of the current notebook.
  --paths       Print the path of each notebook.
  --unarchived  Only list unarchived notebooks.

Subcommands:
  (default)  List notebooks.
  add        Create a new global notebook. When an existing notebook's
             <remote-url> is specified, create the new global notebook as a
             clone of <remote-url>.
             Aliases: \`notebooks create\`, \`notebooks new\`
  archive    Set the current notebook or notebook <name> to 'archived' status.
  export     Export the notebook <name> to the current directory or <path>,
             making it usable as a local notebook.
  import     Import the local notebook at <path> to make it global.
  init       Create a new local notebook. Specify a <path> or omit to
             initialize the current working directory as a local notebook.
             Specify <remote-url> to clone an existing notebook.
  current    Print the current notebook name.
  delete     Delete a notebook.
  open       Open the current notebook directory or notebook <name> in your
             file browser, explorer, or finder.
             Shortcut Alias: \`o\`
  peek       Open the current notebook directory or notebook <name> in the
             first tool found in this list:
             \`ranger\` [1], \`mc\` [2], \`exa\` [3] or \`ls\`.
             Shortcut Alias: \`p\`
  rename     Rename a notebook.
  status     Print the archival status of the current notebook or
             notebook <name>.
  unarchive  Remove 'archived' status from current notebook or notebook <name>.
  use        Switch to a notebook.

    1. https://ranger.github.io/
    2. https://en.wikipedia.org/wiki/Midnight_Commander
    3. https://github.com/ogham/exa

Description:
  Manage notebooks.

Examples:
  ${_ME} notebooks --names
  ${_ME} notebooks add Example1
  ${_ME} notebooks add Example2 https://github.com/example/example.git

Shortcut Alias: \`n\`
HEREDOC
_notebooks() {
  # _notebooks_add()
  #
  # Usage:
  #   _notebooks_add <name> [<remote_url>]
  _notebooks_add() {
    local _name="${1:-}"
    if [[ -z "${_name}" ]]
    then
      _exit_1 _help notebooks
    fi

    if [[ -e "${NB_DIR}/${_name}" ]]
    then
      _exit_1 printf "Already exists: %s\\n" "$(_highlight "${_name}")"
    fi

    local _repo_url="${2:-}"
    if [[ -n "${_repo_url}" ]]
    then
      git clone "${_repo_url}" "${NB_DIR}/${_name}"
      printf "%s\\n" "${_name}" > "${NB_DIR}/.current"
    else
      mkdir -p "${NB_DIR}/${_name}"
      cd "${NB_DIR}/${_name}"              &&
        git init 1>/dev/null               &&
        touch "${NB_DIR}/${_name}/.index"  &&
        _clear_cache                       &&
        _git_checkpoint "[nb] Initialize" "${NB_DIR}/${_name}"
    fi
    printf "Added notebook: %s\\n" "$(_highlight "${_name}")"
  }

  # _notebooks_current()
  #
  # Usage:
  #   _notebooks_current --path
  _notebooks_current() {
    local _path=0
    if [[ "${1:-}" == "--path" ]]
    then
      _path=1
    fi

    if ((_path))
    then
      printf "%s\\n" "${_NOTEBOOK_PATH}"
    else
      if [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"                    ]] &&
         [[ "${_NOTEBOOK_PATH}" == "${_LOCAL_NOTEBOOK_PATH}"  ]]
      then
        printf "local\\n"
      else
        basename "${_NOTEBOOK_PATH}"
      fi
    fi
  }

  # _notebooks_delete()
  #
  # Usage:
  #   _notebooks_delete <name>
  _notebooks_delete() {
    local _name="${1:-}"
    if [[ -z "${_name}" ]] || [[ "${_name}" =~ ^\-f$|^\-\-force$ ]]
    then
      _exit_1 _help notebooks
    elif [[ "${_name}" == "local"          ]] &&
         [[ -n "${_LOCAL_NOTEBOOK_PATH:-}" ]]
    then
      _exit_1 cat <<HEREDOC
Use your system's shell or file explorer to delete local notebook directories.
HEREDOC
    fi

    local _force=0
    if [[ "${2:-}" =~ ^\-f$|^\-\-force$ ]]
    then
      _force=1
    fi

    if [[ ! -d "${NB_DIR}/${_name}"        ]] ||
       [[ ! -e "${NB_DIR}/${_name}/.git"   ]] ||
       [[ ! -e "${NB_DIR}/${_name}/.index" ]]
    then
      _exit_1 printf "Notebook not found: %s\\n" "$(_highlight "${_name}")"
    fi

    local _notebook_names=
    _notebook_names=($(_notebooks --names --no-color))

    local _notebook_count=
    _notebook_count="${#_notebook_names[@]}"

    if ! ((_force))
    then
      cat <<HEREDOC
Deleting $(_highlight "${_name}").

This action cannot be undone. This will permanently delete the
$(_highlight "${_name}") notebook, all notes and files it contains,
and the entire revision history.

HEREDOC
      while true
      do
        read -r -p "\
Please type $(_highlight "${_name}") to confirm: " __response
        if [[ "${__response}" == "${_name}" ]]
        then
          break
        else
          printf "Exiting...\\n"
          exit 0
        fi
      done
    fi

    if [[ "$(_notebooks current)" == "${_name}" ]] &&
       [[ "${_notebook_count}" -gt 1            ]]
    then
      if [[ "${_name}" != "home" ]]
      then
        _notebooks use "home"
      else
        for __notebook in "${_notebook_names[@]:-}"
        do
          if [[ "${__notebook}" != "$(_notebooks current)" ]]
          then
            _notebooks use "${__notebook}"
            break
          fi
        done
      fi
    fi

    if _command_exists "trash" && [[ "${OSTYPE}" =~ ^darwin ]]
    then
      trash "${NB_DIR:?}/${_name}"
    else
      rm -r -f "${NB_DIR:?}/${_name}"
    fi &&
      _clear_cache &&
      printf "Notebook deleted: %s\\n" "$(_highlight "${_name}")"
  }

  # _notebooks_export()
  #
  # Usage:
  #   _notebooks_export <name> [<path>]
  _notebooks_export() {
    local _name="${1:-}"
    if [[ -z "${_name:-}" ]]
    then
      _exit_1 _help "notebooks"
    fi

    if [[ ! -d "${NB_DIR}/${_name}" ]]
    then
      _exit_1 printf "Notebook not found: %s\\n" "$(_highlight "${_name}")"
    fi

    local _target_path="${2:-}"

    if [[ -n "${_target_path:-}" ]] && [[ ! "${_target_path}" =~ ^/ ]]
    then
      _target_path="${_CURRENT_WORKING_DIR}/${_target_path}"
    fi

    if [[ -n "${_target_path:-}"              ]] &&
       [[ -d "${_target_path}"                ]] &&
       [[ ! "${_target_path}" =~ \/${_name}$  ]]
    then
      _target_path="${_target_path}/${_name}"
    fi

    if [[ -z "${_target_path}" ]]
    then
      _target_path="${_CURRENT_WORKING_DIR}/${_name}"
    fi

    _target_path="$(_get_unique_path "${_target_path}")"

    cp -R "${NB_DIR}/${_name}" "${_target_path}"  &&
      _clear_cache                                &&
      printf "Exported notebook %s to %s\\n"  \
        "$(_highlight "${_name}")"            \
        "$(_highlight "${_target_path}")"
  }

  # _notebooks_import()
  #
  # Usage:
  #   _notebooks_import <path> [<name>]
  _notebooks_import() {
    local _path="${1:-}"
    if [[ -z "${_path:-}" ]]
    then
      _exit_1 _help "notebooks"
    fi

    local _basename=
    _basename="$(basename "${_path}")"

    if [[ ! "${_path}" =~ ^/ ]]
    then
      _path="${_CURRENT_WORKING_DIR}/${_path}"
    fi

    if [[ ! -d "${_path}" ]]
    then
      _exit_1 printf "Not a directory %s" "$(_highlight "${_path}")"
    fi

    local _target_basename="${2:-}"
    if [[ -z "${_target_basename:-}" ]]
    then
      _target_basename="${_basename}"
    fi

    local _target_path=
    _target_path="$(_get_unique_path "${NB_DIR}/${_target_basename}")"

    cp -R "${_path}" "${_target_path}"  &&
      _clear_cache                      &&
      printf "Imported notebook %s\\n" \
        "$(_highlight "$(basename "${_target_path}")")"
  }

  # _notebooks_init()
  #
  # Usage:
  #   _notebooks_init [<path> [<remote_url>]]
  _notebooks_init() {
    local _path=
    local _remote_url=

    for __arg in "${@:-}"
    do
      if _string_is_url "${__arg}" && [[ -z "${_remote_url:-}" ]]
      then
        _remote_url="${__arg}"
      elif [[ -z "${_path:-}" ]]
      then
        _path="${__arg}"
      fi
    done

    if [[ -n "${_remote_url:-}" ]] && [[ -z "${_path}" ]]
    then
      _exit_1 printf \
        "Must specify a <path> when cloning from <remote-url>.\\n%s\\n" \
        "$(_help "notebooks")"
    fi

    if [[ -n "${_path:-}" ]]
    then
      if [[ ! "${_path}" =~ ^/ ]]
      then
        _path="${_CURRENT_WORKING_DIR}/${_path}"
      fi

      if [[ ! -e "${_path}" ]]
      then
        mkdir -p "${_path}"
      elif [[ -f "${_path}" ]]
      then
        _exit_1 printf "File already exists: %s\\n" "$(_highlight "${_path}")"
      fi
    else
      _path="${_CURRENT_WORKING_DIR}"
    fi

    if [[ -d "${_path}"       ]] &&
       [[ -d "${_path}/.git"  ]]
    then
      local _error_message=
      if [[ -f "${_path}/.index" ]]
      then
        printf "Notebook exists: %s\\n" "$(_highlight "${_path}")"
        _error_message="Notebook exists: $(_highlight "${_path}")"
      else
        _error_message="Git repository exists: $(_highlight "${_path}")"
      fi

      _exit_1 printf "%s\\n" "${_error_message}"
    fi

    if [[ "${_path}" != "${_CURRENT_WORKING_DIR}" ]] &&
       [[ -n "${_remote_url:-}"                   ]]
    then
      git clone "${_remote_url}" "${_path}"
    else
      cd "${_path}"             &&
        git init 1>/dev/null    &&
        touch "${_path}/.index" &&
        _git_checkpoint "[nb] Initialize" "${_path}"
    fi
    printf "Initialized local notebook: %s\\n" "$(_highlight "${_path}")"
  }

  # _notebooks_list()
  #
  # Usage:
  #   _notebooks_list [<name>] [--archived] [--local] [--global] [--names]
  #                   [--no-color] [--paths] [--unarchived]
  _notebooks_list() {
    local _notebook_names=()
    local _notebook_paths=()
    local _no_color=0
    local _only_archived=0
    local _only_global=0
    local _only_local=0
    local _only_names=0
    local _only_paths=0
    local _only_unarchived=0

    _debug printf "_notebooks_list() \${@:-}: '%s'\\n" "${@:-}"

    for __arg in "${@:-}"
    do
      case "${__arg}" in
        --archived)
          _only_archived=1
          ;;
        --local)
          _only_local=1
          ;;
        --global)
          _only_global=1
          ;;
        --names)
          _only_names=1
          ;;
        --nocolor|--no-color)
          _no_color=1
          ;;
        --paths)
          _only_paths=1
          ;;
        --unarchived)
          _only_unarchived=1
          ;;
        *)
          _notebook_names+=("${__arg}")
          ;;
      esac
    done

    if [[ -z "${NB_DIR}" ]] || [[ ! -e "${NB_DIR}" ]]
    then
      exit 1
    fi

    if [[ -z "${_notebook_names[*]:-}" ]]
    then
      _notebook_names=($(ls -1 "${NB_DIR}"))
      set +f
      _notebook_paths=($(ls -1 -d "${NB_DIR}"/*))
      set -f

      if [[ -n "${_LOCAL_NOTEBOOK_PATH:-}" ]]
      then
        _notebook_names=("local" "${_notebook_names[@]:-}")
        _notebook_paths=("${_LOCAL_NOTEBOOK_PATH}" "${_notebook_paths[@]:-}")
      fi
    else
      for __name in "${_notebook_names[@]}"
      do
        if [[ "${__name}" == "local" ]]
        then
          _notebook_paths+=("${_LOCAL_NOTEBOOK_PATH}")
        else
          _notebook_paths+=("${NB_DIR}/${__name}")
        fi
      done
    fi

    _debug printf \
      "_notebooks_list() \${_only_names:-}: '%s'\\n" \
      "${_only_names:-}"
    _debug printf \
      "_notebooks_list() \${_notebook_names[*]}: '%s'\\n" \
      "${_notebook_names[*]:-}"
    _debug printf \
      "_notebooks_list() \${_notebook_paths[*]}: '%s'\\n" \
      "${_notebook_paths[*]:-}"

    for ((i=0;i < "${#_notebook_names[@]}"; i++))
    do
      if [[ -e "${_notebook_paths[i]}/.git" ]]
      then # it's a git repository.
        local _notebook_line=
        local _origin_url=

        if [[ "${i}" == "0" ]]                      &&
           [[ "${_notebook_names[i]}" == "local" ]] &&
           [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"     ]]
        then # local notebook as first notebook
          if ((_only_global))
          then
            continue
          else
            if ((_only_paths))
            then
              _notebook_line="${_notebook_paths[i]}"
            elif ((_no_color)) || [[ "${_SCOPE}" != "local" ]]
            then
              _notebook_line="local"
            else
              _notebook_line="$(_highlight "local" --underline)"
            fi
          fi
        elif ((_only_local))
        then
          if [[ -z "${_LOCAL_NOTEBOOK_PATH:0}" ]]
          then
            return 1
          else
            continue
          fi
        else
          if ((_only_paths))
          then
            _notebook_line="${_notebook_paths[i]}"
          elif ((_no_color))
          then
            _notebook_line="${_notebook_names[i]}"
          else
            if [[ "${_SCOPE}" == "${_notebook_names[i]}" ]]
            then # it's the current repository.
              _notebook_line="$(_highlight "${_notebook_names[i]}")"

              if [[ "${#_notebook_names[@]}" -gt 1 ]]
              then
                _notebook_line="$(
                  _highlight "${_notebook_names[i]}" --underline
                )"
              fi
            else
              _notebook_line="${_notebook_names[i]}"
            fi
          fi
        fi

        if [[ -e "${_notebook_paths[i]}/.archived" ]]
        then
          if ((_only_unarchived))
          then
            continue
          elif ! ((_only_names)) && ! ((_only_paths))
          then
            _notebook_line="${_notebook_line} (archived)"
          fi
        elif ((_only_archived))
        then
          continue
        fi

        if ! ((_only_names)) && ! ((_only_paths))
        then
          cd "${_notebook_paths[i]}" ||
            _exit_1 printf "_notebooks() \`cd\` failed."
          _origin_url="$(git config --get remote.origin.url || echo '')"
          if [[ -n "${_origin_url:-}" ]]
          then
            _notebook_line="${_notebook_line} (${_origin_url})"
          fi
        fi

        printf "%s\\n" "${_notebook_line}"
      fi
    done
  }

  # _notebooks_notebook()
  #
  # Usage:
  #   _notebooks_notebook <subcommand> <name>
  _notebooks_notebook() {
    local _subcommand="${1:-}"

    local _notebook_name="${2:-}"
    if [[ -n "${_notebook_name:-}" ]]
    then
      _NOTEBOOK_PATH="${NB_DIR}/${_notebook_name}"
    else
      _notebook_name="$(_notebooks current)"
    fi

    if [[ -z "${_notebook_name:-}" ]]
    then
      _exit_1 printf "Unable to determine notebook name.\\n"
    fi

    if [[ -z "${_subcommand}" ]]
    then
      printf "%s\\n" "${_notebook_name}"
      return 0
    fi

    if [[ "${_subcommand:-}" =~ ^open$|^o$ ]]
    then
      if _command_exists "xdg-open"
      then
        xdg-open "${_NOTEBOOK_PATH}"
      elif _command_exists "open"
      then
        open "${_NOTEBOOK_PATH}"
      else
        _exit_1 printf \
          "%s doesn't know how to open directories on your system.\\n" \
          "$(_highlight "${_ME}")"
      fi
    elif [[ "${_subcommand:-}" =~ ^peek$|^p$ ]]
    then
      if _command_exists "ranger"
      then
        ranger "${_NOTEBOOK_PATH}"
      elif _command_exists "mc"
      then
        mc "${_NOTEBOOK_PATH}"
      elif _command_exists "exa"
      then
        exa -lah --git "${_NOTEBOOK_PATH}"
      else
        # gnu || bsd
        ls -lah --color=always "${_NOTEBOOK_PATH}" 2>/dev/null ||
          ls -lah -G "${_NOTEBOOK_PATH}"
      fi
    else
      local _dotfile_path="${_NOTEBOOK_PATH}/.archived"

      if [[ "${_subcommand}" == "archive" ]]
      then
        if [[ ! -e "${_dotfile_path}" ]]
        then
          touch "${_dotfile_path}" &&
            _git_checkpoint "[nb] Archived"
        fi

        printf "%s archived.\\n" "$(_highlight "${_notebook_name}")"
      elif [[ "${_subcommand}" == "status" ]]
      then
        if [[ -e "${_dotfile_path}" ]]
        then
          printf "%s is archived.\\n" "$(_highlight "${_notebook_name}")"
        else
          printf "%s is not archived.\\n" "$(_highlight "${_notebook_name}")"
        fi
      elif [[ "${_subcommand}" == "unarchive" ]]
      then
        if [[ -e "${_dotfile_path}" ]]
        then
          rm "${_dotfile_path}" &&
            _git_checkpoint "[nb] Unarchived"
        fi

        printf "%s unarchived.\\n" "$(_highlight "${_notebook_name}")"
      fi
    fi
  }

  # _notebooks_rename()
  #
  # Usage:
  #   _notebooks_rename <old> <new>
  _notebooks_rename() {
    local _old="${1:-}"
    local _new="${2:-}"

    if [[ -z "${_old}" ]] || [[ -z "${_new}" ]]
    then
      _exit_1 _help notebooks
    elif [[ -n "${_LOCAL_NOTEBOOK_PATH:-}" ]]
    then
      if [[ "${_old}" == "local" ]] || [[ "${_new}" == "local" ]]
      then
        _exit_1 cat <<HEREDOC
'local' refers to the local notbook and can not be renamed.
HEREDOC
      fi
    elif [[ ! -d "${NB_DIR}/${_old}" ]]
    then
      _exit_1 printf "%s is not a valid notebook name.\\n" \
        "$(_highlight "${_old}")"
    elif [[ -e "${NB_DIR}/${_new}" ]]
    then
      _exit_1 printf "A notebook named '%s' already exists.\\n" \
        "$(_highlight "${_new}")"
    fi

    mv "${NB_DIR}/${_old}" "${NB_DIR}/${_new}"

    if [[ "$(cat "${NB_DIR}/.current")" == "${_old}" ]]
    then
      printf "%s\\n" "${_new}" > "${NB_DIR}/.current"
    fi

    _clear_cache
    printf "%s is now named %s\\n" \
      "$(_highlight "${_old}")"    \
      "$(_highlight "${_new}")"
  }

  # _notebooks_use()
  #
  # Usage:
  #   _notebooks_use <name>
  _notebooks_use() {
    local _name="${1:-}"

    if [[ -z "${_name}" ]]
    then
      _exit_1 _help notebooks
    fi

    if [[ -n "${_LOCAL_NOTEBOOK_PATH}" ]]
    then
      _exit_1 cat <<HEREDOC
Currently in a local notebook. To run a command in a global notebook,
add the notebook name before the command name, separated by a colon:
  ${_ME} <notebook>:<command> [options...]

Examples:
  ${_ME} home:list
  ${_ME} example:add --title "Example Title"
  ${_ME} example:search 'sample query'
HEREDOC
    fi

    # Autocomplete can result in a trailing colon on the notebook name, so
    # remove it if present.
    if [[ "${_name}" =~ :$ ]]
    then
      _name=$(printf "%s\\n" "${_name}" | cut -f 1 -d ":")
    fi

    if [[ -d "${NB_DIR}/${_name}/.git" ]]
    then
      printf "%s\\n" "${_name}" > "${NB_DIR}/.current"
      printf "Now using %s.\\n" "$(_highlight "${_name}")"
    else
      _exit_1 printf "Not found: %s\\n" "$(_highlight "${_name}")"
    fi
  }

  _notebooks_add_new() {
    local _notebook_list=
    _notebook_list=($(
      find "${NB_DIR}" -mindepth 1 -maxdepth 1 -type d | grep -v '/\.'
    ))

    for __notebook_path in "${_notebook_list[@]}"
    do
      if [[ ! -d "${__notebook_path}/.git" ]]
      then
        cd "${__notebook_path}"             &&
          git init 1>/dev/null              &&
          touch "${__notebook_path}/.index" &&
          _clear_cache                      &&
          _git_checkpoint "[nb] Initialize" "${__notebook_path}"
      fi
    done
  }

  _notebooks_add_new

  local _subcommand="${1:-}"
  local _name="${2:-}"

  case "${_subcommand}" in
    ^a$|add|create|new)
      _notebooks_add "${_name:-}" "${3:-}"
      ;;
    export)
      _notebooks_export "${2:-}" "${3:-}"
      ;;
    import)
      _notebooks_import "${2:-}" "${3:-}"
      ;;
    init)
      _notebooks_init "${_name:-}" "${3:-}"
      ;;
    current)
      _notebooks_current "${_name:-}"
      ;;
    delete)
      _notebooks_delete "${_name:-}" "${3:-}"
      ;;
    rename)
      _notebooks_rename "${_name:-}" "${3:-}"
      ;;
    use)
      _notebooks_use "${_name:-}"
      ;;
    archive|open|peek|status|unarchive)
      _notebooks_notebook "${_subcommand}" "${_name:-}"
      ;;
    *)
      _notebooks_list "${@}"
      ;;
  esac
}
_alias_subcommand "notebooks" "n"
_alias_subcommand "notebooks" "nb"
_alias_subcommand "notebooks" "nbs"
_alias_subcommand "notebooks" "notebook"
_alias_subcommand "notebooks" "ns"

# open ################################################################### open

desc "open" <<HEREDOC
Usage:
  ${_ME} open (<id> | <filename> | <path> | <title>)

Description:
  Open the note file. When the note is a bookmark, open the bookmarked page in
  your system's primary web browser. When the note is in a text format or any
  other file type, \`open\` is the equivalent of \`edit\`.

See also:
  ${_ME} help bookmark
  ${_ME} help edit

Shortcut Alias: \`o\`
HEREDOC
_open() {
  if [[ -z "${1:-}" ]]
  then
    _exit_1 _help "open"
  fi

  _bookmark open "${@}"
}
_alias_subcommand "open" "o"

# peek ################################################################### peek

desc "peek" <<HEREDOC
Usage:
  ${_ME} peek (<id> | <filename> | <path> | <title>)

Description:
  When the note is a bookmark, view the bookmarked page in your terminal web
  browser. When the note is in a text format or any other file type, \`peek\`
  is the equivalent of \`show\`.

See also:
  ${_ME} help bookmark
  ${_ME} help show

Alias: \`preview\`
Shortcut Alias: \`p\`
HEREDOC
_peek() {
  if [[ -z "${1:-}" ]]
  then
    _exit_1 _help "peek"
  fi

  _bookmark peek "${@}"
}
_alias_subcommand "peek" "p"
_alias_subcommand "peek" "preview"

# remote ############################################################### remote

desc "remote" <<HEREDOC
Usage:
  ${_ME} remote
  ${_ME} remote remove
  ${_ME} remote set <url> [-f | --force]

Subcommands:
  (default)     Print the remote URL for the notebook.
  remove        Remove the remote URL from the notebook.
  set           Set the remote URL for the notebook.

Options:
  -f, --force   Skip the confirmation prompt.

Description:
  Get, set, and remove the remote repository URL for the current notebook.

Examples:
  ${_ME} remote set https://github.com/example/example.git
  ${_ME} remove remove
HEREDOC
_remote() {
  local _existing_url=
  local _force=0
  local _remote_exists=0
  local _subcommand=
  local _url=

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      -f|--force)
        _force=1
        ;;
      *)
        if [[ -z "${_subcommand}" ]]
        then
          _subcommand="${__arg}"
        elif [[ "${_subcommand}" =~ ^set$|^add$ ]] &&
             [[ -z "${_url}" ]]
        then
          _url="${__arg}"
        fi
        ;;
    esac
  done
  _debug printf "_remote() \${_subcommand}: '%s'\\n" "${_subcommand}"
  _debug printf "_remote() \${_url}: '%s'\\n" "${_url}"

  cd "${_NOTEBOOK_PATH}" || _exit_1 printf "_git() \`cd\` failed.\\n"

  if [[ "$(git remote get-url origin 2>/dev/null)" ]]
  then
    _remote_exists=1
    _existing_url="$(git remote get-url origin)"
  fi

  _debug printf "_remote() \${_remote_exists}: '%s'\\n" "${_remote_exists}"
  _debug printf "_remote() \${_existing_url}: '%s'\\n" "${_existing_url}"

  case "${_subcommand}" in
    remove|rm)
      if ((_remote_exists))
      then
        if ! ((_force))
        then
          while true
          do
            printf "Removing remote %s\\n" "$(_highlight "${_existing_url}")"
            read -r -p "Do you want to proceed? [y/N] " __yn
            case ${__yn} in
              [Yy]*)
                break
                ;;
              *)
                printf "Exiting...\\n"
                exit 0
                ;;
            esac
          done
        fi

        git remote rm origin &&
          printf "Removed remote %s\\n" "$(_highlight "${_existing_url}")" &&
          return 0
      else
        _exit_1 printf "No remote configured.\\n"
      fi
      ;;
    set|add)
      if [[ -z "${_url}" ]]
      then
        _exit_1 _help "remote"
      fi

      if ((_remote_exists))
      then
        if [[ "${_existing_url}" == "${_url}" ]]
        then
          _exit_1 printf "Remote already set to %s\\n" "$(_highlight "${_url}")"
        fi

        if ! ((_force))
        then
          while true
          do
            printf "Updating remote from %s to %s\\n" \
              "$(_highlight "${_existing_url}")"      \
              "$(_highlight "${_url}")"
            read -r -p "Do you want to proceed? [y/N] " __yn
            case ${__yn} in
              [Yy]*)
                break
                ;;
              *)
                printf "Exiting...\\n"
                exit 0
                ;;
            esac
          done
        fi

        git remote set-url origin "${_url}"                       &&
          printf "Remote set to %s\\n" "$(_highlight "${_url}")"  &&
          return 0
      else
        git remote add origin "${_url}"                             &&
          printf "Remote set to %s\\n" "$(_highlight "${_url}")"  &&
          return 0
      fi
      ;;
    *)
      if ((_remote_exists))
      then
        git remote get-url origin &&
        return 0
      else
        printf "No remote configured.\\n"
        return 0
      fi
      ;;
  esac
}

# rename ############################################################### rename

desc "rename" <<HEREDOC
Usage:
  ${_ME} rename (<id> | <filename> | <path> | <title>) [-f | --force]
            (<name> | --reset | --to-bookmark | --to-note)

Options:
  -f, --force     Skip the confirmation prompt.
  --reset         Reset the filename to the last modified timestamp.
  --to-bookmark   Preserve the existing filename and replace the extension
                  with '.bookmark.md' to convert the note to a bookmark.
  --to-note       Preserve the existing filename and replace the bookmark's
                  '.bookmark.md' extension with '.md' to convert the bookmark
                  to a Markdown note.

Description:
  Rename a note. Set the filename to <name> for the specified note file. When
  file extension is omitted, the existing extension will be used.

Examples:
  # Rename 'example.md' to 'example.org'
  ${_ME} rename example.md example.org

  # Rename note 3 (example.md) to "New Name.md"
  ${_ME} rename 3 "New Name"

  # Rename 'example.bookmark.md' to 'New Name.bookmark.md'
  ${_ME} rename example.bookmark.md "New Name"

  # Rename note 3 ('example.md') to bookmark named 'example.bookmark.md'
  ${_ME} rename 3 --to-bookmark
HEREDOC
_rename() {
  local _force=0
  local _reset=0
  local _selection=
  local _target_basename=
  local _target_name=
  local _to_target_type=

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      --force|-f)
        _force=1
        ;;
      --reset)
        _reset=1
        ;;
      --to-bookmark)
        _to_target_type="bookmark"
        ;;
      --to-note)
        _to_target_type="note"
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${__arg}"
        elif [[ -z "${_target_name}" ]]
        then
          _target_name="${__arg}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_selection}" ]]
  then
    _exit_1 _help "rename"
  fi

  local _source_basename
  _source_basename="$(_get_selection_basename "${_selection}")"
  _set_selection_notebook "${_selection}"
  local _source_path="${_NOTEBOOK_PATH}/${_source_basename}"

  if [[ -z "${_source_basename}" ]]
  then
    _exit_1 _help "rename"
  fi
  _debug printf "_rename() \${_source_basename}: '%s'\\n" \
    "${_source_basename}"

  if ((_reset))
  then
    local _file_type="${NB_DEFAULT_EXTENSION}"

    # Assign filename with unicode timestamp.
    _target_basename="$(date -r "${_source_path}" -u "+%Y%m%d%H%M%S").${_file_type}"
  elif [[ -n "${_target_name:-}"    ]] ||
       [[ -n "${_to_target_type:-}" ]]
  then
    local _source_file_name="${_source_basename%%.*}"
    local _source_file_type="${_source_basename#*.}"
    if [[ -z "${_source_file_type:-}"                     ]] ||
       [[ "${_source_file_type}" == "${_source_basename}" ]]
    then
      _source_file_type=
    fi

    local _target_file_name="${_target_name%%.*}"
    local _target_file_type="${_target_name#*.}"
    if [[ -z "${_target_file_type:-}"                 ]] ||
       [[ "${_target_file_type}" == "${_target_name}" ]]
    then # no file extension specified in _target_name
      if [[ -n "${_source_file_type}" ]]
      then
        _target_file_type="${_source_file_type}"
      else
        _target_file_type=
      fi
    fi

    if [[ -n "${_to_target_type:-}" ]]
    then
      if [[ "${_to_target_type}" == "bookmark" ]]
      then
        _target_file_type="bookmark.md"
      elif [[ "${_to_target_type}" == "note" ]]
      then
        _target_file_type="md"
      else
        _exit_1 _help "rename"
      fi
    fi

    if [[ -z "${_target_file_name:-}" ]]
    then
      _target_file_name="${_source_file_name}"
    fi

    if [[ -n "${_target_file_type:-}" ]]
    then
      _target_basename="${_target_file_name}.${_target_file_type}"
    else
      _target_basename="${_target_name}"
    fi

    if [[ -e "${_NOTEBOOK_PATH}/${_target_basename}" ]]
    then
      _exit_1 printf "File already exists: %s\\n" \
        "$(_highlight "${_target_basename}")"
    fi
  else
    _exit_1 _help "rename"
  fi

  if ! ((_force))
  then
    printf "Renaming %s to %s\\n"           \
      "$(_highlight "${_source_basename}")" \
      "$(_highlight "${_target_basename}")"
    while true
    do
      read -r -p "Are you sure you want to proceed? [y/N] " __yn
      case ${__yn} in
        [Yy]*)
          break
          ;;
        *)
          printf "Exiting...\\n"
          exit 0
          ;;
      esac
    done
  fi

  mv "${_source_path}" "${_NOTEBOOK_PATH}/${_target_basename}"  &&
    _index update "${_source_basename}" "${_target_basename}"   &&
    _git_checkpoint \
      "[nb] Rename: ${_source_basename} to ${_target_basename}"
  printf "%s renamed to %s\\n"            \
    "$(_highlight "${_source_basename}")" \
    "$(_highlight "${_target_basename}")"
}

# search ############################################################### search

desc "search" <<HEREDOC
Usage:
  ${_ME} search <query> [-a | --all] [-t <type> | --type <type> | --<type>]
                    [-l | --list] [--path]

Options:
  -a, --all                     Search all active notebooks.
  -l, --list                    Print the id, filename, and title listing for
                                each matching file, without the excerpt.
  --path                        Print the full path for each matching file.
  -t, --type <type>, --<type>   List items of <type>. <type> can be a file
                                extension or one of the following types:
                                note, bookmark, document, archive, image,
                                video, audio, folder
Description:
  Search notes. Uses the first available tool in the following list:
    1. \`rg\`    https://github.com/BurntSushi/ripgrep
    2. \`ag\`    https://github.com/ggreer/the_silver_searcher
    3. \`ack\`   http://beyondgrep.com/
    4. \`grep\`  https://en.wikipedia.org/wiki/Grep

Examples:
  # search current notebook for 'example query'
  ${_ME} search 'example query'

  # search all notebooks for 'example query'
  ${_ME} search 'example query' --all

  # search notes for 'Example' OR 'Sample'
  ${_ME} search 'Example|Sample'

  # search for bookmarks containing the hashtag '#example'
  ${_ME} search '#example' --type bookmark

  # search with a regular expression for notes containing phone numbers
  ${_ME} search '^(1?(-?\\d{3})-?)?(\\d{3})(-?\\d{4})$'

Shortcut Alias: \`q\`
HEREDOC
_search() {
  local _all=0
  local _last_path=
  local _only_list=0
  local _max_columns="2000"
  local _print_paths=0
  local _query=
  local _type=
  local _use_grep=0

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      -a|--all)
        _all=1
        ;;
      -l|--list)
        _only_list=1
        ;;
      --path|--paths)
        _print_paths=1
        ;;
      --type)
        _type="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --use-grep)
        # The `--use-grep` option bypasses other search tools. Intended to be
        # used primarily for testing.
        _use_grep=1
        ;;
      *)
        if [[ "${__arg:-}" =~ ^-- ]]
        then
          _type="${__arg:2}"
        elif [[ -z "${_query}" ]]
        then
          _query="${__arg}"
        fi
        ;;
    esac

    shift
  done

  if [[ -z "${_query:-}" ]]
  then
    _exit_1 _help "search"
  else
    local _target_notebook_paths=()

    if ((_all))
    then
      _target_notebook_paths=($(_notebooks --paths --unarchived))
    else
      _target_notebook_paths=($(_notebooks current --path))
    fi

    _debug printf \
      "_search() \${_target_notebook_paths[*]}: '%s'\\n" \
      "${_target_notebook_paths[*]}"

    for __notebook_path in "${_target_notebook_paths[@]:-}"
    do
      if _command_exists "rg" && ! ((_use_grep))
      then
        rg \
          --hidden        \
          --iglob '!.git' \
          --ignore-case   \
          --no-heading    \
          --color always  \
          --line-number   \
          --max-columns "${_max_columns}" --max-columns-preview \
          "${_query}" "${__notebook_path}" \
            || return 0 # Don't fail out within a single scope.
      elif _command_exists "ag" && ! ((_use_grep))
      then
        # TODO: `ag` outputs unordered results, which breaks tests/search.bats.
        # Determine how to test without relying on ordering.
        ag \
          --hidden      \
          --ignore-case \
          --noheading   \
          --color       \
          --color-line-number '32' \
          --color-match '1;35' \
          "${_query}" "${__notebook_path}" \
            || return 0 # Don't fail out within a single scope.
      elif _command_exists "ack" && ! ((_use_grep))
      then # ack is available.
        ack "${_query}" "${__notebook_path}" \
          --ignore-case \
          --noheading   \
          --color-lineno='bold green'   \
          --color-match='black on_blue' \
            || return 0 # Don't fail out within a single scope.
      else # fall back to POSIX grep.
        # Add /dev/null so file path is printed even if there is only one
        # matching file. Reference: http://stackoverflow.com/a/15432718
        set +f
        find . -type f -not -path '*/\.git*' \
          | grep \
              --ignore-case   \
              --color=always  \
              --text          \
              -n "${_query}"  \
              "${__notebook_path}"/* \
              "${__notebook_path}"/.index /dev/null \
                || return 0 # Don't fail out within a single scope.
        set -f
      fi | while read -r _line
      do
        local _content_line_with_hit=
        local _file_info=
        local _file_info_color=
        local _filename=
        local _filename_color=
        local _filename_hit=0
        local _id=
        # Define `_id_filename` with and without color to have a version
        # without the additional length from `tput` calls.
        local _id_filename=
        local _id_filename_color=
        local _path=
        local _skip=0
        local _title=

        # Use `sed` to remove color and 'matches' suffix from output.
        # http://unix.stackexchange.com/a/140255
        _path="$(
          printf "%s\\n" "${_line}"                         \
            | cut -d: -f 1                                  \
            | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g" \
            | sed -e 's/ matches//g'
        )"

        if [[ "${_last_path}" != "${_path}" ]]
        then
          if [[ -n "${_type:-}" ]]
          then
            if [[ "${_path}" =~ ${_type}$ ]]
            then
              _skip=0
            elif {
                [[ "${_type}" =~ ^bookmark$|^bookmarks$ ]] &&
                _file_is_bookmark "${_path}"
              } || {
                [[ "${_type}" =~ ^note$|^notes$|^text$ ]] &&
                _file_is_text "${_path}"
              } || {
                [[ "${_type}" =~ ^folder$|^folders$ ]] &&
                [[ "$(dirname "${_path}")" != "${__notebook_path}" ]]
              } || {
                [[ "${_type}" =~ ^archive$ ]] &&
                _file_is_archive "${_path}"
              } || {
                [[ "${_type}" =~ ^audio$|^music$ ]] &&
                _file_is_audio "${_path}"
              } || {
                [[ "${_type}" =~ ^document$|^documents$|^doc$|^docs$ ]] &&
                _file_is_document "${_path}"
              } || {
                [[ "${_type}" =~ ^encrypted$ ]] &&
                _file_is_encrypted "${_path}"
              } || {
                [[ "${_type}" =~ ^image$|^images$|^picture$|^pictures$ ]] &&
                _file_is_image "${_path}"
              }  || {
                [[ "${_type}" =~ ^video$|^videos$ ]] &&
                _file_is_video "${_path}"
              }
            then
              _skip=0
            else
              _skip=1
            fi
          fi
        fi

        if [[ -z "${_line}" ]]
        then
          # Print nothing, skipping the blank line in `ag` output with
          # multiple matches.
          :
        elif ((_print_paths))
        then
          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf "%s\\n" "${_path}"
          fi
        else
          if ((_skip))
          then
            continue
          fi

          _filename="$(basename "${_path}")"
          _filename_color="${_filename}"

          # Use '.index' to match filenames.
          if [[ -n "${_filename:-}" ]] && [[ "${_filename:-}" == ".index" ]]
          then
            _filename_hit=1
            _filename_color="$(printf "%s\\n" "${_line}" | cut -d: -f 3-)"
            _filename="$(
              printf "%s\\n" "${_filename_color}" \
                | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g"
            )"
          fi

          local _filename_for_id="${_filename}"

          if [[ "${__notebook_path}/${_filename}" != "${_path}" ]] &&
             [[ ! "${_path:-}" =~ \.index$                      ]]
          then
            local _parent_dirname=
            _parent_dirname="$(dirname "${_path}")"

            _filename_for_id="$(basename "${_parent_dirname}")"

            local _relative_parent_dirname=
            _relative_parent_dirname="${_parent_dirname#${__notebook_path}/}"

            _filename="${_relative_parent_dirname}/${_filename}"
            _filename_color="${_relative_parent_dirname}/${_filename_color}"
          fi

          _id="$(
            _NOTEBOOK_PATH="${__notebook_path}" \
              _index get_id "${_filename_for_id}"
          )"
          _title="$(_get_title "${_path}")"

          if [[ -n "${_title}" ]]
          then
            _file_info="${_filename} '${_title}'"
            _file_info_color="${_filename_color} '${_title}'"
          else
            _file_info="${_filename}"
            _file_info_color="${_filename_color}"
          fi

          if ((_all)) || ((_SCOPED))
          then
            local _notebook_name=
            _notebook_name="$(_get_notebook_identifier "${__notebook_path}")"

            _id_filename="[${_notebook_name}:${_id}] ${_file_info}"
            _id_filename_color="$(_id_brackets_color "${_notebook_name}:${_id}") ${_file_info_color}"
          else
            _id_filename="[${_id}] ${_file_info}"
            _id_filename_color="$(_id_brackets_color "${_id}") ${_file_info_color}"
          fi

          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf '\033[?7l'
            printf "%s" "${_id_filename_color}"
            printf '\033[?7h'
            printf "\\n"
          fi

          if ((_only_list))
          then
            [[ -n "${_path}" ]] && _last_path="${_path}"
            continue
          fi

          if [[ "${_last_path}" != "${_path}" ]]
          then # match is in a different file than the last match
            printf '\033[?7l'
            _print_line "${_id_filename}"
            printf '\033[?7h'
          fi

          if ((_filename_hit))
          then
            _content_line_with_hit="Filename Match: $(
              printf "%s\\n" "${_line}" | cut -d: -f 3-
            )"
          else
            _content_line_with_hit="$(
              printf "%s\\n" "${_line}" | cut -d: -f 2-
            )"
          fi

          # Truncate long lines.
          local _line_length=
          _line_length="$(
            printf "%s\\n" "${_content_line_with_hit}" | awk '{print length}'
          )"
          local _line_length_diff
          _line_length_diff=$((_line_length-_max_columns-100))

          if [[ "${_line_length_diff}" -gt 0 ]]
          then
            _content_line_with_hit="$(\
              printf "%s\\n" "${_content_line_with_hit}" \
                | awk '{ print substr($0, 1, 2000) }'
            )"
            _content_line_with_hit+="$(
              _highlight "... [${_line_length_diff} characters omitted]"
            )"
          fi

          printf "%s\\n\\n" "${_content_line_with_hit}"
        fi

        [[ -n "${_path}" ]] && _last_path="${_path}"
      done
    done | if read -r _line
    then # output is present
      # Print the test line then `cat` the rest.
      printf "%s\\n" "${_line}"
      cat
      return 0
    else
      return 1
    fi
  fi
}
_alias_subcommand "search" "q"

# settings ########################################################### settings

desc "settings" <<HEREDOC
Usage:
  ${_ME} settings [<number> | <name>]
  ${_ME} settings colors [<number>]
  ${_ME} settings edit
  ${_ME} settings get   (<number> | <name>)
  ${_ME} settings list  [--long]
  ${_ME} settings set   (<number> | <name>) <value>
  ${_ME} settings show  (<number> | <name>)
  ${_ME} settings unset (<number> | <name>)

Subcommands:
  (default)  Open the settings prompt.
  colors     Print a table of available colors and their xterm color numbers.
             When <number> is provided, print the number in its color.
  edit       Open the \`${_ME}\` configuration file in \`\$EDITOR\`.
  get        Print the value of a setting.
  list       List information about available settings.
  set        Assign <value> to a setting.
  show       Print the help information and current value of a setting.
  unset      Unset a setting, returning it to the default value.

Description:
  Configure \`${_ME}\`. Use \`${_ME} settings set\` to customize a setting and
  \`${_ME} settings unset\` to restore the default for a setting.

Examples:
  ${_ME} settings
  ${_ME} settings set 5 'org'
  ${_ME} settings set color_primary 105
  ${_ME} settings unset color_primary
  ${_ME} settings colors
  ${_ME} settings colors 105
HEREDOC
_settings() {
  # Usage: _nb_settings_colors
  _nb_settings_colors() {
    _nb_settings_colors_print(){
        for __color_number
        do
          printf '\e[38;5;%dm %3d ' \
            "${__color_number}"     \
            "${__color_number}"
        done
        printf '\e[0m \n'
        # printf '\e[0m '
    }

    if [[ -n "${1:-}" ]]
    then
      _nb_settings_colors_print "${1:-}"
    else
      _nb_settings_colors_print {0..15}

      for ((_i=0;_i<6;_i++))
      do
        _nb_settings_colors_print $(seq $((_i*36+16)) $((_i*36+51)))
      done

      _nb_settings_colors_print {232..255}

      printf "\\n"
    fi
  }

  # Usage: _nb_settings_get_value (<number> | <name>)
  _nb_settings_get_value() {
    local _setting_name=
    _setting_name="$(_nb_settings_identify "${1:-}")" &&
      _env | grep "${_setting_name}" | cut -d= -f2
  }

  # Usage: _nb_settings_identify [--id] (<number> | <name>)
  _nb_settings_identify() {
    local _get_id=0
    local _id_or_name=

    if [[ -z "${1:-}" ]]
    then
      return 1
    elif [[ "${1}" == "--id" ]]
    then
      _get_id=1
      [[ -z "${2:-}" ]] && return 1
      _id_or_name="${2:-}"
    else
      _id_or_name="${1}"
    fi

    case "${_id_or_name}" in
      1|auto_sync|NB_AUTO_SYNC|nb_auto_sync|AUTO_SYNC)
        ((_get_id)) && printf "1" || printf "NB_AUTO_SYNC"
        return 0
        ;;
      2|color_primary|NB_COLOR_PRIMARY|nb_color_primary|COLOR_PRIMARY|primary_color)
        ((_get_id)) && printf "2" || printf "NB_COLOR_PRIMARY"
        return 0
        ;;
      3|color_secondary|NB_COLOR_SECONDARY|nb_color_secondary|COLOR_SECONDARY|secondary_color)
        ((_get_id)) && printf "3" || printf "NB_COLOR_SECONDARY"
        return 0
        ;;
      4|color_theme|NB_COLOR_THEME|nb_color_theme|COLOR_THEME|theme|color_scheme)
        ((_get_id)) && printf "4" || printf "NB_COLOR_THEME"
        return 0
        ;;
      5|default_extension|NB_DEFAULT_EXTENSION|nb_default_extension|DEFAULT_EXTENSION)
        ((_get_id)) && printf "5" || printf "NB_DEFAULT_EXTENSION"
        return 0
        ;;
      6|editor|EDITOR)
        ((_get_id)) && printf "6" || printf "EDITOR"
        return 0
        ;;
      7|encryption_tool|NB_ENCRYPTION_TOOL|nb_encryption_tool|ENCRYPTION_TOOL)
        ((_get_id)) && printf "7" || printf "NB_ENCRYPTION_TOOL"
        return 0
        ;;
      8|footer|NB_FOOTER|nb_footer|FOOTER)
        ((_get_id)) && printf "8" || printf "NB_FOOTER"
        return 0
        ;;
      9|nb_dir|NB_DIR)
        ((_get_id)) && printf "9" || printf "NB_DIR"
        return 0
        ;;
      *)
        _return_1 \
          printf "Setting not found: %s\\n" \
          "$(_highlight "${_id_or_name}")"
        ;;
    esac
  }

  # Usage: _nb_settings_prompt [<id> | <name>]
  _nb_settings_prompt() {
    local _setting_name="${1:-}"

    if [[ -n "${_setting_name}" ]]
    then
      _setting_name="$(_nb_settings_identify "${_setting_name}")"
    else
      cat <<HEREDOC
$(_highlight "${_ME}") Settings
$(_highlight_secondary "-----------")
$(_settings list)

Enter the number or name of the setting to change, or $(_highlight 'q') to quit.
HEREDOC

      while true
      do
        read -r -p "$(_highlight "Number or Name: ")" __setting
        if [[ -n "${__setting}" ]]
        then
          case "${__setting}" in
            q|quit|exit)
              printf "Exiting...\\n"
              return 0
              ;;
            *)
              _setting_name="$(
                _nb_settings_identify "${__setting}"
              )" && break
              ;;
          esac
        fi
      done
    fi

    if [[ "${_setting_name}" == "NB_COLOR_PRIMARY"    ]] ||
       [[ "${_setting_name}" == "NB_COLOR_SECONDARY"  ]]
    then
      printf "%s\\n\\n" "$(_nb_settings_colors)"
    fi

    _settings show "${_setting_name}"

    local _hi_unset= && _hi_unset="$(_highlight 'unset')"
    local _hi_q=     && _hi_q="$(_highlight 'q')"

    cat <<HEREDOC

Enter a new value, ${_hi_unset} to set to the default value, or ${_hi_q} to quit.
HEREDOC

    while true
    do
      read -r -p "$(_highlight "Value: ")" __value
      if [[ -n "${__value}" ]]
      then
        case "${__value}" in
          q|quit|exit)
            printf "Exiting...\\n"
            return 0
            ;;
          reset|unset)
            _nb_settings_unset "${_setting_name}" || continue
            break
            ;;
          *)
            _nb_settings_set "${_setting_name}" "${__value}" || continue
            break
            ;;
        esac
      fi
    done
  }

  # Usage: _nb_settings_set (<number> | <name>) <value>
  _nb_settings_set() {
    local _attribution=
    _attribution="# Set by \`${_ME}\` â€¢ $(date)"
    local _entry=
    local _setting_name=
    local _stripped=
    local _value=

    _setting_name="$(_nb_settings_identify "${1:-}")"  &&
      _nb_settings_validate_value "${_setting_name}" "${2:-}" &&
      {
        _value="${2:-}"
        if [[ "${_value}" =~ ^~ ]]
        then
          # shellcheck disable=SC2016
          _value="$(printf "%s\\n" "${_value}" | sed "s|~|${HOME}|g")"
        fi
      } &&
      if [[ "${_setting_name}" == "EDITOR" ]]
      then
        _entry="export ${_setting_name}=\"${_value}\" ${_attribution}"
      else
        _entry="export ${_setting_name}=\"\${${_setting_name}:-${_value}}\" ${_attribution}"
      fi &&
      _nb_settings_unset "${_setting_name}" > /dev/null 2>&1 &&
      printf "\\n%s\\n" "${_entry}" >> "${NBRC_PATH}"        &&
      if [[ "${_setting_name}" == "NB_COLOR_PRIMARY"      ]] ||
         [[ "${_setting_name}" == "NB_COLOR_SECONDARY"    ]]
      then
        _setting_name="$(tput setaf "${_value}")${_setting_name}${_TPUT_SGR0}"
               _value="$(tput setaf "${_value}")${_value}${_TPUT_SGR0}"
      elif [[ "${_setting_name}" == "NB_COLOR_THEME" ]]
      then
        local _new_color=
        _new_color="$(NB_COLOR_THEME='' "${_MY_PATH}" settings get NB_COLOR_PRIMARY)"
        _setting_name="$(tput setaf "${_new_color}")${_setting_name}${_TPUT_SGR0}"
               _value="$(tput setaf "${_new_color}")${_value}${_TPUT_SGR0}"
      else
        _setting_name="$(_highlight "${_setting_name}")"  \
               _value="$(_highlight "${_value}")"
      fi &&
      printf "%s set to %s\\n"  \
        "${_setting_name}"      \
        "${_value}"
  }

  # Usage: _nb_settings_unset (<number> | <name>)
  _nb_settings_unset() {
    local _setting_name=
    local _default_value=

    _setting_name="$(_nb_settings_identify "${1:-}")" &&
      "${_SED_I_COMMAND[@]}" \
        -e "s/^export ${_setting_name}.*Added by.*$//g" \
        -e "s/^export ${_setting_name}.*Set by.*$//g" \
        "${NBRC_PATH}" &&
        {
          _stripped=$(<"${NBRC_PATH}")
          printf "%s\\n" "${_stripped}" > "${NBRC_PATH}"
        } && {
          _default_value="$(
            eval "${_setting_name}='' \"${_MY_PATH}\" settings get ${_setting_name}"
          )"

          if [[ "${_setting_name}" == "NB_COLOR_SECONDARY" ]]
          then
            _setting_name="$(_highlight "${_setting_name}")"
            _default_value="$(tput setaf "${_default_value}")${_default_value}${_TPUT_SGR0}"
          elif [[ "${_setting_name}" == "NB_COLOR_PRIMARY" ]]
          then
            _setting_name="$(tput setaf "${_default_value}")${_setting_name}${_TPUT_SGR0}"
            _default_value="$(tput setaf "${_default_value}")${_default_value}${_TPUT_SGR0}"
          elif [[ "${_setting_name}" == "NB_COLOR_THEME" ]]
          then
            _new_hi_color="$(
              NB_COLOR_THEME="nb" NB_COLOR_PRIMARY='' \
                "${_MY_PATH}" settings get NB_COLOR_PRIMARY
            )"

            _setting_name="$(tput setaf "${_new_hi_color}")${_setting_name}${_TPUT_SGR0}"
            _default_value="$(tput setaf "${_new_hi_color}")${_default_value}${_TPUT_SGR0}"
          else
            _setting_name="$(_highlight "${_setting_name}")"
            _default_value="$(_highlight "${_default_value}")"
          fi
        } &&
        printf "%s restored to the default: %s\\n"  \
          "${_setting_name}"                        \
          "${_default_value}"
  }

  # Usage: _nb_settings_validate_value (<number> | <name>) <value>
  _nb_settings_validate_value() {
    if [[ "${1:-}" == 'EDITOR'                ]] ||
       [[ "${1:-}" == 'NB_DEFAULT_EXTENSION'  ]]
    then
      if [[ -n "${2:-}" ]]
      then
        return 0
      else
        _return_1 printf "%s requires a value.\\n" "${1:-}"
      fi
    elif [[ "${1:-}" == 'NB_AUTO_SYNC'  ]] ||
         [[ "${1:-}" == 'NB_FOOTER'     ]]
    then
      if [[ "${2:-}" =~ ^0|1$ ]]
      then
        return 0
      else
        _return_1 printf "%s must be either '0' or '1'.\\n" "${1}"
      fi
    elif [[ "${1:-}" == 'NB_DIR' ]]
    then
      if [[ -z "${2:-}"   ]] ||
         [[ "${2}" == "/" ]] ||
         {
          [[ -e "${2}"   ]] &&
          [[ ! -w "${2}" ]]
         }
      then
        _return_1 printf "'%s' is not a valid location for NB_DIR.\\n" "${2:-}"
      fi
    elif [[ "${1:-}" == 'NB_ENCRYPTION_TOOL' ]]
    then
      if [[ "${2:-}" =~ ^openssl|gpg$ ]]
      then
        return 0
      else
        _return_1 \
          printf "NB_ENCRYPTION_TOOL must be either 'openssl' or 'gpg'.\\n"
      fi
    elif [[ "${1:-}" == 'NB_COLOR_PRIMARY'    ]] ||
         [[ "${1:-}" == 'NB_COLOR_SECONDARY'  ]]
    then
      if [[ "${2:-}" =~ ^[0-9] ]]
      then
        return 0
      else
        _return_1 printf "%s must be a number.\\n" "${1}"
      fi
    elif [[ "${1:-}" == 'NB_COLOR_THEME' ]]
    then
      if _contains "${2:-}" "${_NB_COLOR_THEMES[@]}"
      then
        return 0
      else
        _return_1 printf "%s must be one of the available themes.\\n" "${1}"
      fi
    else
      return 0
    fi
  }

  local _settings_list_items=()
  local _settings_help_items=()

  _settings_list_items+=("$(_id_brackets_color '1') auto_sync")
  _settings_help_items+=("\
    $(_highlight_secondary "---------")
    By default, operations that trigger a git commit like \`add\`, \`edit\`,
    and \`delete\` will sync notebook changes to the remote repository, if
    one is set. To disable this behavior, set this to '0'.

      â€¢ Default Value: '1'")

  _settings_list_items+=("$(_id_brackets_color '2') color_primary")
  _settings_help_items+=("\
    $(_highlight_secondary "-------------")
    The primary color used to highlight identifiers and messages. Often this
    can be set to an xterm color number between 0 and 255. Some terminals
    support many more colors. To view a table of 256 common colors and numbers,
    run: \`${_ME} settings colors\`
    To view a color for a number, run: \`${_ME} settings colors <number>\`

      â€¢Â Default Value: '68' (blue) for 256 color terminals,
                       '4'  (blue) for  8  color terminals.")

  _settings_list_items+=("$(_id_brackets_color '3') color_secondary")
  _settings_help_items+=("\
    $(_highlight_secondary "---------------")
    The color used for lines and footer elements. Like color_primary, this
    can often be set to an xterm color number between 0 and 255. view a
    table of 256 common colors and numbers, run: \`${_ME} settings colors\`
    To view a color for a number, run: \`${_ME} settings colors <number>\`

      â€¢Â Default Value: '8'")

  _settings_list_items+=("$(_id_brackets_color '4') color_theme")
  _settings_help_items+=("\
    $(_highlight_secondary "-----------")
    The color theme. \`${_ME}\` has several built-in themes and user
    defined themes can be installed in the \$NB_DIR/.themes directory.
    Themes have an .nb-theme or .nb-theme.sh extension and contain a
    single if statment assigning the color environment variables to
    tput ANSI color numbers.

      Example:

        # filename: ~/.nb/.themes/example.nb-theme.sh
        if [[ \"\${NB_COLOR_THEME}\" == \"example\" ]]
        then
          export NB_COLOR_PRIMARY=68
          export NB_COLOR_SECONDARY=8
        fi

    To view a list of available color numbers, run \`nb settings colors\`
    Available themes:

      $(__list_themes() {
          local _line=
          local _line_color=

          for __theme in "${_NB_COLOR_THEMES[@]}"
          do
            local _test_line="${_line} ${__theme}"

            if [[ "${#_test_line}" -gt 65 ]]
            then
              printf "%s\\n" "${_line_color}" | sed 's/,*$//g'
                    _line="       ${__theme},"
              _line_color="       $(_highlight "${__theme}"),"
            else
                    _line="${_line} ${__theme},"
              _line_color="${_line_color} $(_highlight "${__theme}"),"
            fi
          done

          printf "%s\\n" "${_line_color}" | sed 's/,*$//g'
        } && __list_themes)

      â€¢Â Default Value: 'nb'")

  _settings_list_items+=("$(_id_brackets_color '5') default_extension")
  _settings_help_items+=("\
    $(_highlight_secondary "-----------------")
    The default extension to use for notes files. Change to 'org' for Emacs
    Org mode files, 'rst' for reStructuredText, 'txt' for plain text, or
    whatever you prefer.

      â€¢ Default Value: 'md'")

  _settings_list_items+=("$(_id_brackets_color '6') editor")
  _settings_help_items+=("\
    $(_highlight_secondary "------")
    The command line text editor to use with \`${_ME}\`.

      â€¢Â Example Values: 'vim', 'emacs', 'micro', 'code', 'subl' 'macdown'")

  _settings_list_items+=("$(_id_brackets_color '7') encryption_tool")
  _settings_help_items+=("\
    $(_highlight_secondary "---------------")
    The tool used for encrypting notes.

      â€¢ Supported Values: 'openssl', 'gpg'
      â€¢Â Default Value:    'openssl'")

  _settings_list_items+=("$(_id_brackets_color '8') footer")
  _settings_help_items+=("\
    $(_highlight_secondary "------")
    By default, \`${_ME} ls\` includes a footer with example commands for
    easy reference. To hide this footer, set this to '0'.

      â€¢ Default Value: '1'")

  _settings_list_items+=("$(_id_brackets_color '9') nb_dir")
  _settings_help_items+=("\
    $(_highlight_secondary "------")
    The location of the directory that contains the notebooks. To sync with
    Dropbox, you could create a folder at ~/Dropbox/Notes and use:
    \`${_ME} settings set NB_DIR ~/Dropbox/Notes\`

      â€¢ Default Value: '~/.nb'")

  while ((${#}))
  do
    local __arg="${1:-}"

    case "${__arg}" in
      color|colors)
        _nb_settings_colors "${2:-}"
        return 0
        ;;
      edit)
        _edit_file "${NBRC_PATH}" --no-wait
        return 0
        ;;
      get)
        if [[ -z "${2:-}" ]]
        then
          _exit_1 _help settings
        fi

        _nb_settings_get_value "${2:-}"
        return 0
        ;;
      list)
        if [[ "${2:-}" == "--long" ]]
        then
          local _counter=0

          for __setting in "${_settings_list_items[@]}"
          do
            ((_counter)) && printf "\\n"
            _counter="$((_counter+1))"

            _settings show "${_counter}"
          done
        else
          printf "%s\\n" "${_settings_list_items[@]}"
        fi

        return 0
        ;;
      set)
        if [[ -z "${2:-}" ]] || [[ -z "${3:-}" ]]
        then
          _exit_1 _help "settings"
        fi

        _nb_settings_set "${2:-}" "${3:-}"
        return 0
        ;;
      show|help|about|info|more)
        if [[ -z "${2:-}" ]]
        then
          _exit_1 _help "settings"
        fi

        local _setting_id=
        _setting_id="$(_nb_settings_identify --id "${2:-}")"

        local _setting_name=
        _setting_name="$(_nb_settings_identify "${2:-}")"

        local _index=
        _index="$((_setting_id-1))"

        printf "%s\\n%s\\n"                     \
          "${_settings_list_items[${_index}]}"  \
          "${_settings_help_items[${_index}]}"

        printf "\\n%s is currently set to %s\\n"  \
          "$(_highlight "${_setting_name}")"      \
          "$(_highlight "$(_nb_settings_get_value "${_setting_name}")")"
        return 0
        ;;
      reset|unset)
        if [[ -z "${2:-}" ]]
        then
          _exit_1 _help "settings"
        fi

        _nb_settings_unset "${2:-}"
        return 0
        ;;
      *)
        local _setting_name=
        if [[ -n "${1:-}" ]]
        then
          _setting_name="$(_nb_settings_identify "${1}")"
        fi

        if [[ -n "${_setting_name:-}" ]]
        then
          if [[ -n "${2:-}" ]]
          then
            _nb_settings_set "${_setting_name}" "${2}"
          else
            _nb_settings_prompt "${_setting_name}"
          fi
        else
          _nb_settings_prompt
        fi

        return 0
        ;;
    esac

    shift
  done
}
_alias_subcommand "settings" "config"

# shell  ################################################################ shell

desc "shell" <<HEREDOC
Usage:
  ${_ME} shell [<subcommand> [<options>...] | --clear-history]

Optons:
  --clear-history  Clear the \`${_ME}\` shell history.

Description:
  Start the \`${_ME}\` interactive shell. Type 'exit' to exit.

  \`${_ME} shell\` recognizes all \`${_ME}\` subcommands and options, providing
  a streamlined, distraction-free approach for working with \`${_ME}\`.

  When <subcommand> is present, the command will run as the shell is opened.

Example:
  $ ${_ME} shell
  ${_ME}> ls 3
  [3] Example

  ${_ME}> edit 3 --content "New content."
  Updated [3] Example

  ${_ME}> notebook
  home

  ${_ME}> exit
  $
HEREDOC
_shell() {
  HISTFILE="${HOME}/.${_ME}_history"
  set -o history

  local _initial_command=
  local _prompt=
  _prompt="$(_highlight "${_ME}")$(_highlight_secondary ">") "

  for __arg in "${@:-}"
  do
    case "${__arg}" in
      --clear-history)
        if [[ -e "${HISTFILE}" ]]
        then
          rm "${HISTFILE}"
          printf "History cleared.\\n"
          return 0
        fi
        ;;
      *)
        if [[ -n "${__arg}" ]]
        then
          _initial_command+=" ${__arg}"
        fi
        ;;
    esac
  done

  _debug printf "_shell() \${_initial_command:-}: '%s'\\n" \
    "${_initial_command:-}"

  printf "%s" "${_TPUT_COLOR_PRIMARY}"
  cat <<HEREDOC
__          _
\ \   _ __ | |__
 \ \ | '_ \| '_ \\
 / / | | | | |_) |
/_/  |_| |_|_.__/
$(_highlight_secondary "------------------")
$(_highlight "${_ME} shell") started. Enter $(_highlight "ls") to list notes and notebooks.
Enter $(_highlight "help") for a list of subcommands. Enter $(_highlight "exit") to exit.
HEREDOC

  if [[ -n "${_initial_command:-}" ]]
  then
    eval "\"${_MY_PATH}\" ${_initial_command}"
  fi

  while true
  do
    while IFS='' read -r -e -d $'\n' -p "${_prompt}" __input
    do
      history -s "${__input}"
      if [[ "${__input}" =~ ^exit|quit$ ]]
      then
        return 0
      else
        # Strip leading 'n', 'nb', or 'notes'.
        local _normalized_input=
        _normalized_input="$(
          printf "%s\\n" "${__input}" \
            | sed -e 's/^n$//'        \
            | sed -e 's/^n //'        \
            | sed -e 's/^nb$//'       \
            | sed -e 's/^nb //'       \
            | sed -e 's/^notes$//'    \
            | sed -e 's/^notes //'
        )"

        if [[ "${_normalized_input}" =~ ^help   ]] ||
           [[ "${_normalized_input}" =~ ^help\  ]]
        then
          # Strip 'nb' command name from help output.
          local _output=
          local _processed_output=

          _output="$(eval "\"${_MY_PATH}\" ${_normalized_input}" || :)"
          _processed_output="$(
            printf "%s\\n" "${_output}" \
              | sed -e "s/^  nb /  /"
          )"
          printf "%s\\n" "${_processed_output}"
        elif [[ "${_normalized_input}" =~ ^echo\ .*   ]] ||
             [[ "${_normalized_input}" =~ ^printf\ .* ]]
        then
          eval "${_normalized_input}"
        # elif [[ "${_normalized_input}" =~ ^vim\ .*   ]]
        elif _command_name="$(
          printf "%s\\n" "${_normalized_input}" \
            | grep --only-matching --color=never \
                -e '^code'    \
                -e '^emacs'   \
                -e '^gvim'    \
                -e '^macdown' \
                -e '^mate'    \
                -e '^mvim'    \
                -e '^nano'    \
                -e '^nvim'    \
                -e '^subl'    \
                -e '^vim'
        )"
        then
          _normalized_input="$(
            printf "%s\\n" "${_normalized_input}" \
              | sed -e "s/^${_command_name} //"
          )"

          eval "\"${_MY_PATH}\" edit --editor \"${_command_name}\" ${_normalized_input}"
        else
          eval "\"${_MY_PATH}\" ${_normalized_input}" || :
        fi
      fi
    done
  done
}

# show ################################################################### show

desc "show" <<HEREDOC
Usage:
  ${_ME} show (<id> | <filename> | <path> | <title>) [--dump [--no-color]]
          [--filename | --id | --path | --render | --title]

Options:
  --dump      Print to standard output.
  --filename  Print the filename of the item.
  --id        Print the id number of the item.
  --path      Print the full path of the item.
  --no-color  When used with \`--dump\`, print the note without highlighting.
  --render    Use \`pandoc\` [1] to render the file to HTML and display with
              \`lynx\` [2] (if available) or \`w3m\` [3]. If \`pandoc\` is not
              available, \`--render\` is ignored.
  --title     Print the title of the note.

Description:
  Show a note. Notes in text file formats can be rendered or dumped to
  standard output. Non-text files will be opened in your system's preferred
  app or program for that file type.

  By default, the note will be opened using \`less\` or the program configured
  in the \`\$PAGER\` environment variable. Use the following keys to navigate
  in \`less\` (see \`man less\` for more information):

    Key               Function
    ---               --------
    mouse scroll      Scroll up / down
    arrow up / down   Scroll one line up / down
    f                 Move forward one page
    b                 Move back one page
    /<query>          Search for <query>
    n                 Jump to next <query> match
    q                 Quit

  To skip the pager and print to standard output, use the \`--dump\` option.

  If Pygments [4] is installed, notes are printed with syntax highlighting.

    1. http://pandoc.org/
    2. https://en.wikipedia.org/wiki/Lynx_(web_browser)
    3. https://en.wikipedia.org/wiki/W3m
    4. http://pygments.org/

Examples:
  ${_ME} show 1
  ${_ME} show example.md --render
  ${_ME} show 'A Document Title' --dump --no-color

Shortcut Alias: \`s\`
HEREDOC
_show() {
  _debug printf "_show() \${0:-}: '%s'\\n" "${0:-}"
  _debug printf "_show() \${1:-}: '%s'\\n" "${1:-}"
  _debug printf "_show() \${2:-}: '%s'\\n" "${2:-}"

  local _dump=0
  local _password=
  local _print_filename=0
  local _print_id=0
  local _print_no_color=0
  local _print_path=0
  local _render=0
  local _selection=
  local _print_title=0
  local _tool=

  while ((${#}))
  do
    local __arg="${1:-}"
    local __val="${2:-}"

    case "${__arg}" in
      --dump)
        _dump=1
        ;;
      --path)
        _print_path=1
        ;;
      --filename)
        _print_filename=1
        ;;
      --id|--index)
        _print_id=1
        ;;
      --password)
        _password="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      --raw|--no-color|--nocolor)
        _print_no_color=1
        ;;
      --render|-r)
        _render=1
        ;;
      --title)
        _print_title=1
        ;;
      --tool)
        _tool="$(__option_get_value "${__arg}" "${__val:-}")"
        shift
        ;;
      *)
        if [[ -z "${_selection:-}" ]]
        then
          _selection="${__arg}"
        fi
        ;;
    esac

    shift
  done

  _debug printf "_show() \${_render}: '%s'\\n" "${_render}"
  _debug printf "_show() \${_selection}: '%s'\\n" "${_selection}"

  if [[ -z "${_selection:-}" ]]
  then
    _exit_1 _help "show"
  fi

  local _basename
  _basename="$(_get_selection_basename "${_selection}")"
  _debug printf "_show() \${_basename}: '%s'\\n" "${_basename}"
  if [[ -z "${_basename}" ]]
  then
    _exit_1 printf "Note not found: %s\\n" "$(_highlight "${_selection}")"
  fi
  _set_selection_notebook "${_selection}"

  local _target_path="${_NOTEBOOK_PATH}/${_basename}"

  if [[ -z "${_basename:-}" ]] && [[ ! -e "${_target_path}" ]]
  then
    _exit_1 printf "Selection not found.\\n"
  fi

  if ((_print_path))
  then # `show --path`
    printf "%s/%s\\n" "${_NOTEBOOK_PATH}" "${_basename}"
    return 0
  fi

  if ((_print_filename))
  then
    printf "%s\\n" "${_basename}"
    return 0
  fi

  if ((_print_id))
  then
    local _id
    _id="$(_index get_id "${_basename}")"
    printf "%s\\n" "${_id}"
    return 0
  fi

  if ((_print_title))
  then
    _get_title "${_NOTEBOOK_PATH}/${_basename}"
    return 0
  fi

  if _file_is_encrypted "${_target_path}"
  then
    local _encrypted_path
    _encrypted_path="${_target_path}"

    if [[ -z "${_password}" ]]
    then
      # Request password without displaying it
      printf "Password: "
      read -r -s _password </dev/tty
      printf "\\n" # print newline to stop `read`.
    fi

    if [[ -z "${_password}" ]]
    then
      _exit_1 printf "Password required.\\n"
    fi

    local _decrypted_path
    _decrypted_path="$(_decrypt_file "${_target_path}" "${_password}")"

    _target_path="${_decrypted_path}"
  fi

  if _file_is_archive "${_target_path}" &&
     [[ ! "${_target_path}" =~ docx$ ]]
  then
    _exit_1 printf "\
Can't show archives. Export archive and expand to edit.\\n"
  fi

  if ! _file_is_text "${_target_path}"
  then
    if [[ -d "${_target_path}"      ]] &&
       _command_exists "ranger"        &&
       {
         [[ -z "${_tool}"           ]] ||
         [[ "${_tool}" == "ranger"  ]]
       }
    then
      ranger "${_target_path}"
    elif [[ -d "${_target_path}" ]] &&
         _command_exists "mc"       &&
         {
           [[ -z "${_tool}"      ]] ||
           [[ "${_tool}" == "mc" ]]
         }
    then
      mc "${_target_path}"
    elif [[ -d "${_target_path}"  ]] &&
         _command_exists "exa"       &&
         {
           [[ -z "${_tool}"       ]] ||
           [[ "${_tool}" == "exa" ]]
         }
    then
      exa -lah --git "${_target_path}"
    elif [[ -d "${_target_path}" ]]
    then
      # gnu || bsd
      ls -lah --color=always "${_target_path}" 2>/dev/null ||
        ls -lah -G "${_target_path}"
    elif _command_exists "imgcat"                 &&
         _file_is_image "${_target_path}"         &&
         [[ -n "${TERM_PROGRAM:-}"            ]]  &&
         [[ "${TERM_PROGRAM}" == "iTerm.app"  ]]  &&
         {
           [[ -z "${_tool}"          ]] ||
           [[ "${_tool}" == "imgcat" ]]
         }
    then
      imgcat "${_target_path}" \
        | if _command_exists "less" && ! ((_dump))
          then
            less -r --prompt="$(_less_prompt)"
          else
            cat
          fi
    elif _command_exists "magick"         &&
         _file_is_image "${_target_path}" &&
         {
           # Detect sixel support. Via: https://git.io/JfCel
           IFS=";" read -ra __reply -s -t 1 -d "c" -p $'\e[c' >&2
           [[ "${__reply[*]}" =~ 4 ]] || [[ "$TERM" == yaft* ]]
         } && {
           [[ -z "${_tool}"          ]] ||
           [[ "${_tool}" == "magick" ]]
         }
    then
      magick "${_target_path}" sixel:- \
        | if _command_exists "less" && ! ((_dump))
          then
            less -r --prompt="$(_less_prompt)"
          else
            cat
          fi
    elif [[ -n "${KITTY_WINDOW_ID:-}" ]]  &&
         _file_is_image "${_target_path}" &&
         {
           [[ -z "${_tool}"           ]]  ||
           [[ "${_tool}" == "icat"    ]]
         }
    then
      kitty +kitten icat "${_target_path}" \
        | if _command_exists "less" && ! ((_dump))
          then
            less -r --prompt="$(_less_prompt)"
          else
            cat
          fi
    elif _command_exists "mplayer"        &&
         _file_is_audio "${_target_path}" &&
         {
           [[ -z "${_tool}"           ]] ||
           [[ "${_tool}" == "mplayer" ]]
         }
    then
      printf "Playing audio. Press %s to quit.\\n" "$(_highlight "Ctrl-C")"
      mplayer "${_target_path}"
    elif _command_exists "afplay"         &&
         _file_is_audio "${_target_path}" &&
         {
           [[ -z "${_tool}"          ]] ||
           [[ "${_tool}" == "afplay" ]]
         }
    then
      printf "Playing audio. Press %s to quit.\\n" "$(_highlight "Ctrl-C")"
      afplay "${_target_path}"
    elif _command_exists "mpg123"                   &&
         _file_is_audio "${_target_path}"           &&
         [[ "${_target_path}" =~ mp1$|mp2$|mp3$ ]]  &&
         {
           [[ -z "${_tool}"          ]] ||
           [[ "${_tool}" == "mpg123" ]]
         }
    then
      printf "Playing audio. Press %s to quit.\\n" "$(_highlight "Ctrl-C")"
      mpg123 "${_target_path}"
    elif _command_exists "ffplay"         &&
         _file_is_audio "${_target_path}" &&
         {
           [[ -z "${_tool}"          ]] ||
           [[ "${_tool}" == "ffplay" ]]
         }
    then
      printf "Playing audio. Press %s to quit.\\n" "$(_highlight "Ctrl-C")"
      ffplay -loglevel quiet "${_target_path}"
    elif _command_exists "pdftotext" && [[ "${_target_path}" =~ pdf$ ]]
    then
      pdftotext "${_target_path}" - \
        | tr -d '\014' \
        | if [[ -n "${PAGER:-}"       ]] &&
             [[ ! "${PAGER}" =~ less  ]] &&
             ! ((_dump))
          then
            "${PAGER}"
          elif _command_exists "less" && ! ((_dump))
          then
            less --CLEAR-SCREEN --prompt="$(_less_prompt)"
          else
            cat
          fi
    elif [[ "${_target_path}" =~ docx$ ]] && _command_exists "pandoc"
    then
      pandoc --from docx --to markdown "${_target_path}" \
        | _highlight_syntax_if_available \
        | if [[ -n "${PAGER:-}"      ]] &&
             [[ ! "${PAGER}" =~ less ]] &&
             ! ((_dump))
          then
            "${PAGER}"
          elif _command_exists "less" && ! ((_dump))
          then
            less --CLEAR-SCREEN --prompt="$(_less_prompt)"
          else
            cat
          fi
    elif _command_exists "xdg-open"
    then
      xdg-open "${_target_path}"
    elif [[ "${OSTYPE}" =~ ^darwin ]]
    then
      open "${_target_path}"
    fi
  elif ((_render))              &&
       ((_dump))                &&
       _command_exists "pandoc" &&
       _command_exists "w3m"
  then # `show --render --dump` with `pandoc` and `w3m` available.
    pandoc "${_target_path}" \
      | w3m -dump -T text/html
  elif ((_render))              &&
       _command_exists "pandoc" &&
       _command_exists "w3m"
  then # `show --render` with `pandoc` and `w3m` available.
    pandoc "${_target_path}" \
      | w3m -T text/html
  elif ((_render))              &&
       _command_exists "pandoc" &&
       _command_exists "lynx"
  then # `show --render` with `pandoc` and `lynx` available.
    pandoc "${_target_path}" | lynx -stdin
  else # default
    if ((_dump))
    then # `show --dump [--no-color]`
      if ((_print_no_color))
      then # `show --dump --no-color`
        cat "${_target_path}"
      else # `show --dump`
        _highlight_syntax_if_available "${_target_path}"
      fi
    else # `show`
      if [[ -n "${PAGER:-}" ]] && [[ "${PAGER:-}" =~ less ]]
      then
        _highlight_syntax_if_available "${_target_path}" \
          | "${PAGER}" -R --CLEAR-SCREEN --prompt="$(_less_prompt)"
      elif _command_exists "less"
      then
        _highlight_syntax_if_available "${_target_path}" \
          | less -R --CLEAR-SCREEN --prompt="$(_less_prompt)"
      elif [[ -n "${PAGER:-}" ]]
      then
        _highlight_syntax_if_available "${_target_path}" | "${PAGER}"
      else
        _highlight_syntax_if_available "${_target_path}"
      fi
    fi
  fi

  if [[ -n "${_decrypted_path:-}" ]] && [[ -e "${_decrypted_path}" ]]
  then
    rm "${_decrypted_path}"
  fi
}
_alias_subcommand "show" "s"

# status ############################################################### status

desc "status" <<HEREDOC
Usage:
  ${_ME} status

Description:
  Run \`git status\` in the current notebook.
HEREDOC
_status() {
  cd "${_NOTEBOOK_PATH}" || _exit_1 printf "_status() \`cd\` failed.\\n"
  git status
}

# sync ################################################################### sync

desc "sync" <<HEREDOC
Usage:
  ${_ME} sync [-a | --all]

Options:
  -a, --all   Sync all active notebooks.

Description:
  Sync the current local notebook with the remote repository.
HEREDOC
_sync() {
  local _notebooks

  _debug printf "_sync() \${*}: '%s'\\n" "${*}"

  if [[ -n "${1:-}" ]] && [[ "${1}" =~ ^-a|--all$ ]]
  then
    _debug printf "_sync() -a|--all\\n"
    _notebooks=($(_notebooks --names --no-color --unarchived))
  else
    _notebooks=($(_notebooks current))
  fi

  _debug printf "_sync() \${_notebooks[*]:-}: '%s'\\n" "${_notebooks[*]:-}"

  printf "Syncing: "
  for __notebook in "${_notebooks[@]:-}"
  do
    printf "%s..." "${__notebook}"
    _NOTEBOOK_PATH="${NB_DIR}/${__notebook}"
    (NB_AUTO_SYNC=1 _git_checkpoint "[nb] Sync" --spinner)
  done &&
    printf "Done!\\n" ||
      printf "Syncing failed!\\n"
}

# update ############################################################### update

desc "update" <<HEREDOC
Usage:
  ${_ME} update

Description:
  Update ${_ME} to the latest version.
HEREDOC
_update() {
  local _current_path
  _current_path="${BASH_SOURCE[0]}"
  if [[ -n "${_current_path}" ]]
  then
    _current_path="$(realpath "${_current_path}")"
  fi

  if hash npm 2>/dev/null         &&
    npm list | grep -q notes.sh   &&
    [[ "${_current_path}" =~ \/node\/|\/node_modules\/ ]]
  then # installed with npm
    cat <<'HEREDOC'
Installed with npm. To update, run:
  npm update -g notes.sh
HEREDOC
  elif [[ "${OSTYPE}" =~ ^darwin        ]] &&
       [[ "${_current_path}" =~ Cellar  ]]
  then
    cat <<'HEREDOC'
Installed with Homebrew. To update, run:
  brew upgrade xwmx/taps/notes
HEREDOC
  else
    local _nb_url="${_REPO_RAW_URL}/nb"

    local _temp_file
    _temp_file="$(mktemp)"

    if ! _download_from "${_nb_url}" "${_temp_file}"
    then
      _exit_1 printf "Unable to download update.\\n"
    fi

    if [[ "$(_get_hash "${_temp_file}")" != "$(_get_hash "${_current_path}")" ]]
    then
      while true
      do
        printf "Updating %s in place. " "$(_highlight "${_ME}")"
        read -r -p "Are you sure you want to proceed? [y/N] " __yn
        case ${__yn} in
          [Yy]*)
            break
            ;;
          *)
            printf "Exiting...\\n"
            exit 0
            ;;
        esac
      done

      cat  "${_temp_file}" > "${_current_path}"
      printf "%s updated to the latest version.\\n" "$(_highlight "${_ME}")"
      exit 0
    else
      printf "Already at the latest version.\\n"
    fi

    if [[ -n "${_temp_file}" ]]
    then
      rm "${_temp_file}"
    fi
  fi
}
_alias_subcommand "update" "upgrade"

# use ##################################################################### use

desc "use" <<HEREDOC
Usage:
  ${_ME} use <notebook>

Description:
  Switch to the specified notebook. Shortcut for \`${_ME} notebooks use\`.

Shortcut Alias: \`u\`
HEREDOC
_use() {
  local _name="${1:-}"
  if [[ -z "${_name}" ]]
  then
    _exit_1 _help use
  fi
  _notebooks use "${_name}"
}
_alias_subcommand "use" "u"

# version ############################################################# version

desc "version" <<HEREDOC
Usage:
  ${_ME} version

Description:
  Display version information.
HEREDOC
_version() {
  printf "%s\\n" "${_VERSION}"
}

###############################################################################
# _nb_main()
###############################################################################

# _nb_main()
#
# Description:
#   Call the appropriate subcommand.
_nb_main() {
  _debug printf "_nb_main() >> start\\n"
  _debug printf "_nb_main() \${@}: '%s'\\n" "${@}"
  _debug printf "_nb_main() \${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"

  # Set `$_SUBCOMMAND` if it's still blank.
  if [[ -z "${_SUBCOMMAND:-}" ]]
  then
    _SUBCOMMAND="ls"
  fi

  if [[ -n "${_SCOPE}" ]]
  then
    _SCOPED=1
    if [[ "${_SCOPE}" == "local"          ]] &&
       [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"  ]]
    then
      _NOTEBOOK_PATH="${_LOCAL_NOTEBOOK_PATH}"
    else
      _NOTEBOOK_PATH="${NB_DIR}/${_SCOPE}"
    fi
  else
    if [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"                    ]] &&
       [[ "${_LOCAL_NOTEBOOK_PATH}" == "${_NOTEBOOK_PATH}"  ]]
    then
      _SCOPE="local"
    else
      _SCOPE="$(basename "${_NOTEBOOK_PATH}")"
    fi
  fi

  case "${_SUBCOMMAND}" in
    init|sync)
      _git_required
      "_${_SUBCOMMAND}" "${@}"
      ;;
    commands|completions|env|help|settings|version)
      "_${_SUBCOMMAND}" "${@}"
      ;;
    *)
      _git_required

      # Call `_init()` if configuration hasn't been initialized.
      if [[ ! -e "${NB_DIR}"          ]] ||
         [[ ! -e "${_NOTEBOOK_PATH}"  ]]
      then
        _git_required
        _init "${@}"
        _ls || true # returns 0 due to empty repository.
        return 0
      fi

      _debug printf "\${_SUBCOMMAND}: %s\\n" "${_SUBCOMMAND}"
      _debug printf \
        "\${_GIT_SUBCOMMANDS_PATTERN}: %s\\n" "${_GIT_SUBCOMMANDS_PATTERN}"

      if [[ "${_SUBCOMMAND}" =~ ${_GIT_SUBCOMMANDS_PATTERN} ]]
      then
        if _git_index_is_dirty
        then
          _index reconcile

          if _git_should_autosync
          then
            _debug \
              printf "_nb_main(): _git_index_is_dirty && ((NB_AUTO_SYNC))\\n"
            "${_MY_PATH}" sync
          else
            _debug \
              printf "_nb_main(): _git_index_is_dirty && ! ((NB_AUTO_SYNC))\\n"
            _git_checkpoint "[nb] Commit" --spinner
          fi
        elif _git_should_autosync
        then
          _debug \
            printf "_nb_main(): ! _git_index_is_dirty\\n"
          ("${_MY_PATH}" sync &>/dev/null) &
        fi
      fi

      "_${_SUBCOMMAND}" "${@}"
      ;;
  esac
}

###############################################################################
# Program Option Parsing
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring='h'

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while ((${#}))
do
  case "${1}" in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c="${1:i:1}"
        # add current char to options
        options+=("-${c}")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ "${optstring}" = *"${c}:"* && "${1:i+1}" ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("${@}")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("${1}")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_SCOPE=
_SCOPED=0
_ARGUMENTS=()

# $_SUBCOMMANDS
#
# All available subcommands.
_SUBCOMMANDS=(
  a
  add
  b
  bookmark
  bookmarks
  bs
  commands
  completions
  config
  count
  create
  d
  delete
  e
  edit
  export
  env
  git
  h
  help
  history
  import
  index
  init
  list
  ls
  move
  mv
  n
  nb
  nbs
  new
  notebook
  notebooks
  ns
  o
  open
  p
  peek
  preview
  q
  remote
  rename
  s
  search
  settings
  shell
  show
  status
  subcommands
  sync
  u
  update
  upgrade
  use
  version
)

# $_DOCUMENTED_SUBCOMMANDS
#
# Primary subcommands that appear in documentation. For example, aliases are
# omitted from this list. This list is also used for tab completion.
_DOCUMENTED_SUBCOMMANDS=(
  a
  add
  b
  bookmark
  commands
  completions
  count
  d
  delete
  e
  edit
  export
  env
  git
  h
  help
  history
  import
  init
  list
  ls
  move
  mv
  n
  notebooks
  o
  open
  p
  peek
  preview
  q
  remote
  rename
  s
  search
  settings
  shell
  show
  status
  sync
  u
  update
  use
  version
)

# $_GIT_SUBCOMMANDS
#
# Subcommands that initiate background cleanup commits and sync with remotes.
_GIT_SUBCOMMANDS=(
  a
  add
  b
  bookmark
  bookmarks
  bs
  count
  create
  d
  delete
  e
  edit
  export
  import
  list
  ls
  move
  mv
  n
  nb
  nbs
  new
  notebook
  notebooks
  ns
  o
  open
  p
  peek
  preview
  q
  rename
  s
  show
  search
  use
  u
)

# $_SUBCOMMANDS_PATTERN
#
# The contents of the `$_SUBCOMMANDS` array, joined with '|'.
_SUBCOMMANDS_PATTERN="^$(_join '$|^' "${_SUBCOMMANDS[@]}")$"

# $_GIT_SUBCOMMANDS_PATTERN
#
# The contents of the `$_GIT_SUBCOMMANDS` array, joined with '|'.
_GIT_SUBCOMMANDS_PATTERN="^$(_join '$|^' "${_GIT_SUBCOMMANDS[@]}")$"

_debug printf "\${_SUBCOMMANDS_PATTERN}: %s\\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\${_GIT_SUBCOMMANDS_PATTERN}: %s\\n" "${_GIT_SUBCOMMANDS_PATTERN}"

# _is_valid_subcommand()
#
# Usage:
#   _is_valid_subcommand <name>
#
# Returns:
#   0  If the given <name> is a valid subcommand name.
#   1  If not.
_is_valid_subcommand() {
  [[ -n "${1:-}" ]] &&  [[ "${1:-}" =~ ${_SUBCOMMANDS_PATTERN} ]]
}

# $_PREVIOUS_OPTION_WAS_FLAG
#
# Set to `1` when a flag option is found and use to avoid setting subcommand
# to a flag argument.
_PREVIOUS_OPTION_WAS_FLAG=0

# Parse program options.
while ((${#}))
do
  __opt="${1}"
  shift
  case "${__opt}" in
    -h|--help)
      if [[ "${_SUBCOMMAND}" == "git" ]]
      then
        _ARGUMENTS+=("${__opt}")
      else
        _PRINT_HELP=1
      fi
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      if [[ "${_SUBCOMMAND}" == "git" ]]
      then
        _ARGUMENTS+=("${__opt}")
      else
        _PRINT_VERSION=1
      fi
      ;;
    -i|--interactive)
      _SUBCOMMAND="shell"
      ;;
    --welcome)
      _print_welcome
      ;;
    *:*)
      __parts=($(printf "%s\\n" "${__opt}" | tr ":" "\\n"))
      if [[ -z "${_SCOPE:-}"        ]] &&
         [[ -z "${_SUBCOMMAND:-}"   ]] &&
         [[ "${#__parts[@]}" -gt 0  ]]
      then
        if [[ -d "${NB_DIR}/${__parts[0]}"      ]] ||
           {
             [[ "${__parts[0]}" == "local"      ]] &&
             [[ -n "${_LOCAL_NOTEBOOK_PATH:-}"  ]]
           }
        then
          _SCOPE="${__parts[0]}"
          if _is_valid_subcommand "${__parts[1]:-}"
          then
            _SUBCOMMAND="${__parts[1]:-}"
          fi
        else
          _exit_1 printf "Notebook not found: %s\\n" "${__parts[0]}"
        fi
      else
        _ARGUMENTS+=("${__opt}")
      fi
      ;;
    --endopts)
      # Terminate option parsing.
      break
      ;;
    *)
      if ! ((_PREVIOUS_OPTION_WAS_FLAG))  &&
         [[ -z "${_SUBCOMMAND:-}" ]]      &&
         _is_valid_subcommand "${__opt}"
      then
        _SUBCOMMAND="${__opt}"
      else
        if [[ "${__opt}" =~ ^- ]]
        then
          _PREVIOUS_OPTION_WAS_FLAG=1
        elif ((_PREVIOUS_OPTION_WAS_FLAG))
        then
          _PREVIOUS_OPTION_WAS_FLAG=0
        fi

        _ARGUMENTS+=("${__opt}")
      fi
      ;;
  esac
done

_debug printf "\${_SUBCOMMANDS[*]}: '%s'\\n" "${_SUBCOMMANDS[*]}"
_debug printf "\${_SUBCOMMANDS_PATTERN}: '%s'\\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\${_SUBCOMMAND}: '%s'\\n" "${_SUBCOMMAND}"
_debug printf "\${_SCOPE}: '%s'\\n" "${_SCOPE}"
_debug printf "\${_ARGUMENTS[*:-]}: '%s'\\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# _main()
###############################################################################

# _main()
#
# Usage:
#   _main "$@"
#
# Description:
#   Primary entry point for the program logic. Call this function at the end
#   of the script after everything has been defined.
_main() {
  if (("${_PRINT_HELP}"))
  then
    _help "${_SUBCOMMAND:-}"
  elif (("${_PRINT_VERSION}"))
  then
    _version
  else
    _nb_main "${_ARGUMENTS[@]:-}"
  fi
}

_main "${@:-}"
